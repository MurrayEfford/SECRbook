<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>Spatially Explicit Capture–Recapture</title>

    <meta name="author" content="Murray Efford" />
  
   <meta name="description" content="A handbook of SECR methods." />
   <meta name="generator" content="placeholder" />
  <meta property="og:title" content="Spatially Explicit Capture–Recapture" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="A handbook of SECR methods." />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Spatially Explicit Capture–Recapture" />
  
  <meta name="twitter:description" content="A handbook of SECR methods." />
  
  <!-- JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script>
  <script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script>
    <script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet" />
    <script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script>
    <script src="libs/bs3compat-0.6.1/transition.js"></script>
    <script src="libs/bs3compat-0.6.1/tabs.js"></script>
    <script src="libs/bs3compat-0.6.1/bs3compat.js"></script>
    <link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet" />
    <script src="libs/bs4_book-1.0.0/bs4_book.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script>

  <!-- CSS -->
  <style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
    <style type="text/css">
    /* Used with Pandoc 2.11+ new --citeproc when CSL is used */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
          margin-bottom: 0em;
        }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
    
</head>

<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<!--bookdown:title:start-->
<!--bookdown:title:end-->

<!--bookdown:toc:start-->
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book">
    <a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">Spatially Explicit Capture–Recapture</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
      </form>

      <nav aria-label="Table of contents">
        <h2>Table of contents</h2>
        <div id="book-toc"></div>

        <div class="book-extra">
          <p><a id="book-repo" href="#">View book source <i class="fab fa-github"></i></a></li></p>
        </div>
      </nav>
    </div>
  </header>

  <main class="col-sm-12 col-md-9 col-lg-7" id="content">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->
<div id="preface" class="section level1 unnumbered">
<h1 class="unnumbered">Preface</h1>
<p>This book is about the methods for describing animal populations that have
come to be called ‘spatially explicit capture–recapture’ or simply ‘spatial
capture–recapture’. We use ‘SECR’ as a general label for these data and models.</p>
<p>SECR data are observations of marked animals at known locations. The observations are from a well-defined regime of spatial sampling, most commonly with traps, cameras, or some other type of passive detector. SECR models are used to estimate parameters of the animal population,
particularly the population density.</p>
<div id="why-secr" class="section level2 unnumbered">
<h2 class="unnumbered">Why SECR?</h2>
<p>Non-spatial capture–recapture methods are highly developed and powerful <span class="citation">(<a href="#ref-obwa78">Otis et al. 1978</a>; <a href="#ref-wnc02">Williams, Nichols, and Conroy 2002</a>; <a href="#ref-cw">Cooch and White 2023</a>)</span>. SECR plugs some gaps in non-spatial methods (particularly with respect to density estimation), and has some unexpected benefits:</p>
<ol style="list-style-type: decimal">
<li><em>Freedom from edge effects</em><br />
Estimation of density with non-spatial capture–recapture is dogged by uncertain edge effects. SECR explicitly accounts for edge effects so density estimates are unbiased.</li>
<li><em>Reduced individual heterogeneity</em><br />
Unmodelled individual heterogeneity of detection is a universal source of bias in capture–recapture <span class="citation">(e.g., <a href="#ref-lc24">Laake and Collier 2024</a>)</span>. Spatial sampling is a potent source of heterogeneity, due to differential access to detectors. SECR models this component of heterogeneity, which then ceases to be a problem.</li>
<li><em>Scaleable detection model</em><br />
The core detection model in SECR describes the interaction between a single individual and a single detector. Parameter estimates can therefore be used to simulate sampling with novel detector configurations.</li>
<li><em>Coherent adjustment for effort</em><br />
Known variation in effort, including incomplete use of a detector array, can be modelled without ad hoc covariates.</li>
<li><em>Spatial pattern (covariates)</em><br />
SECR allows density to be modelled as a function of continuous spatial covariates.</li>
</ol>
</div>
<div id="why-this-book" class="section level2 unnumbered">
<h2 class="unnumbered">Why this book?</h2>
<p>The literature of SECR has grown beyond the attention spans and time budgets of most users. Major SECR publications are <span class="citation">Efford (<a href="#ref-e04">2004</a>)</span>, <span class="citation">Borchers and Efford (<a href="#ref-be08">2008</a>)</span>, <span class="citation">Royle et al. (<a href="#ref-rcsg14">2014</a>)</span>, <span class="citation">Borchers and Fewster (<a href="#ref-bf16">2016</a>)</span>, <span class="citation">Sutherland, Royle, and Linden (<a href="#ref-srl19">2019</a>)</span> and <span class="citation">Turek et al. (<a href="#ref-Turek2021">2021</a>)</span>.</p>
<p>This book provides both a gentle introduction, in the spirit of <span class="citation">(<a href="#ref-cw">Cooch and White 2023</a>)</span>, and more in-depth treatment of important topics. It is software oriented and therefore unashamedly partial and incomplete. Much of the content is drawn from earlier papers and the documentation of R <span class="citation">(<a href="#ref-R-base">R Core Team 2024</a>)</span> packages. Some topics are yet to be included (e.g., acoustic data) but documentation may be found on the <a href="https://www.otago.ac.nz/density/SECRinR.html">DENSITY</a> website. Others such as partial identity models <span class="citation">(<a href="#ref-Augustine2018">Augustine et al. 2018</a>)</span> have yet to be considered at all.</p>
<p>Part II is mostly independent of software. Other chapters lean heavily on the R package <strong>secr</strong>.</p>
</div>
<div id="software" class="section level2 unnumbered">
<h2 class="unnumbered">Software</h2>
<p>
The R package <strong>secr</strong> <span class="citation">(<a href="#ref-R-secr">Efford 2024</a>)</span> provides most of the functionality we will need.
It performs maximum likelihood estimation for a range of closed-population SECR models<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. The Windows application <a href="https://www.otago.ac.nz/density/">DENSITY</a> <span class="citation">(<a href="#ref-edr04">Efford, Dawson, and Robbins 2004</a>)</span> has been superceded, although its graphical interface can still come in handy.</p>
<p>Bayesian approaches using Markov chain Monte Carlo (MCMC) methods are a flexible alternative to maximum likelihood. The R package <a href="https://CRAN.R-project.org/package=nimbleSCR">nimbleSCR</a> promises to make these methods more accessible<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>.</p>
<p>Add-on packages extend the capability of <strong>secr</strong>:</p>
<ul>
<li><strong>secrlinear</strong> enables the estimation of linear density (e.g., animals per km) for populations in linear habitats such as stream networks (<a href="https://CRAN.R-project.org/package=secrlinear/vignettes/secrlinear-vignette.pdf">secrlinear-vignette.pdf</a>).</li>
<li><strong>ipsecr</strong> fits models by simulation and inverse prediction, rather than maximum likelihood; this is a rigorous way to analyse data from single-catch traps (<a href="https://CRAN.R-project.org/package=ipsecr/vignettes/ipsecr-vignette.pdf">ipsecr-vignette.pdf</a>).</li>
<li><strong>secrdesign</strong> enables the assessment of alternative study designs by Monte Carlo simulation; scenarios may differ in detector (trap) layout, sampling intensity, and other characteristics (<a href="https://www.otago.ac.nz/density/pdfs/secrdesign-vignette.pdf%5D">secrdesign-vignette.pdf</a>).</li>
<li><strong>openCR</strong> <span class="citation">(<a href="#ref-es20">Efford and Schofield 2020</a>)</span> implements open-population models.</li>
</ul>
<p>These packages are available from the <a href="https://cran.r-project.org/">CRAN</a> repository – just open R and type <code>install.packages('xxxx')</code> where xxxx is the package name.</p>
<p>Other R packages for SECR may be found outside CRAN. A distinct maximum-likelihood implementation by <span class="citation">Sutherland, Royle, and Linden (<a href="#ref-srl19">2019</a>)</span> is available on GitHub (<a href="https://github.com/jaroyle/oSCR" class="uri">https://github.com/jaroyle/oSCR</a>). Open-population packages by Ben Augustine and Richard Glennie are also available on GitHub (<a href="https://github.com/benaug/OpenPopSCR" class="uri">https://github.com/benaug/OpenPopSCR</a>; <a href="https://github.com/r-glennie/openpopscr" class="uri">https://github.com/r-glennie/openpopscr</a>).</p>
</div>
<div id="acknowledgments" class="section level2 unnumbered">
<h2 class="unnumbered">Acknowledgments</h2>
<p>Joanne Potts and Gurutzeta Guillera-Arroita gave helpful comments on an early version of the habitat chapter.</p>
<p>Thanks for data -</p>
<ul>
<li>Ken Burnham snowshoe hares Chapter @ref(Example)</li>
<li>Jared Laufenburg black bears Chapter @ref(Habitat)</li>
<li>Kevin Young horned lizards Appendix @ref(Areaandtransectsearches)</li>
<li>Garth Mowat Selkirk grizzly bears Appendix @ref(Noneuclidean)</li>
<li>Chris Sutherland non-euclidean simulation Appendix @ref(Noneuclidean)</li>
</ul>
<p><img src="figures/by-nc-sa.png" width="15%" /></p>
<p>The online version of this book is licensed under the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.</p>
<!--chapter:end:index.Rmd-->
</div>
</div>
<div id="part-introduction-to-secr" class="section level1 unnumbered">
<h1 class="unnumbered">(PART*) Introduction to SECR</h1>
</div>
<div id="Basics" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Concepts and terminology</h1>
<p>This chapter briefly introduces the concepts and terminology of SECR. The following chapter provides a <a href="#Example">simple example</a>, and the <a href="#theory">Theory</a> chapter provides technical details.</p>
<div id="spatial-population" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> Spatial population</h2>
<p>An animal population in SECR is a spatial point pattern, where each point
represents the location of an animal’s activity centre<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>.
Density is a property of the spatial point process of which the pattern is one instance. The usual process model is a 2-dimensional Poisson process (Fig. @ref(fig:example)). By fitting the SECR model we can estimate the intensity surface of the Poisson process that we represent by <span class="math inline">\(D(\vec x)\)</span> where <span class="math inline">\(\vec x\)</span> stands for the x,y coordinates of a point. The surface may be <em>homogeneous</em> (flat, with constant <span class="math inline">\(D(\vec x)\)</span>) or <em>inhomogeneous</em> (varying).</p>
<p>The intensity surface is better represented as depending on a vector of parameters <span class="math inline">\(\phi\)</span>, hence <span class="math inline">\(D(\vec x; \phi)\)</span>. For constant density <span class="math inline">\(\phi\)</span> is a single value.</p>
</div>
<div id="detectors" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> Detectors</h2>
<p>
SECR uses sampling devices placed at known locations. We need to recognise individuals whenever they are detected. The accumulated detections of each known individual are its ‘detection history’. Device types differ according to how they affect animal behaviour and the data they collect; each type corresponds to a probability model, as covered later.</p>
<p>Detection may be entirely passive and non-invasive when individuals carry unique natural marks (e.g., pelage patterns) or their DNA can be sampled. We call such devices “proximity detectors”. Proximity detectors may be split according to the distribution of the number of detections per animal per occasion (binary, Poisson, or binomial), with binary the most common.</p>
<p>Animals without natural marks must be marked individually on their first detection. This implies capture and handling. Only devices that hold an animal until it is released can truly be called ‘traps’. The probability model for trapping must allow for exclusivity: an animal can be found at only one trap on any occasion, and some traps (‘single-catch’ traps) also exclude other individuals after the first.</p>
<p>Confusingly, <strong>secr</strong> uses ‘traps’ as a generic name for R objects holding detector coordinates and other information. This software-specific jargon should be avoided in publications.</p>
<table>
<caption>(#tab:deviceexamples) Examples of SECR sampling</caption>
<colgroup>
<col width="15%" />
<col width="25%" />
<col width="21%" />
<col width="37%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Device</th>
<th align="left">Marks</th>
<th align="left">Type</th>
<th align="left">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Automatic camera</td>
<td align="left">natural marks: stripes and spot patterns</td>
<td align="left">proximity detector</td>
<td align="left">tiger, <span class="citation">Royle, Karanth, et al. (<a href="#ref-Royle2009">2009</a>)</span></td>
</tr>
<tr class="even">
<td align="left">Hair snag</td>
<td align="left">microsatellite DNA</td>
<td align="left">proximity detector</td>
<td align="left">grizzly bear, <span class="citation">Mowat and Strobeck (<a href="#ref-ms00">2000</a>)</span></td>
</tr>
<tr class="odd">
<td align="left">Cage trap</td>
<td align="left">numbered ear tag</td>
<td align="left">single-catch trap</td>
<td align="left">brushtail possum, <span class="citation">Efford et al. (<a href="#ref-ewcb05">2005</a>)</span></td>
</tr>
<tr class="even">
<td align="left">Ugglan trap</td>
<td align="left">numbered ear tag</td>
<td align="left">multi-catch trap</td>
<td align="left">field vole, <span class="citation">Ergon and Gardner (<a href="#ref-Ergon2013">2013</a>)</span></td>
</tr>
<tr class="odd">
<td align="left">Mist net</td>
<td align="left">numbered leg band</td>
<td align="left">multi-catch trap</td>
<td align="left">red-eyed vireo, <span class="citation">Borchers and Efford (<a href="#ref-be08">2008</a>)</span></td>
</tr>
</tbody>
</table>
</div>
<div id="sampling-across-time" class="section level2" number="1.3">
<h2><span class="header-section-number">1.3</span> Sampling across time</h2>
<p>For most vertebrates we expect population turnover (births, deaths, AC movement) to happen on time scales of months or years. A population sampled over shorter intervals (days or weeks) can therefore be considered closed. A ‘session’ in <strong>secr</strong> parlance is a set of samples from a closed population on one or more ‘occasions’ (possibly consecutive days).</p>
<p>Distinguishing occasions within a session is necessary for trap-type detectors (there would otherwise be no recaptures). For proximity-type detectors the role of ‘occasions’ is more subtle, and data may usually be collapsed to animal- and detector-specific counts. The spatial pattern of binary detections alone is sufficient to obtain an estimate of density <span class="citation">(<a href="#ref-edb09">Efford, Dawson, and Borchers 2009</a>)</span>.</p>
<p>It is not necessary for all detectors to be used on all occasions. Incomplete usage <span class="citation">(and other variation in effort per occasion – <a href="#ref-ebm13">Efford, Borchers, and Mowat 2013</a>)</span> may be recorded for each detector as an attribute of ‘traps’ objects.</p>
<p>Data collected across multiple sessions potentially include losses of some individuals and gains of others. An open population model is the natural way to go, e.g., <span class="citation">Efford and Schofield (<a href="#ref-es20">2020</a>)</span>. However, the complexity of open-population models can be avoided if sessions are treated as independent in a ‘multi-session’ closed population analysis.</p>
</div>
<div id="data-structure" class="section level2" number="1.4">
<h2><span class="header-section-number">1.4</span> Data structure</h2>
<p>
Data for a single SECR session comprise a 3-dimensional rectangular array with dimensions corresponding to known animals, sampling occasions, and detectors. Data in each cell of the array are usually binary (0/1) but may be integer counts &gt; 1 (e.g., if binary data have been collapsed by occasion). In <strong>secr</strong>, an R Object of class ‘capthist’ holds data in this form, along with the coordinates of the detectors in its ‘traps’ attribute. The user constructs a capthist object from text or spreadsheet input using data entry functions described <a href="https://cran.r-project.org/web/packages/secr/vignettes/secr-datainput.pdf">here</a>.</p>
</div>
<div id="model-fitting" class="section level2" number="1.5">
<h2><span class="header-section-number">1.5</span> Model fitting</h2>
<p>A SECR model combines a model for the point process (the state model) and a
model for distance-dependent detection (the observation model). Unbiased estimates
of population density (and other parameters) by jointly fitting the state and observation models.</p>
<div id="distance-dependent-detection" class="section level3" number="1.5.1">
<h3><span class="header-section-number">1.5.1</span> Distance-dependent detection</h3>
<p>In order to estimate density from a sample we must account for the sampling process. The process is inherently spatial: each animal is more likely to be detected near its AC, and less likely to be detected far away. Sampling filters the geographic locations of animals as indicated in Fig. @ref(fig:example).</p>
<div class="figure">
<img src="figures/example.png" alt="Distance-dependent detection of uniformly distributed activity centres (open circles; filled if captured)" width="70%" />
<p class="caption">
(#fig:example)Distance-dependent detection of uniformly distributed activity centres (open circles; filled if captured)
</p>
</div>
<p>The true locations of animals are not known, and therefore the distance-dependent probabilities cannot be calculated directly. The model is fitted by marginalising (integrating over) animal locations.</p>
Distance-dependent detection is represented by a ‘detection function’ with intercept, scale, and possibly shape, determined by parameters to be estimated<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>.
<div class="figure">
<img src="SECRbook_files/figure-html/detectionfunctions-1.png" alt="Some detection functions" width="75%" />
<p class="caption">
(#fig:detectionfunctions)Some detection functions
</p>
</div>
</div>
<div id="habitat" class="section level3" number="1.5.2">
<h3><span class="header-section-number">1.5.2</span> Habitat</h3>
<p>SECR models include a map of potential habitat near the detectors. Here ‘potential’ means ‘feasible locations for the AC of detected animals’. Excluded are sites that are known <em>a priori</em> to be unoccupied, and sites that are so distant that an animal centred there has negligible chance of detection.</p>
<p>The habitat map is called a ‘habitat mask’ in <strong>secr</strong> and a ‘state space’ in the various Bayesian implementations. It is commonly formed by adding a constant-width buffer around the detectors. For computational convenience the map is discretized as many small pixels. Spatial covariates (vegetation type, elevation, etc.) may be attached to each pixel for use in density models. The choice of buffer width and pixel size are considered later.</p>
</div>
<div id="link" class="section level3" number="1.5.3">
<h3><span class="header-section-number">1.5.3</span> Link functions</h3>
<p>
A simple SECR model has three parameters: density <span class="math inline">\(D\)</span>, and the intercept <span class="math inline">\(g_0\)</span> and spatial scale <span class="math inline">\(\sigma\)</span> of the detection function. Valid values of each parameter are restricted to part of the number line (positive values for <span class="math inline">\(D\)</span> and <span class="math inline">\(\sigma\)</span>, values between zero and one for <span class="math inline">\(g_0\)</span>). A straightforward way to constrain estimates to valid values is to conduct maximization of the likelihood on a transformed (‘link’) scale: at each evaluation the parameter value is back transformed to the natural scale. The link function for all commonly used parameters defaults to ‘log’ (for positive values) except for g0 which defaults to ‘logit’ (for values between zero and one).</p>
<table>
<caption>(#tab:links) Link functions.</caption>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Function</th>
<th align="left">Inverse</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">log</td>
<td align="left"><span class="math inline">\(y = \log(x)\)</span></td>
<td align="left"><span class="math inline">\(\exp(y)\)</span></td>
</tr>
<tr class="even">
<td align="left">logit</td>
<td align="left"><span class="math inline">\(y = \log[p/(1-p)]\)</span></td>
<td align="left"><span class="math inline">\(1 / [1 + \exp(-y)]\)</span></td>
</tr>
<tr class="odd">
<td align="left">identity</td>
<td align="left"><span class="math inline">\(y=x\)</span></td>
<td align="left">y</td>
</tr>
</tbody>
</table>
<p>Working on a link scale is especially useful when the parameter is itself a function of covariates. For example, <span class="math inline">\(\log (D) = \beta_0 + \beta_1 c \;\)</span> for a log-linear function of a spatially varying covariate <span class="math inline">\(c\)</span>. The coefficients <span class="math inline">\(\beta_0\)</span> and <span class="math inline">\(\beta_1\)</span> are estimated in place of <span class="math inline">\(D\)</span> per se.</p>
<p>We sometimes use the terminology of ‘beta’ parameters (coefficients on the link scale) and ‘real’ parameters (on the natural scale) that is derived from MARK <span class="citation">(<a href="#ref-cw">Cooch and White 2023</a>)</span>.</p>
<!-- cloglog -->
</div>
<div id="estimation" class="section level3" number="1.5.4">
<h3><span class="header-section-number">1.5.4</span> Estimation</h3>
<p>
</p>
<p>There are several ways to estimate the parameters of the SECR probability model, all of them computer-intensive. We focus on numerical maximization of the log likelihood (<span class="citation">Borchers and Efford (<a href="#ref-be08">2008</a>)</span> and Chapter @ref(Theory)). The likelihood integrates over the unknown locations of the animals’ activity centres. This is achieved in practice by summing over cells in a discretized map of the <a href="#Habitat">habitat</a>.</p>
<p>In outline, a function to compute the log likelihood from a vector of beta parameters is passed, along with the data, to an optimization function. Optimization is iterative. For illustration, Fig. @ref(fig:MLE) shows the sequence of likelihood evaluations with two maximization algorithms when the parameter vector consists of only the intercept and spatial scale of detection. Optimization returns the maximized log likelihood, a vector of parameter values at the maximum, and the Hessian matrix from which the variance-covariance matrix of the estimates may be obtained.</p>
<div class="figure">
<img src="SECRbook_files/figure-html/MLE-1.png" alt="Numerical maximization of conditional likelihood by two methods; triangle -- initial values; filled circle -- estimates. Both converge on the same estimates (dashed lines). Newton-Raphson is the default method in **secr**." width="100%" />
<p class="caption">
(#fig:MLE)Numerical maximization of conditional likelihood by two methods; triangle – initial values; filled circle – estimates. Both converge on the same estimates (dashed lines). Newton-Raphson is the default method in <strong>secr</strong>.
</p>
</div>
<p>Bayesian methods make use of algorithms that sample from a Markov chain (MCMC) to approximate the posterior distribution of the parameters. MCMC for abundance estimation faces the special problem that an unknown number of individuals, at unknown locations, remain undetected. The issue is addressed by data augmentation <span class="citation">(<a href="#ref-ry08">Royle and Young 2008</a>)</span> or using a semi-complete data likelihood <span class="citation">(<a href="#ref-Zhang2022">Zhang et al. 2022</a>)</span>.</p>
<p>Early anxiety about the suitability of MLE and asymptotic variances for SECR with small samples appears to have been mistaken. <span class="citation">Royle, Karanth, et al. (<a href="#ref-Royle2009">2009</a>)</span> believed that “… the practical validity of these procedures cannot be asserted in most situations involving small samples”. This has not been borne out by subsequent simulations. The choice between Bayesian and frequentist (MLE) methods is now an issue of convenience for most users. MLE provides fast and repeatable results for established models with a small to medium number of parameters. Bayesian methods have an advantage for novel models and those with many parameters, although the crossover point has not been demonstrated.</p>
<!-- "As the underlying point process model is made more complex (e.g., containing interactions and conditional dependencies) the integration required for inference by integrated likelihood may become computationally prohibitive. [...] we feel that the biggest practical advantage apparent at this time has to do with the validity of inferences achieved by Bayesian analysis. In particular, classical inference procedures are asymptotic and as such their relevance to small sample situations is questionable. Conversely, Bayesian inferences do not rely on asymptotic arguments and are valid regardless of the sample size. There seems to be a prevailing view in statistical ecology that classical likelihood-based procedures are virtuous because of the availability of simple formulas and procedures for carrying out inference, such as calculating standard errors, doing model selection by AIC, and assessing goodness of fit. In large samples, this is an important practical benefit of classical likelihood-based inference. However, the practical validity of these procedures cannot be asserted in most situations involving small samples." -->
<p>A further method, simulation and inverse prediction, has a niche use for data from single-catch traps <span class="citation">(<a href="#ref-edr04">Efford, Dawson, and Robbins 2004</a>; <a href="#ref-Efford2023">Efford 2023c</a>)</span>.</p>
<!--chapter:end:01-basics.Rmd-->
</div>
</div>
</div>
<div id="Example" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Simple example</h1>
<p></p>
<p>We use the Alaskan snowshoe hare data of Burnham and Cushwa <span class="citation">(<a href="#ref-obwa78">Otis et al. 1978</a>)</span><a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>.</p>
<p><img src="figures/snowshoehare.png" width="40%" /><img src="figures/otisetal.png" width="40%" /></p>
<blockquote>
<p>“In 1972, Burnham and Cushwa (pers. comm.) laid out a livetrapping grid in a black spruce forest 30 miles (48.3 km) north of Fairbanks, Alaska. The basic grid was 10 x 10, with traps spaced 200 feet (61 m) apart. Trapping for snowshoe hares was carried out for 9 consecutive days in early winter. Traps were not baited for the first 3 days, and therefore we have chosen to analyze the data from the last 6 days of trapping.”</p>
<p><span class="citation">Otis et al. (<a href="#ref-obwa78">1978, 36</a>)</span></p>
</blockquote>
<div id="input-data" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Input data</h2>
<p>The raw data are in two text files, the capture file and the trap layout file. Data from <span class="citation">Otis et al. (<a href="#ref-obwa78">1978</a>)</span> have been transformed for <strong>secr</strong> (code in <a href="https://www.otago.ac.nz/density/pdfs/secr-tutorial.pdf">secr-tutorial.pdf</a>). The files may be downloaded to the current directory with</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>fnames <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;hareCH6capt.txt&quot;</span>, <span class="st">&quot;hareCH6trap.txt&quot;</span>)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>url <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">&#39;https://www.otago.ac.nz/density/examples/&#39;</span>, fnames)</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="fu">download.file</span>(url, fnames, <span class="at">method =</span> <span class="st">&quot;libcurl&quot;</span>)</span></code></pre></div>
<p>The capture file “hareCH6capt.txt” has one line per capture and four columns (header lines are commented out and are not needed). Here we display the first 6 lines. The first column is a session label derived from the original study name; here there is only one session.</p>
<pre><code># Burnham and Cushwa snowshoe hare captures
# Session ID Occasion Detector 
wickershamunburne  1 2 0201
wickershamunburne 19 1 0501
wickershamunburne 72 5 0601
wickershamunburne 73 6 0601
... </code></pre>
<p>The trap layout file “hareCH6trap.txt” has one row per trap and columns for the detector label and x- and y-coordinates. We display the first 6 lines. The detector label is used to link captures to trap sites. Coordinates can relate to any rectangular coordinate system; <strong>secr</strong> will assume distances are in metres. These coordinates simply describe a 10 <span class="math inline">\(\times\)</span> 10 square grid with spacing 60.96 m. Do not use unprojected geographic coordinates (latitude and longitude)<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>.</p>
<pre><code># Burnham and Cushwa snowshoe hare trap layout
# Detector  x  y 
0101 0 0
0201 60.96 0
0301 121.92 0
0401 182.88 0
... </code></pre>
<p>We load <strong>secr</strong> and read the data files to construct a capthist object. The detectors are single-catch traps (maximum of one capture per animal per occasion and one capture per trap per occasion).</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="fu">library</span>(secr)</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>hareCH6 <span class="ot">&lt;-</span> <span class="fu">read.capthist</span>(<span class="st">&quot;hareCH6capt.txt&quot;</span>, <span class="st">&quot;hareCH6trap.txt&quot;</span>, </span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>                         <span class="at">detector =</span> <span class="st">&quot;single&quot;</span>)</span></code></pre></div>
<pre><code>## No errors found :-)</code></pre>
<pre><code>## [1] TRUE TRUE</code></pre>
<p>The capthist object <code>hareCH6</code> now contains almost all the information needed to fit a model.</p>
</div>
<div id="check-data" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> Check data</h2>
<p>Type <code>summary(hareCH6)</code> for a summary of the data. These are <em>spatial</em> data so we learn a lot by mapping them. The <code>plot</code> method for capthist objects has additional arguments; set <code>tracks = TRUE</code> to join consecutive captures of each individual.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">1</span>))  <span class="co"># reduce margins</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="fu">plot</span> (hareCH6, <span class="at">tracks =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="figure" style="text-align: center">
<img src="SECRbook_files/figure-html/cap-1.png" alt="Snowshoe hare spatial capture data. Trap sites (red crosses) are 61 m apart. Grid lines (grey) are 100 m apart (use arguments `gridl` and `gridsp` to suppress the grid or vary its spacing). Colours help distinguish individuals, but some are recycled." width="336" />
<p class="caption">
(#fig:cap)Snowshoe hare spatial capture data. Trap sites (red crosses) are 61 m apart. Grid lines (grey) are 100 m apart (use arguments <code>gridl</code> and <code>gridsp</code> to suppress the grid or vary its spacing). Colours help distinguish individuals, but some are recycled.
</p>
</div>
<p>The most important insight is that individuals tend to be recaptured near their site of first capture. This is expected when the individuals of a species occupy home ranges. In SECR models the tendency for detections to be localised is reflected in the spatial scale parameter <span class="math inline">\(\sigma\)</span>. Good estimation of <span class="math inline">\(\sigma\)</span> and density <span class="math inline">\(D\)</span> requires spatial recaptures (i.e. captures at sites other than the site of first capture).</p>
<p>Successive trap-revealed movements can be extracted with the <code>moves</code> function and summarised with <code>hist</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>m <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">moves</span>(hareCH6))</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="fl">3.2</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">1</span>), <span class="at">mgp =</span> <span class="fu">c</span>(<span class="fl">2.1</span>,<span class="fl">0.6</span>,<span class="dv">0</span>))  <span class="co"># reduce margins</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="fu">hist</span>(m, <span class="at">breaks =</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">500</span>,<span class="dv">61</span>), <span class="at">xlab =</span> <span class="st">&quot;Movement  m&quot;</span>, <span class="at">main =</span> <span class="st">&quot;&quot;</span>)</span></code></pre></div>
<div class="figure" style="text-align: center">
<img src="SECRbook_files/figure-html/moves-1.png" alt="Trap-revealed movements of snowshoe hares" width="336" />
<p class="caption">
(#fig:moves)Trap-revealed movements of snowshoe hares
</p>
</div>
<p>About 30% of trap-revealed movements were of <span class="math inline">\(&gt;\)</span> 100 m (Fig. @ref(fig:moves); try also <code>plot(ecdf(m))</code>), so we can be sure that peripheral hares stood a good chance of being trapped even if their home ranges were centred well outside the area plotted in Fig. @ref(fig:cap).</p>
</div>
<div id="fit-a-simple-model" class="section level2" number="2.3">
<h2><span class="header-section-number">2.3</span> Fit a simple model</h2>
<p>Next we fit the simplest possible SECR model with function <code>secr.fit</code>. The <code>buffer</code> argument determines the habitat extent - we take a stab at this and check it later. Setting <code>trace = FALSE</code> suppresses printing of intermediate likelihood evaluations; it doesn’t hurt to leave it out. We save the fitted model with the name ‘fit’. Fitting is much faster if we use parallel processing in multiple threads - the number will depend on your machine, but 7 is OK for Windows with a quad-core processor.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="fu">secr.fit</span> (hareCH6, <span class="at">buffer =</span> <span class="dv">250</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>, <span class="at">ncores =</span> <span class="dv">7</span>)</span></code></pre></div>
<pre><code>## Warning: multi-catch likelihood used for single-catch traps</code></pre>
<p>A warning is generated. The data are from single-catch traps, but there is no usable theory for likelihood-based estimation from single-catch traps. This is not the obstacle it might seem, because simulations seem to show that the alternative likelihood for multi-catch traps may be used without damaging the density estimates <span class="citation">(<a href="#ref-ebb09">Efford, Borchers, and Byrom 2009</a>)</span>. It is safe to ignore the warning for now<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>.
<!-- We could avoid the warning by resetting the detector type to "multi". -->
<!-- ```{r multi} -->
<!-- detector(traps(hareCH6)) <- "multi" -->
<!-- ``` --></p>
</div>
<div id="output" class="section level2" number="2.4">
<h2><span class="header-section-number">2.4</span> Output</h2>
<p>The output from <code>secr.fit</code> is an object of class ‘secr’. If you investigate the structure of <code>fit</code> with <code>str(fit)</code> it will seem to be a mess: it is a list with more than 25 components, none of which contains the final estimates you are looking for.</p>
<p>To examine model output or extract particular results you should use one of the functions defined for the purpose. Technically, these are S3 methods for the class ‘secr’. The key methods are <code>print,</code> <code>plot,</code> <code>AIC,</code> <code>coef,</code> <code>vcov,</code> and <code>predict.</code> Append ‘.secr’ when seeking help e.g. <code>?print.secr</code>.</p>
<p>Typing the name of the fitted model at the R prompt invokes the print method for <code>secr</code> objects and displays a more useful report.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>fit</span></code></pre></div>
<pre><code>## 
## secr.fit(capthist = hareCH6, buffer = 250, trace = FALSE, ncores = 7)
## secr 4.6.6, 13:59:46 22 Feb 2024
## 
## Detector type      single 
## Detector number    100 
## Average spacing    60.96 m 
## x-range            0 548.64 m 
## y-range            0 548.64 m 
## 
## N animals       :  68  
## N detections    :  145 
## N occasions     :  6 
## Mask area       :  104.595 ha 
## 
## Model           :  D~1 g0~1 sigma~1 
## Fixed (real)    :  none 
## Detection fn    :  halfnormal
## Distribution    :  poisson 
## N parameters    :  3 
## Log likelihood  :  -607.988 
## AIC             :  1221.98 
## AICc            :  1222.35 
## 
## Beta parameters (coefficients) 
##            beta  SE.beta       lcl       ucl
## D      0.382528 0.129950  0.127831  0.637226
## g0    -2.723792 0.160932 -3.039212 -2.408371
## sigma  4.224580 0.065323  4.096549  4.352610
## 
## Variance-covariance matrix of beta parameters 
##                 D          g0       sigma
## D      0.01688706 -0.00173068 -0.00162336
## g0    -0.00173068  0.02589902 -0.00737561
## sigma -0.00162336 -0.00737561  0.00426709
## 
## Fitted (real) parameters evaluated at base levels of covariates 
##        link  estimate SE.estimate        lcl        ucl
## D       log  1.465986  0.19131237  1.1363604  1.8912274
## g0    logit  0.061584  0.00930047  0.0456855  0.0825366
## sigma   log 68.345782  4.46931584 60.1324236 77.6809846</code></pre>
<p>The report comprises these sections:</p>
<ul>
<li>function call and time stamp</li>
<li>summary of the data</li>
<li>description of the model, including the maximized log likelihood, Akaike’s Information Criterion AIC</li>
<li>estimates of model coefficients (‘beta’ parameters)</li>
<li>estimates of variance-covariance matrix of the coefficients</li>
<li>estimates of the ‘real’ parameters</li>
</ul>
<p>The last three items are generated by the <code>coef</code>, <code>vcov</code> and <code>predict</code> methods respectively. The final table of estimates is the most interesting, but it is derived from the other two. For our simple model there is one beta parameter for each real parameter<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a>. The estimated density is 1.47 hares per hectare, 95% confidence interval 1.14–1.89 hares per hectare<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a>.</p>
<p>The other two real parameters jointly determine the detection function that you can easily plot with 95% confidence limits:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">1</span>))  <span class="co"># adjust white margins</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="fu">plot</span>(fit, <span class="at">limits =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="figure" style="text-align: center">
<img src="SECRbook_files/figure-html/plotfit-1.png" alt="Fitted halfnormal detection function, with 95% confidence limits" width="336" />
<p class="caption">
(#fig:plotfit)Fitted halfnormal detection function, with 95% confidence limits
</p>
</div>
</div>
<div id="revisiting-buffer-width" class="section level2" number="2.5">
<h2><span class="header-section-number">2.5</span> Revisiting buffer width</h2>
<p>Choosing a buffer width is a common stumbling block. We used <code>buffer = 250</code> without any explanation. Here it is. As far as we know, the snowshoe hare traps were surrounded by suitable habitat. We limit our attention to the area immediately around the traps by specifying a habitat buffer. The <code>buffer</code> argument is a short-cut for defining the potential habitat (area of integration); the alternative is to provide a habitat mask in the <code>mask</code> argument. Buffers and habitat masks are covered at length in Chapter @ref(Habitat).</p>
<p>Buffer width is not critical as long as it is wide enough that animals at the edge have effectively zero chance of appearing in our sample, so that increasing the buffer has negligible effect on estimates. For half-normal detection (the default) a buffer of <span class="math inline">\(4\sigma\)</span> is usually enough<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a>. We check the present model with the function <code>esa.plot</code>. The estimated density<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a> has easily reached a plateau at the chosen buffer width (dashed red line):</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">1</span>))  <span class="co"># adjust white margins</span></span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a><span class="fu">esa.plot</span>(fit)</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v =</span> <span class="dv">250</span>, <span class="at">lty =</span> <span class="dv">2</span>, <span class="at">col =</span> <span class="st">&#39;red&#39;</span>)</span></code></pre></div>
<div class="figure" style="text-align: center">
<img src="SECRbook_files/figure-html/esaplot-1.png" alt="Post hoc evaluation of buffer width using `esa.plot()` " width="432" />
<p class="caption">
(#fig:esaplot)Post hoc evaluation of buffer width using <code>esa.plot()</code>
</p>
</div>
</div>
<div id="overall-probability-of-detection" class="section level2" number="2.6">
<h2><span class="header-section-number">2.6</span> Overall probability of detection</h2>
<p>As a final flourish, we plot contours of the overall probability of detection <span class="math inline">\(p_\cdot(\vec x; \theta)\)</span> as a function of AC location <span class="math inline">\(\vec x\)</span>, given the fitted model. The white line is the outer edge of the automatic mask generated by <code>secr.fit</code> with a 250-m buffer.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>tr <span class="ot">&lt;-</span> <span class="fu">traps</span>(hareCH6)   <span class="co"># just the traps</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>dp <span class="ot">&lt;-</span> <span class="fu">detectpar</span>(fit)   <span class="co"># extract detection parameters from simple model</span></span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>mask300 <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(tr, <span class="at">nx =</span> <span class="dv">128</span>, <span class="at">buffer =</span> <span class="dv">300</span>)  </span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="fu">covariates</span>(mask300)<span class="sc">$</span>pd <span class="ot">&lt;-</span> <span class="fu">pdot</span>(mask300, tr, <span class="at">detectpar =</span> dp, </span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>     <span class="at">noccasions =</span> <span class="dv">6</span>)</span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">5</span>))  <span class="co"># adjust white margin</span></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a><span class="fu">plot</span>(mask300, <span class="at">cov =</span> <span class="st">&#39;pd&#39;</span>, <span class="at">dots =</span> <span class="cn">FALSE</span>, <span class="at">border =</span> <span class="dv">1</span>, <span class="at">inset =</span> <span class="fl">0.1</span>, </span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a>     <span class="at">title =</span> <span class="st">&#39;p.(x)&#39;</span>)</span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a><span class="fu">plot</span>(tr, <span class="at">add =</span> <span class="cn">TRUE</span>)   <span class="co"># over plot trap locations</span></span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a><span class="fu">pdot.contour</span>(tr, <span class="at">nx =</span> <span class="dv">128</span>, <span class="at">detectfn =</span> <span class="st">&#39;HN&#39;</span>, <span class="at">detectpar =</span> dp, </span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a>     <span class="at">noccasions =</span> <span class="dv">6</span>, <span class="at">add =</span> <span class="cn">TRUE</span>)</span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a><span class="fu">plotMaskEdge</span>(<span class="fu">make.mask</span>(tr, <span class="dv">250</span>, <span class="at">type =</span> <span class="st">&#39;trapbuffer&#39;</span>), <span class="at">add =</span> <span class="cn">TRUE</span>, </span>
<span id="cb15-13"><a href="#cb15-13" tabindex="-1"></a>     <span class="at">col =</span> <span class="st">&#39;white&#39;</span>)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/pdot-1.png" alt="Contour plot of overall detection probability." width="65%" height="60%" />
<p class="caption">
(#fig:pdot)Contour plot of overall detection probability.
</p>
</div>
<div class="figure">
<img src="SECRbook_files/figure-html/pdotdist-1.png" alt="Distribution of overall detection probability for AC locations at varying distance from traps." width="65%" height="60%" />
<p class="caption">
(#fig:pdotdist)Distribution of overall detection probability for AC locations at varying distance from traps.
</p>
</div>
<!-- Pdot fig \@ref(fig:pdot) -->
<!--chapter:end:02-example.Rmd-->
</div>
</div>
<div id="part-theory" class="section level1 unnumbered">
<h1 class="unnumbered">(PART*) Theory</h1>
</div>
<div id="Theory" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Likelihood</h1>
<p>The chapters in Part II provide background mostly for reference. They aim to be independent of any particular implementation of SECR, although some cross-references to <strong>secr</strong> creep in. The notation and terminology originated with <span class="citation">Borchers and Efford (<a href="#ref-be08">2008</a>)</span>, extensions from <span class="citation">Efford, Borchers, and Byrom (<a href="#ref-ebb09">2009</a>)</span>, <span class="citation">Efford (<a href="#ref-e11">2011</a>)</span> and elsewhere.</p>
<div id="notation" class="section level2" number="3.1">
<h2><span class="header-section-number">3.1</span> Notation</h2>
<p></p>
<table>
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="78%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Category</th>
<th align="left">Symbol</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">General</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">AC</td>
<td align="left">activity centre</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><span class="math inline">\(\mathbf{x}\)</span></td>
<td align="left">point <span class="math inline">\((x,y)\)</span> in the plane</td>
</tr>
<tr class="even">
<td align="left">Data</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><span class="math inline">\(n\)</span></td>
<td align="left">number of individuals detected</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><span class="math inline">\(S\)</span></td>
<td align="left">number of sampling occasions</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><span class="math inline">\(K\)</span></td>
<td align="left">number of detectors</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><span class="math inline">\(\omega_i\)</span></td>
<td align="left">spatial detection history of the <span class="math inline">\(i\)</span>-th animal</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><span class="math inline">\(\Omega\)</span></td>
<td align="left">set of all detection histories <span class="math inline">\(\omega_i, i = 1..n\)</span></td>
</tr>
<tr class="even">
<td align="left">Parameters</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><span class="math inline">\(D(\mathbf{x}; \phi)\)</span><a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a></td>
<td align="left">intensity surface of AC Poisson point process at <span class="math inline">\(\mathbf{x}\)</span></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><span class="math inline">\(\phi\)</span></td>
<td align="left">parameter vector for AC point process (scalar density if surface flat)</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><span class="math inline">\(\theta\)</span></td>
<td align="left">vector of detection parameters (minimally <span class="math inline">\((g_0, \sigma)\)</span> or <span class="math inline">\((\lambda_0,\sigma)\)</span>)</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><span class="math inline">\(g_0\)</span></td>
<td align="left">intercept of distance-probability-of-detection function</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><span class="math inline">\(\lambda_0\)</span></td>
<td align="left">intercept of distance-hazard-of-detection function</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><span class="math inline">\(\sigma\)</span></td>
<td align="left">spatial scale parameter of distance-detection function</td>
</tr>
<tr class="odd">
<td align="left">Model</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><span class="math inline">\(d_k(\mathbf{x})\)</span></td>
<td align="left">distance of point <span class="math inline">\(\mathbf{x}\)</span> from detector <span class="math inline">\(k\)</span></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><span class="math inline">\(\lambda(d)\)</span></td>
<td align="left">hazard of detection at distance <span class="math inline">\(d\)</span> (distance-hazard-of-detection function)</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><span class="math inline">\(g(d)\)</span></td>
<td align="left">probability of detection at distance <span class="math inline">\(d\)</span> (distance-probability-of-detection function)</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><span class="math inline">\(p_\cdot(\mathbf{x}; \theta)\)</span></td>
<td align="left">probability that an individual with AC at <span class="math inline">\(\mathbf{x}\)</span> is detected at least once</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><span class="math inline">\(h_{isk}(\mathbf{x}; \theta)\)</span></td>
<td align="left">hazard of detection at detector <span class="math inline">\(k\)</span> for animal <span class="math inline">\(i\)</span> on occasion <span class="math inline">\(s\)</span></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><span class="math inline">\(p_{isk}(\mathbf{x}; \theta)\)</span></td>
<td align="left">probability of detection corresponding to <span class="math inline">\(h_{isk}(\mathbf{x}; \theta)\)</span></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><span class="math inline">\(p_{k}(\mathbf{x}; \theta)\)</span></td>
<td align="left"><span class="math inline">\(p_{isk}(\mathbf{x}; \theta)\)</span> constant across individuals <span class="math inline">\(i\)</span> and occasions <span class="math inline">\(s\)</span></td>
</tr>
<tr class="odd">
<td align="left">Habitat</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><span class="math inline">\(A\)</span></td>
<td align="left">potential habitat (‘habitat mask’, ‘state space’) <span class="math inline">\(A \subset R^2\)</span></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><span class="math inline">\(|A|\)</span></td>
<td align="left">area of <span class="math inline">\(A\)</span></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><span class="math inline">\(N(A)\)</span></td>
<td align="left">number of AC in <span class="math inline">\(A\)</span></td>
</tr>
</tbody>
</table>
</div>
<div id="Likelihood" class="section level2" number="3.2">
<h2><span class="header-section-number">3.2</span> Likelihood</h2>
<p></p>
<p>This formulation of the likelihood is based on <span class="citation">Borchers and Efford (<a href="#ref-be08">2008</a>)</span> with minor changes in notation:
<span class="math display">\[\begin{equation}
L(\phi, \theta | \Omega ) = \mbox{Pr}(n| \phi, \theta) \; \mbox{Pr}(\Omega | n, \phi, \theta).
(\#eq:L)
\end{equation}\]</span></p>
<p>Parameters of the state model (<span class="math inline">\(\phi\)</span>) and the detection model (<span class="math inline">\(\theta\)</span>) are estimated jointly by maximizing the logarithm of the likelihood. When density is constant across space, <span class="math inline">\(\phi\)</span> drops out of the rightmost term, which then relates to the detection (observation) model alone, and maximization of this component gives unbiased estimates of <span class="math inline">\(\theta\)</span> (see <a href="#conditional">Conditional likelihood</a>).</p>
<div id="Pr-n" class="section level3" number="3.2.1">
<h3><span class="header-section-number">3.2.1</span> Number of individuals</h3>
<p>
If AC follow an inhomogeneous Poisson process then <span class="math inline">\(n\)</span> has a Poisson distribution with parameter
<span class="math display">\[\begin{equation}
\lambda = \int_{R^2} D(\mathbf{x}; \phi) \, p_\cdot(\mathbf{x};\theta) \, d\mathbf{x},
(\#eq:n)
\end{equation}\]</span>
where <span class="math inline">\(D(\mathbf{x}; \phi)\)</span> is the density at <span class="math inline">\(\mathbf{x}\)</span> and <span class="math inline">\(p_\cdot(\mathbf{x}|\theta)\)</span> is the overall probability of detecting an AC at <span class="math inline">\(\mathbf{x}\)</span> (see Sections @ref(pointdetectors) and @ref(areasearches)). Thus <span class="math inline">\(\mbox{Pr}(n | \phi, \theta) = \lambda^n \exp (-\lambda) / n!\)</span>. The distribution of <span class="math inline">\(n\)</span> is binomial when the population size in a defined area is <a href="#fixedN">fixed</a>.</p>
</div>
<div id="Pr-omega" class="section level3" number="3.2.2">
<h3><span class="header-section-number">3.2.2</span> Detection histories</h3>
<p>In general we have
<span class="math display">\[\begin{equation}
\mbox{Pr} (\Omega | n, \phi, \theta) = \binom {n}{n_1,...,n_C}
\prod_{i=1}^n \mbox{Pr}( \omega_i | \omega_i&gt;0, \phi, \theta),
(\#eq:CL)
\end{equation}\]</span></p>
<p>where <span class="math inline">\(\omega_i&gt;0\)</span> indicates a non-empty detection history. The multinomial coefficient uses the frequencies <span class="math inline">\(n_1,...,n_C\)</span> of each of the <span class="math inline">\(C\)</span> observed histories. The coefficient is a constant not involving parameters and it can be omitted without changing the model fit (consistent inclusion or exclusion is needed for valid likelihood-based comparisons such as those using AIC).</p>
<p>We do not know the true AC locations, but they can be integrated<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a> out of the likelihood using an expression for their spatial distribution, i.e.
<span class="math display">\[\begin{equation}
\mbox{Pr}( \omega_i | \omega_i&gt;0, \phi, \theta) = \int_{R^2} \mbox{Pr}( \omega_i | \omega_i&gt;0, \theta, \mathbf{x}) \, f(\mathbf{x} | \omega_i&gt;0, \phi, \theta) \; d\mathbf{x}
(\#eq:omegai)
\end{equation}\]</span>
where <span class="math inline">\(f(\mathbf{x}| \omega_i&gt;0, \phi, \theta)\)</span> is the conditional density of an AC given that the individual was detected. The conditional density is given by
<span class="math display">\[\begin{equation}
f(\mathbf{x}| \omega_i&gt;0, \phi, \theta) = \frac{D(\mathbf{x} ; \phi) p_\cdot(\mathbf{x} ; \theta)}{\lambda(\phi,\theta)}.
(\#eq:f)
\end{equation}\]</span></p>
</div>
</div>
<div id="distance-dependent-detection-1" class="section level2" number="3.3">
<h2><span class="header-section-number">3.3</span> Distance-dependent detection</h2>
<p>The key idea of SECR is that the probability of detecting a particular animal at a particular detector on one occasion can be represented as a function of the distance between its AC and the detector. The function should decline effectively to zero at large distances. Distances are not observed directly, and we rely on functions of somewhat arbitrary shape. Fortunately, the estimates are not very sensitive to the choice. Detection functions are covered in detail in Chapter @ref(Detection). Either probability <span class="math inline">\(g(d)\)</span> or hazard <span class="math inline">\(\lambda(d)\)</span> may be modelled as a function of distance. A halfnormal form is commonly used (e.g., <span class="math inline">\(g(d) = g_0 \exp (-d^2/2/\sigma^2)\)</span>). The shapes of, e.g., halfnormal <span class="math inline">\(g(d)\)</span> and halfnormal <span class="math inline">\(\lambda_0(d)\)</span> are only subtly different, but <span class="math inline">\(\lambda(d)\)</span> is preferred because it lends itself to mathematical manipulation and occurs more widely in the literature (often with different notation).</p>
<p>The function <span class="math inline">\(\lambda(d)\)</span> may be transformed into a probability with <span class="math inline">\(g(d) = 1 - \exp[-\lambda(d)]\)</span> and the reverse transformation is <span class="math inline">\(\lambda(d) = -\log[1-g(d)]\)</span>. The intercept parameter <span class="math inline">\(g_0\)</span> has been replaced by <span class="math inline">\(\lambda_0\)</span>; although the name <span class="math inline">\(\sigma\)</span> is retained for the spatial scale parameter this is not exactly interchangeable between the models.</p>
</div>
<div id="pointdetectors" class="section level2" number="3.4">
<h2><span class="header-section-number">3.4</span> Detector types</h2>
<p></p>
<p>The SECR data <span class="math inline">\(\omega_i\)</span> for each detected individual comprise a matrix with dimensions <span class="math inline">\(S\)</span> (occasions) and <span class="math inline">\(K\)</span> (detectors). Each element may be binary (0/1) or integer (0, 1, 2, …). Various probability models exist for the entries <span class="math inline">\(\omega_{isk}\)</span>. The appropriate probability model follows in most cases directly from the type of detector device; we therefore classify probability models according to device type. Table @ref(tab:detectortypes) matches this classification to that of <span class="citation">Royle et al. (<a href="#ref-rcsg14">2014</a>)</span>. This section covers passive detection at a point; <a href="#areasearches">area searches</a> are considered later.</p>
<table>
<caption>(#tab:detectortypes) Detector types (based on <span class="citation">Efford and Boulanger (<a href="#ref-eb19">2019</a>, Table 1)</span>)</caption>
<colgroup>
<col width="30%" />
<col width="22%" />
<col width="47%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Detector type</th>
<th align="left"><span class="citation">Royle et al. (<a href="#ref-rcsg14">2014</a>)</span></th>
<th align="left">Data</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Binary proximity</td>
<td align="left">Bernoulli<sup>1</sup></td>
<td align="left">binary animal <span class="math inline">\(\times\)</span> occasion <span class="math inline">\(\times\)</span> detector</td>
</tr>
<tr class="even">
<td align="left">Poisson count proximity</td>
<td align="left">Poisson</td>
<td align="left">integer animal <span class="math inline">\(\times\)</span> occasion <span class="math inline">\(\times\)</span> detector</td>
</tr>
<tr class="odd">
<td align="left">Binomial count proximity</td>
<td align="left">Binomial</td>
<td align="left">integer animal <span class="math inline">\(\times\)</span> occasion <span class="math inline">\(\times\)</span> detector</td>
</tr>
<tr class="even">
<td align="left">Multi-catch trap</td>
<td align="left">Multinomial</td>
<td align="left">binary animal <span class="math inline">\(\times\)</span> occasion</td>
</tr>
<tr class="odd">
<td align="left">Single-catch trap</td>
<td align="left">—</td>
<td align="left">binary animal <span class="math inline">\(\times\)</span> occasion, exclusive</td>
</tr>
<tr class="even">
<td align="left">Area search</td>
<td align="left"></td>
<td align="left">integer animal <span class="math inline">\(\times\)</span> occasion <span class="math inline">\(\times\)</span> detector</td>
</tr>
<tr class="odd">
<td align="left">Transect search</td>
<td align="left"></td>
<td align="left">integer animal <span class="math inline">\(\times\)</span> occasion <span class="math inline">\(\times\)</span> detector</td>
</tr>
<tr class="even">
<td align="left">Exclusive area search<sup>2</sup></td>
<td align="left"></td>
<td align="left">binary animal <span class="math inline">\(\times\)</span> occasion</td>
</tr>
<tr class="odd">
<td align="left">Exclusive transect search<sup>2</sup></td>
<td align="left"></td>
<td align="left">binary animal <span class="math inline">\(\times\)</span> occasion</td>
</tr>
</tbody>
</table>
<ol style="list-style-type: decimal">
<li>Also ‘Binomial’ in <span class="citation">Royle and Gardner (<a href="#ref-rg11">2011</a>)</span></li>
<li>‘Exclusive’ here means that an individual can be detected at no more than one detector (polygon or transect) per occasion.</li>
</ol>
<p>For each type of detector we require <span class="math inline">\(\mbox{Pr}(\omega_{isk} | \mathbf{x})\)</span> and the overall probability of detection <span class="math inline">\(p_\cdot(\mathbf{x})\)</span>. For some detector types it is more natural to express the probability in terms of the occasion- and trap-specific hazard <span class="math inline">\(h_{sk} = \lambda[d_k(\mathbf{x}); \theta^\prime] = -\log(1-g[d_k(\mathbf{x}); \theta])\)</span> than the probability <span class="math inline">\(p_{sk} (\mathbf{x}) = g[d_k(\mathbf{x}); \theta] = 1 - \exp\{-\lambda[d_k(\mathbf{x}); \theta^\prime]\}\)</span><a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a>.</p>
<p>We summarise the probability models in Table @ref(tab:pointdetectortypes), with comments on each point detector type below.</p>
<table>
<caption>(#tab:pointdetectortypes) Summary of point detector types (conditioning on <span class="math inline">\(\theta\)</span> omitted to save space)</caption>
<colgroup>
<col width="31%" />
<col width="34%" />
<col width="34%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Detector type</th>
<th align="left"><span class="math inline">\(\mbox{Pr}(\omega_{isk} | \mathbf{x})\)</span></th>
<th align="left"><span class="math inline">\(p_\cdot(\mathbf{x})\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Binary proximity</td>
<td align="left"><span class="math inline">\(p_{sk}(\mathbf{x}) ^{\omega_{isk}} [1-p_{sk}(\mathbf{x})]^{(1-\omega_{isk})}\)</span></td>
<td align="left"><span class="math inline">\(1 - \prod_s\prod_k 1 - p_{sk} (\mathbf{x})\)</span></td>
</tr>
<tr class="even">
<td align="left">Poisson count proximity</td>
<td align="left"><span class="math inline">\(\{h_{sk} (\mathbf{x})^{\omega_{isk}} \exp [-h_{sk}(\mathbf{x})]\} / \omega_{isk}!\)</span></td>
<td align="left"><span class="math inline">\(1 - \exp [- \sum_s \sum_k h_{sk}(\mathbf{x})]\)</span></td>
</tr>
<tr class="odd">
<td align="left">Binomial count proximity<sup>1</sup></td>
<td align="left"><span class="math inline">\(\binom{B_s}{\omega_{isk}} p_{sk}(\mathbf{x})^{\omega_{isk}} [1-p_{sk}(\mathbf{x})]^{(B_s-\omega_{isk})}\)</span></td>
<td align="left"><span class="math inline">\(1 - \prod_s\prod_k [1 - p_{sk} (\mathbf{x})]^{B_s}\)</span></td>
</tr>
<tr class="even">
<td align="left">Multi-catch trap<sup>2</sup></td>
<td align="left"><span class="math inline">\(\{1 - \exp [-H_s(\mathbf{x})]\}\frac{h_{sk}(\mathbf{x})}{H_s(\mathbf{x})}\)</span></td>
<td align="left"><span class="math inline">\(1 - \exp[ -\sum_s H_s(\mathbf{x})]\)</span></td>
</tr>
</tbody>
</table>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(B_s\)</span> is the size of the binomial distribution, the number of opportunities for detection, assumed constant across detectors</li>
<li><span class="math inline">\(H_s = \sum_k h_{sk}(\mathbf{x})\)</span> is the hazard summed over traps</li>
</ol>
<div id="binary-proximity-detector" class="section level3" number="3.4.1">
<h3><span class="header-section-number">3.4.1</span> Binary proximity detector</h3>
<p></p>
<p>A proximity detector records the presence of an individual at or near a point without restricting its movement. The data are binary when any detections after the first are ignored (this avoids worries about the non-independence of repeated visits to a detector).</p>
<p>Assuming independence among detectors, the distance-detection model applies directly as the probability of detection in a particular detector, and the overall probability of detection is the complement of the product of probabilities of non-detection in all detectors.</p>
</div>
<div id="poisson-count-proximity-detector" class="section level3" number="3.4.2">
<h3><span class="header-section-number">3.4.2</span> Poisson count proximity detector</h3>
<p></p>
<p>Hazard is the natural scale for the Poisson parameter.</p>
</div>
<div id="binomial-count-proximity-detector" class="section level3" number="3.4.3">
<h3><span class="header-section-number">3.4.3</span> Binomial count proximity detector</h3>
<p></p>
<p>Binomial counts arise when there is a finite number of opportunities for detection within each occasion that we denote <span class="math inline">\(B_s\)</span>. This commonly happens when binary proximity data are collapsed to a single occasion: the initial number of occasions is known (<span class="math inline">\(B_s = S\)</span>) and places an upper limit on the count. Collapsing is often efficient. It precludes modelling parameter variation or learned responses across occasions.</p>
<p>Each count is binomial with size <span class="math inline">\(B_s\)</span> and probability equal to the per-occasion detection probability.</p>
</div>
<div id="multi-catch-trap" class="section level3" number="3.4.4">
<h3><span class="header-section-number">3.4.4</span> Multi-catch trap</h3>
<p></p>
<p>A trap is a device that detains an animal until it is released, allowing only one detection of that animal per occasion. The single-detector, single-AC probability from a distance-dependent detection function (preceding section) must be modified to allow for prior capture in a different trap: traps effectively “compete” for animals. If the trap remains open for captures of further animals then the solution is a straightforward competing risk model <span class="citation">(<a href="#ref-be08">Borchers and Efford 2008</a>)</span>.</p>
<p>The competing risk model uses the occasion- and trap-specific hazard <span class="math inline">\(h_{sk}\)</span>.</p>
</div>
<div id="single-catch-trap" class="section level3" number="3.4.5">
<h3><span class="header-section-number">3.4.5</span> Single-catch trap</h3>
<p></p>
<p>A single-catch trap can only catch one animal at a time. This entails competition
both among traps for animals and among animals for traps. No simple likelihood is available.
Simulation-based methods <span class="citation">(<a href="#ref-e04">Efford 2004</a>, <a href="#ref-Efford2023">2023c</a>)</span> must be used for unbiased estimation of
<span class="math inline">\(\theta\)</span> and trend in density unless the time of detection has been recorded <span class="citation">(<a href="#ref-Distiller2015">Distiller and Borchers 2015</a>)</span>.</p>
</div>
</div>
<div id="fixedN" class="section level2" number="3.5">
<h2><span class="header-section-number">3.5</span> Fixed <span class="math inline">\(N\)</span></h2>
<p></p>
<p>The formulation of the state model as an inhomogeneous Poisson process (Chapter @ref(Basics)) does not refer to population size <span class="math inline">\(N\)</span>. The state model may also be cast as a ‘conditional’ or ‘binomial’ Poisson process’ <span class="citation">(<a href="#ref-illian08">Illian et al. 2008</a>)</span>. For an arbitrary area <span class="math inline">\(A\)</span> the number of AC is then considered fixed rather than Poisson.</p>
<p>The distribution of <span class="math inline">\(n\)</span> is then binomial with size <span class="math inline">\(N(A)\)</span> and probability
<span class="math inline">\(p_c(\phi, \theta) = \int_A p_\cdot(\mathbf{x}; \theta) f(\mathbf{x}; \phi) d\mathbf{x}\)</span>, where <span class="math inline">\(f(\mathbf{x}; \phi) = D(\mathbf{x}; \phi) / \int_A D(\mathbf{x}; \phi) d\mathbf{x}\)</span>.</p>
<p>The form conditional on <span class="math inline">\(N(A)\)</span> leads to narrower confidence intervals for density owing to the exclusion of variation in <span class="math inline">\(N(A)\)</span> among realisations of the Poisson process for AC. This makes sense when <span class="math inline">\(A\)</span> contains an isolated population with a natural boundary, but most applications do not meet this criterion.</p>
</div>
<div id="confidenceintervals" class="section level2" number="3.6">
<h2><span class="header-section-number">3.6</span> Confidence intervals</h2>
<p></p>
<p>Maximizing the log likelihood leads to a straightforward estimate of the asymptotic covariance matrix <span class="math inline">\(\mathbf{V}\)</span> of the beta parameters. If <span class="math inline">\(\hat \theta\)</span> is the vector of estimates and <span class="math inline">\(\mathbf{H}(\hat \theta)\)</span> is the Hessian matrix evaluated at <span class="math inline">\(\hat \theta\)</span> then the covariance matrix is <span class="math inline">\(\mathbf{V} = \mathbf{H}(\hat \theta)^{-1}\)</span>.</p>
<blockquote>
<p>The Hessian matrix is the square matrix of second-order partial derivatives of the log likelihood. For more on asymptotic variances of MLE see <span class="citation">Seber (<a href="#ref-s82">1982</a>)</span>, <span class="citation">Borchers, Buckland, and Zucchini (<a href="#ref-Borchers2002">2002</a>)</span>, <span class="citation">Cooch and White (<a href="#ref-cw">2023</a>)</span> 1.3.2, and many statistics texts.</p>
</blockquote>
<p>The sampling error of MLE is asymptotically normal, and symmetric (Wald) intervals for SECR parameters appear to work well on the link scale i.e. <span class="math inline">\(\hat \theta_j \pm z_{\alpha/2} \hat \sigma_j\)</span> is a <span class="math inline">\(100(1-\alpha)\%\)</span> interval for <span class="math inline">\(\hat \theta_j\)</span> where <span class="math inline">\(-z_{\alpha/2}\)</span> is the <span class="math inline">\(\alpha/2\)</span> quantile of the standard normal deviate (<span class="math inline">\(z_{0.025} = 1.96\)</span>) and <span class="math inline">\(\hat \sigma_j^2\)</span> is the estimated variance from <span class="math inline">\(\mathbf{V}\)</span>.</p>
<p>On back transformation to the natural (‘real’) scale these intervals become asymmetrical and generally have good coverage properties.</p>
<p>The method of profile likelihood is available (e.g., <span class="citation">Evans, Kim, and O’Brien (<a href="#ref-Evans1996">1996</a>)</span>; <code>secr::confint.secr</code>), but it is seldom used as no problem has been shown with intervals based on asymptotic variances. Similarly, the additional computation required by parametric bootstrap methods is not warranted.</p>
</div>
<div id="varying-effort" class="section level2" number="3.7">
<h2><span class="header-section-number">3.7</span> Varying effort</h2>
<p></p>
<p>When sampling effort varies between detectors or over time in a capture–recapture study we expect a commensurate change in the number of detections. Allowing for known variation in effort when modelling detections has these benefits:</p>
<ul>
<li>detection parameters are related to a consistent unit of effort (e.g., one trap set for one day)</li>
<li>the fit of the detection model is improved</li>
<li>trends in the estimates may be modelled without confounding.</li>
</ul>
<p><span class="citation">Borchers and Efford (<a href="#ref-be08">2008</a>)</span> allowed the duration of exposure to vary between sampling occasions in their competing-hazard model for
multi-catch traps. <span class="citation">Efford, Borchers, and Mowat (<a href="#ref-ebm13">2013</a>)</span> generalised the method to allow joint variation in effort over detectors and over time
(occasions), and considered other detector types.</p>
<p>We use <span class="math inline">\(T_{sk}\)</span> for the effort on occasion <span class="math inline">\(s\)</span> at detector <span class="math inline">\(k\)</span>. At its simplest, <span class="math inline">\(T_{sk}\)</span> can be a binary indicator taking the values 0 (detector not used) or 1 (detector used) (when <span class="math inline">\(T_{sk} = 0\)</span>, no detections are possible and <span class="math inline">\(\omega_{isk} = 0\)</span>). For small, continuously varying, <span class="math inline">\(T_{sk}\)</span> we expect the number of detections to increase linearly with <span class="math inline">\(T_{sk}\)</span>; saturation may occur at higher effort, depending on the detector type. Examples of possible effort variables are the number of days that each automatic camera was operated in a tiger study, or the number of rub trees sampled for DNA in each grid cell of a grizzly bear study.</p>
<p>Following convention in non-spatial capture–recapture <span class="citation">(<a href="#ref-cw">Cooch and White 2023</a>)</span> we could model <span class="math inline">\(g_0\)</span> or <span class="math inline">\(\lambda_0\)</span> on the link scale (logit or log) as a linear function of <span class="math inline">\(T_{sk}\)</span> (a time covariate if constant across detectors, a detector covariate if constant across occasions, or a time-varying detector-level covariate). However, this is suboptimal because varying effort has a linear effect only on <span class="math inline">\(\lambda_0\)</span> for Poisson count detectors, and the estimation of additional parameters is an unnecessary burden. <span class="math inline">\(T_{sk}\)</span> is like an offset in a generalised linear model: it can be included in the SECR model without estimating an additional coefficient.</p>
<p>The SECR models for various detectors (Table @ref(tab:pointdetectortypes)) are expressed in terms of either the probability <span class="math inline">\(p_{sk}\)</span> or the hazard <span class="math inline">\(h_{sk}\)</span>. Each of these scales differently with <span class="math inline">\(T_{sk}\)</span> as shown in Table @ref(tab:effort). Only in the Poisson case is the expected number of detections linear on effort.</p>
<table>
<caption>(#tab:effort) Including effort in SECR models for various detector types. <span class="math inline">\(p^\prime_{sk}(\mathbf{x})\)</span> and <span class="math inline">\(h^\prime_{sk}(\mathbf{x})\)</span> replace the matching quantities in Table @ref(tab:pointdetectortypes).</caption>
<colgroup>
<col width="38%" />
<col width="61%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Detector type</th>
<th align="left">Adjusted probability or hazard</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Multi-catch trap</td>
<td align="left"><span class="math inline">\(h^\prime_{sk}(\mathbf{x}) = h_{sk}(\mathbf{x}) T_{sk}\)</span>; <span class="math inline">\(H^\prime_s(\mathbf{x}) = \sum_k h^\prime_{sk}(\mathbf{x})\)</span></td>
</tr>
<tr class="even">
<td align="left">Binary proximity</td>
<td align="left"><span class="math inline">\(p^\prime_{sk}(\mathbf{x}) = 1 - (1 - p_{sk}(\mathbf{x}))^{T_{sk}}\)</span></td>
</tr>
<tr class="odd">
<td align="left">Poisson count proximity</td>
<td align="left"><span class="math inline">\(h^\prime_{sk}(\mathbf{x}) = h_{sk}(\mathbf{x}) T_{sk}\)</span></td>
</tr>
<tr class="even">
<td align="left">Binomial count proximity</td>
<td align="left">see below</td>
</tr>
</tbody>
</table>
<p>For binomial count detectors we use a formulation not based directly on instantaneous hazard, as explained by <span class="citation">Efford, Borchers, and Mowat (<a href="#ref-ebm13">2013</a>)</span>. For these detectors <span class="math inline">\(T_{sk}\)</span> (assumed integer) is taken as the size of the binomial (maximum possible detections) and <span class="math inline">\(p_{sk}(\mathbf{x})\)</span> is unchanged.</p>
<!--chapter:end:03-theory.Rmd-->
</div>
</div>
<div id="areasearches" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Area search</h1>
<p>Area searches differ from other modes of detection in that each detection may have different coordinates, and the coordinates are continuously distributed rather than constrained to fixed points by the field design. Searched areas may comprise one or more polygons, each of which can be considered a ‘detector’. <span class="citation">Efford (<a href="#ref-e11">2011</a>)</span> gave technical background on the fitting of polygon models to spatially explicit capture–recapture data by maximum likelihood. <span class="citation">Royle and Young (<a href="#ref-ry08">2008</a>)</span> and <span class="citation">Royle et al. (<a href="#ref-rcsg14">2014</a>)</span> provide a Bayesian solution.</p>
<p>Before launching into some rather heavy theory, we note that this can all be avoided by treating polygon data as if they were collected at many point detectors (pixel centres) obtained by discretizing the polygon(s).</p>
<div id="detector-types-for-area-search" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Detector types for area search</h2>
<p></p>
<p>Area-search analogues exist for each of the <a href="#pointdetectors">point detector types</a>.</p>
<ul>
<li>The ‘Poisson-count polygon’ type is suited to individually identifiable cues (e.g., faeces sampled for DNA).</li>
<li>‘Exclusive polygons’ are an analogue of multi-catch traps - they provide at most one detection of an individual per occasion, most likely as a result of a direct search for the animal itself. The horned lizard dataset of <span class="citation">Royle and Young (<a href="#ref-ry08">2008</a>)</span> is a good example.</li>
<li>The ‘binomial-count polygon’ type may result from collapsing exclusive polygon data to a single occasion.</li>
</ul>
<p>We do not consider the area-search analogue of a binary proximity point detector because it seems improbable that binary data would be collected from each of several areas on one occasion.</p>
<div id="detection-model-for-area-search" class="section level3" number="4.1.1">
<h3><span class="header-section-number">4.1.1</span> Detection model for area search</h3>
<p>The distance-dependent detection model for point detectors is replaced for area searches by an overlap model. The hazard of detection of an individual within an irregular searched area is modelled as a function of the quantitative overlap between its home range<a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a> (assumed circular) and the area searched (Fig. @ref(fig:overlapplot)).</p>
<div class="figure" style="text-align: center">
<img src="SECRbook_files/figure-html/overlapplot-1.png" alt="Hazard of detection for an animal centered at the blue dot on an irregular searched polygon (red outline). The cumulative hazard is modelled by the quantitative overlap (grey shading) between a radially symmetrical probability density (circular contours) and the searched area." width="528" />
<p class="caption">
(#fig:overlapplot)Hazard of detection for an animal centered at the blue dot on an irregular searched polygon (red outline). The cumulative hazard is modelled by the quantitative overlap (grey shading) between a radially symmetrical probability density (circular contours) and the searched area.
</p>
</div>
<p>We use <span class="math inline">\(\lambda_0\)</span> for the expected number of detections (detected cues) of an animal whose home range lies completely within the area <span class="math inline">\(\kappa\)</span>, and <span class="math inline">\(h(\mathbf{u}|\mathbf{x})\)</span> for the probability density of activity at point <span class="math inline">\(\mathbf{u}\)</span> for an animal centred at <span class="math inline">\(\mathbf{x}\)</span> (i.e. <span class="math inline">\(\int_{R^2} h(\mathbf{u}|\mathbf{x}) \, d \mathbf{u} = 1\)</span>). Then the expected number of detected cues from an individual on occasion <span class="math inline">\(s\)</span> in polygon <span class="math inline">\(k\)</span> is</p>
<p><span class="math display">\[\begin{equation}
h_{sk}(\mathbf{x}; \theta) = \lambda_0 \int_{\kappa_k} h(\mathbf{u}|\mathbf{x}; \theta^-) \, du,
(\#eq:hsk)
  \end{equation}\]</span></p>
<p>where <span class="math inline">\(\theta = (\lambda_0, \theta^-)\)</span> is the vector of detection parameters and <span class="math inline">\(\kappa_k\)</span> refers to the <span class="math inline">\(k\)</span>-th polygon. The probability of at least one detected cue is <span class="math inline">\(p_{sk}(\mathbf{x}) = 1 - \exp[-h_{sk}(\mathbf{x})]\)</span> as before. The detector-level probabilities conditional on AC location <span class="math inline">\(\mathbf{x}\)</span> follow directly from Table @ref(tab:pointdetectortypes) (repeated in Table @ref(tab:areadetectortypes)).</p>
<table>
<caption>(#tab:areadetectortypes) Detector-level probabilities for area-search detector types.</caption>
<colgroup>
<col width="29%" />
<col width="37%" />
<col width="32%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Detector type</th>
<th align="left"><span class="math inline">\(\mbox{Pr}(\omega_{isk} | \mathbf{x})\)</span></th>
<th align="left"><span class="math inline">\(p_\cdot(\mathbf{x})\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Poisson count polygon</td>
<td align="left"><span class="math inline">\(\{h_{sk} (\mathbf{x})^{\omega_{isk}} \exp [-h_{sk}(\mathbf{x})]\} / \omega_{isk}!\)</span></td>
<td align="left"><span class="math inline">\(1 - \exp [- \sum_s \sum_k h_{sk}(\mathbf{x})]\)</span></td>
</tr>
<tr class="even">
<td align="left">Binomial count polygon</td>
<td align="left"><span class="math inline">\(\binom{B_s}{\omega_{isk}} p_{sk}(\mathbf{x})^{\omega_{isk}} [1-p_{sk}(\mathbf{x})]^{(B_s-\omega_{isk})}\)</span></td>
<td align="left"><span class="math inline">\(1 - \prod_s\prod_k [1 - p_{sk} (\mathbf{x})]^{B_s}\)</span></td>
</tr>
<tr class="odd">
<td align="left">Exclusive polygon<sup>1</sup></td>
<td align="left"><span class="math inline">\(\{1 - \exp [-H_s(\mathbf{x})]\}\frac{h_{sk}(\mathbf{x})}{H_s(\mathbf{x})}\)</span></td>
<td align="left"><span class="math inline">\(1 - \exp[ -\sum_s H_s(\mathbf{x})]\)</span></td>
</tr>
</tbody>
</table>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(H_s = \sum_k h_{sk}(\mathbf{x})\)</span> is the hazard summed over areas. If a single polygon is searched then <span class="math inline">\(h_{sk}(\mathbf{x}) = H_s(\mathbf{x})\)</span>, simplifying the expression for <span class="math inline">\(\mbox{Pr}(\omega_{isk} | \mathbf{x})\)</span>.</li>
</ol>
</div>
<div id="location-within-searched-polygon" class="section level3" number="4.1.2">
<h3><span class="header-section-number">4.1.2</span> Location within searched polygon</h3>
<p>The only data we have considered to this point are the occasion- and detector-specific binary or integer values <span class="math inline">\(\omega_{isk}\)</span> that record detections at the level of polygons. Each spatial detection history <span class="math inline">\(\omega_i\)</span> also includes within-polygon locations. These provide important information on detection scale <span class="math inline">\(\sigma\)</span> and spatial variation in density <span class="math inline">\(\phi\)</span>, and we need to include them in the likelihood.</p>
<div class="figure" style="text-align: center">
<img src="SECRbook_files/figure-html/overlapplot2-1.png" alt="Cues of one animal (yellow) within a searched polygon (red outline)." width="336" />
<p class="caption">
(#fig:overlapplot2)Cues of one animal (yellow) within a searched polygon (red outline).
</p>
</div>
<p>For each individual <span class="math inline">\(i\)</span> there are <span class="math inline">\(\omega_{isk}\)</span> locations of detected cues on occasion <span class="math inline">\(s\)</span> at detector <span class="math inline">\(k\)</span>. We use <span class="math inline">\(\mathbf{Y}_{isk}\)</span> for the collection and <span class="math inline">\(\mathbf{y}_{iskj}\)</span> (<span class="math inline">\(j = 1,...,\omega_{isk}\)</span>) for each separate location. Then
<span class="math display">\[\begin{equation}
  \mbox{Pr}(\mathbf{Y}_{isk} | \mathbf{x}, \theta^-) \propto \prod_{j=1}^{\omega_{isk}} \frac{h(\mathbf{y}_{iskj} | \mathbf{x}; \theta^-)}{\int_{\kappa_k} h(\mathbf{u}|\mathbf{x}; \theta^-) \, du}.
  (\#eq:Yisk)
   \end{equation}\]</span></p>
</div>
<div id="likelihood" class="section level3" number="4.1.3">
<h3><span class="header-section-number">4.1.3</span> Likelihood</h3>
<p></p>
<p>The likelihood component associated with <span class="math inline">\(\omega_i\)</span>, conditional on <span class="math inline">\(\mathbf{x}\)</span>, is a product of the probability of observing <span class="math inline">\(\omega_{isk}\)</span> cues, and the probability of the within-polygon locations:
<span class="math display">\[
    \mbox{Pr}(\omega_i | \omega_i &gt; 0, \mathbf{x}; \phi, \theta) \propto \frac{1}{p_\cdot(\mathbf{x}; \theta)} \prod_s \prod_k \mbox{Pr}(\omega_{isk} | \mathbf{x}; \theta) \, \mbox{Pr}(\mathbf{Y}_{isk} | \mathbf{x}, \theta^-).
   \]</span>
Inserted in @ref(eq:CL), along with <span class="math inline">\(f(\mathbf{x} | \omega_i&gt;0; \phi, \theta)\)</span> from equation @ref(eq:f), this provides the likelihood component <span class="math inline">\(\mbox{Pr} (\Omega | n, \phi, \theta)\)</span> of @ref(eq:L).</p>
</div>
</div>
<div id="transect-search" class="section level2" number="4.2">
<h2><span class="header-section-number">4.2</span> Transect search</h2>
<p></p>
<p>Transect detectors are the linear equivalent of polygons. Cues may be observed only along the searched zero-width transect. Transect detectors, like polygon detectors, may be independent or exclusive. See Appendix @ref(Areaandtransectsearches) for more.</p>
<!--chapter:end:04-theory-area-search.Rmd-->
</div>
</div>
<div id="SpecialTopics" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Special topics</h1>
<div id="multi-session-likelihood" class="section level2" number="5.1">
<h2><span class="header-section-number">5.1</span> Multi-session likelihood</h2>
<p></p>
<p>The data may comprise multiple independent datasets to be analysed together. We call these ‘sessions’, following the terminology of <strong>secr</strong>. They may be synchronous spatial samples from non-overlapping populations or samples of the same population widely separated in time. If there are <span class="math inline">\(J\)</span> such datasets we can denote them <span class="math inline">\(\Omega_j, j = 1,...,J\)</span>. The likelihood to be maximized is then <span class="math inline">\(\prod_j L(\phi, \theta | \Omega_j)\)</span>. While the parameter vector <span class="math inline">\((\phi, \theta)\)</span> is common to all sessions, the mechanism of <a href="#linear-submodels">linear submodels</a> allows ‘real’ parameter values to be specific to a session, common to multiple sessions, or modelled as a function of session-level covariates.</p>
<p>Failure of the independence assumption in a multi-session analysis results in underestimation of the sampling variance.</p>
</div>
<div id="groups" class="section level2" number="5.2">
<h2><span class="header-section-number">5.2</span> Groups</h2>
<p></p>
<p>Users of MARK <span class="citation">(<a href="#ref-cw">Cooch and White 2023</a>)</span> will be familiar with the stratification of a population into ‘groups’, each with potentially different values for parameters such as survival probability. Grouping requires that each animal is assigned to a group on first detection, and that the assignment is permanent. Then density and any detection parameter may be modelled as a function of the grouping factor. Group models are available in <strong>secr</strong> only when maximizing the full likelihood. When maximizing the <a href="#conditional">conditional likelihood</a> the model may specify an individual factor covariate directly, with the same effect as grouping.</p>
<p>The multinomial coefficient in <strong>secr</strong> is stratified by group.</p>
</div>
<div id="esa" class="section level2" number="5.3">
<h2><span class="header-section-number">5.3</span> Effective sampling area</h2>
<p></p>
<p>The effective sampling area is defined <span class="citation">(<a href="#ref-be08">Borchers and Efford 2008</a>)</span> as
<span class="math display">\[\begin{equation}
a(\theta) \equiv \int_{R^2} p_\cdot(\mathbf{x}; \theta) \, d\mathbf{x}.
(\#eq:esa)
\end{equation}\]</span>
This is a scalar <em>effective</em> area for which <span class="math inline">\(\hat D = n / a(\hat \theta)\)</span> is an unbiased estimate of density. It does not correspond to a geographic region or delimited polygon on the ground. It bears <em>no</em> relation to the traditional ‘effective trapping area’ <span class="math inline">\(A_W\)</span> <span class="citation">(e.g., <a href="#ref-obwa78">Otis et al. 1978</a>)</span> for which <span class="math inline">\(\hat D = \hat N / A_W\)</span>, given a non-spatial population estimate <span class="math inline">\(\hat N\)</span> and boundary strip width <span class="math inline">\(W\)</span>. Variation in <span class="math inline">\(a(\theta)\)</span> depends not only on obviously spatial quantities such as the extent of the detector array and the spatial scale of detection <span class="math inline">\(\sigma\)</span>, but also on non-spatial quantities such as sampling effort (e.g., the number of days of trapping) and the intercept of the distance-dependent detection function (<span class="math inline">\(g_0, \lambda_0\)</span>).</p>
<p><span class="citation">Gardner, Royle, and Wegan (<a href="#ref-grw09">2009</a>)</span> and <span class="citation">Royle, Nichols, et al. (<a href="#ref-rnug09">2009</a>)</span> defined an ‘effective trapping area’ or ‘effective sample area’ <span class="math inline">\(A_e\)</span> somewhat differently, omitting the intercept of the detection function. To our knowledge their definition has not found further use. A version closer to ours appears in <span class="citation">Royle et al. (<a href="#ref-rcsg14">2014, sec. 5.12</a>)</span>.</p>
<p><span class="citation">Efford and Mowat (<a href="#ref-em14">2014</a>)</span> defined a ‘single-detector sampling area’ <span class="math inline">\(a_0(\theta) = 2\pi \lambda_0 \sigma^2\)</span> that is equal to @ref(eq:esa) for an isolated detector with <a href="#detectfn">detection functions</a> HHN or HEX. For <span class="math inline">\(K\)</span> isolated detectors <span class="math inline">\(a(\theta) = Ka_0(\theta)\)</span>, but overlap of the ‘catchment areas’ of adjacent detectors leads to <span class="math inline">\(a(\theta) &lt; Ka_0(\theta)\)</span>.</p>
</div>
<div id="conditional" class="section level2" number="5.4">
<h2><span class="header-section-number">5.4</span> Conditional estimation of <span class="math inline">\(\theta\)</span></h2>
<p></p>
<p>When density is constant, the detection parameters (<span class="math inline">\(\theta\)</span>) may be estimated by maximizing the likelihood conditional on <span class="math inline">\(n\)</span>, i.e. Eq. @ref(eq:CL). This reduces to<br />
<span class="math display">\[\begin{equation}
L_n (\theta| \Omega) \propto \prod_{i=1}^n \frac{\int_{R^2} \mbox{Pr}(\omega_i | \mathbf{x}; \theta) \; d\mathbf{x}}{a(\theta)}.
\end{equation}\]</span></p>
<p>Conditioning on <span class="math inline">\(n\)</span> allows individual covariates <span class="math inline">\(z_i\)</span> to be included in the detection model (see later). The effective sampling area then varies among individuals as a function of their covariates. A corresponding Horvitz-Thompson-like derived estimate of density is <span class="math inline">\(\hat D = n / \sum_{i=1}^n a(z_i; \hat \theta)\)</span> <span class="citation">(<a href="#ref-be08">Borchers and Efford 2008</a>)</span>.</p>
<p>When the conditional likelihood is maximized, the inverse Hessian provides variances only for the detection parameters in <span class="math inline">\(\theta\)</span>. The variance of the derived (Horvitz-Thompson) estimate of density <span class="math inline">\(\hat D_{HT} = n / \sum_{i=1}^n a(z_i; \hat \theta)\)</span> depends also on the distribution of <span class="math inline">\(n\)</span>. Following <span class="citation">Huggins (<a href="#ref-h89">1989</a>)</span>,
<span class="math display">\[\begin{equation}
\mbox{var}(\hat D_{HT}) = s^2 + \hat {\mathbf{G}}^T_\theta \hat {\mathbf{I}} \hat {\mathbf{G}}_\theta
(\#eq:varHT)
\end{equation}\]</span>
where <span class="math inline">\(s^2\)</span> is the variance of <span class="math inline">\(\hat D\)</span> when <span class="math inline">\(\theta\)</span> is known, <span class="math inline">\(\hat {\mathbf{I}}\)</span> is the estimated information matrix (inverse
Hessian), and <span class="math inline">\(\hat {\mathbf{G}}\)</span> is a vector containing the gradients of <span class="math inline">\(\hat D\)</span> with respect to the elements
of <span class="math inline">\(\theta\)</span>, evaluated at the maximum likelihood estimates. Numerical evaluation of the second term is straightforward.</p>
<p>When the distribution of AC is inhomogeneous Poisson and detections are independent we expect <span class="math inline">\(n\)</span> to have a Poisson distribution. If <span class="math inline">\(n\)</span> is Poisson then <span class="math inline">\(s^2 = \sum_{i=1}^n a(z_i ; \hat \theta)^{-2}\)</span>. This simplifies to <span class="math inline">\(n/a(\hat \theta)^2\)</span> in the absence of individual covariates.</p>
<p>When <span class="math inline">\(N(A)\)</span> is fixed, <span class="math inline">\(n\)</span> is binomial and <span class="math inline">\(s^2 = \sum_{i=1}^n [1 - a(z_i; \hat \theta)/|A|] / a(z_i; \hat \theta)^2\)</span>.
<!-- or $s^2 = n [1 - a(\hat \theta)/|A|] / a(\hat \theta)^2$. --></p>
<p><span class="math inline">\(\mbox{var}(\hat D_{HT})\)</span> from @ref(eq:varHT) is on the natural scale, and the Wald confidence interval computed on this scale is symmetrical. Intervals that are symmetric on the log scale and asymmetric on the natural scale have better coverage properties. These are obtained as <span class="math inline">\((\hat D_{HT}/C, \hat D_{HT}C)\)</span> where <span class="math inline">\(C = \exp \{ z_{\alpha/2} \sqrt{\log[1 + \frac{\mbox{var}(\hat D_{HT})}{\hat D_{HT}^2}]} \}\)</span> <span class="citation">(<a href="#ref-Burnham1987">Burnham et al. 1987</a>; <a href="#ref-Chao1989">Chao 1989</a>)</span>.</p>
</div>
<div id="relativedensity1" class="section level2" number="5.5">
<h2><span class="header-section-number">5.5</span> Relative density</h2>
<p></p>
<p>A further option is to ignore the process of first detection that determines the set of individuals for which we have capture histories, i.e. to condition on the particular set of detected (tagged) individuals. Then we use <span class="math inline">\(\theta^\prime\)</span> to parameterize a model for their re-detection, and <span class="math inline">\(\phi^\prime\)</span> to describe the spatial distribution of detected individuals. Note that <span class="math inline">\(\phi^\prime\)</span> carries no information about absolute density: the model describes relative density. The parameters may be estimated by maximizing</p>
<p><span class="math display">\[\begin{equation}
L_r(\phi^\prime, \theta^\prime | \Omega) \propto \prod_{i=1}^n \int_{R^2} \mbox{Pr}(\omega_i | \mathbf{x}; \theta^\prime) \, f(\mathbf{x} ; \phi^\prime) \; d\mathbf{x}.
\end{equation}\]</span></p>
<p>The factor <span class="math inline">\(\mbox{Pr}(\omega_i | \mathbf{x}; \theta^\prime)\)</span> is the probability of the observed detection history of animal <span class="math inline">\(i\)</span> given that its activity centre was at <span class="math inline">\(\mathbf{x}\)</span>. The factor <span class="math inline">\(f(\mathbf{x} ; \phi^\prime)\)</span> describes the spatial distribution of <em>tagged</em> animals under the model with no allowance for how they came to be tagged.</p>
<p>Supposing the tagged sample results from previous capture–recapture sampling of a population with density <span class="math inline">\(D(\mathbf{x}; \phi)\)</span> and detection parameters <span class="math inline">\(\theta\)</span>, we can expect <span class="math inline">\(f(\mathbf{x}; \phi^\prime) \propto p_\cdot(\mathbf{x}; \theta) D(\mathbf{x}; \phi)\)</span>. An example is shown <a href="#relativedensity2">later</a>. A model with flat (constant) <span class="math inline">\(f(\mathbf{x}; \phi^\prime)\)</span> is inevitably a poor fit because in reality tagged individuals are concentrated near the detectors.</p>
</div>
<div id="population-size-n" class="section level2" number="5.6">
<h2><span class="header-section-number">5.6</span> Population size <span class="math inline">\(N\)</span></h2>
<p></p>
<p>Population size<a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a> is the number of individual AC in a particular region; we denote this <span class="math inline">\(N(A)\)</span> for region <span class="math inline">\(A\)</span>. For a flat density surface <span class="math inline">\(N(A) = D.|A|\)</span><a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a>. <span class="math inline">\(D\)</span> and <span class="math inline">\(N(A)\)</span> are interchangeable for specified <span class="math inline">\(A\)</span>. In most applications there is no naturally defined region <span class="math inline">\(A\)</span>, and therefore <span class="math inline">\(\hat N(A)\)</span> depends on the arbitrary choice of <span class="math inline">\(A\)</span>. This weakness is not shared by <span class="math inline">\(\hat D\)</span>.</p>
<p>The population size of any region <span class="math inline">\(B\)</span> may be estimated <em>post hoc</em> from a fitted density model using
<span class="math display">\[
\hat N(B) = \int_B \hat D(\mathbf{x}) \, d\mathbf{x}.
\]</span>
The sampling variance of <span class="math inline">\(\hat N(B)\)</span> follows from Poisson assumptions regarding <span class="math inline">\(D(\mathbf{x})\)</span> <span class="citation">(<a href="#ref-ef13">Efford and Fewster 2013</a>)</span>.</p>
</div>
<div id="finite-mixtures" class="section level2" number="5.7">
<h2><span class="header-section-number">5.7</span> Finite mixture models</h2>
<p></p>
<p>Finite mixture models for individual heterogeneity of capture probability were formalised for non-spatial capture–recapture by <span class="citation">Pledger (<a href="#ref-p2000">2000</a>)</span> and remain widely used (e.g., <span class="citation">Cooch and White (<a href="#ref-cw">2023</a>)</span>). These are essentially random-effect models in which the distribution of capture probability comprises two or more latent classes, each with a capture probability and probability of membership.</p>
<p><span class="citation">Borchers and Efford (<a href="#ref-be08">2008, 381</a>)</span> gave the likelihood for a Poisson SECR model with <span class="math inline">\(U\)</span> latent classes in proportions <span class="math inline">\(\psi\)</span> = (<span class="math inline">\(\psi_1\)</span>, …, <span class="math inline">\(\psi_U\)</span>). <span class="math inline">\(U\)</span> is 2 or 3 in all examples we have tried. For each class <span class="math inline">\(u\)</span> there is an associated vector of detection parameters <span class="math inline">\(\theta_u\)</span> (collectively <span class="math inline">\(\theta\)</span>). Omitting the constant multinomial term,
<span class="math display">\[\begin{equation}
\mbox{Pr}(\Omega | n, \phi,\theta, \psi) \propto \prod_{i=1}^n \sum_{u=1}^U\int\frac{\mbox{Pr}\{\omega_i | \mathbf{x}; \theta_u\}}{p_\cdot(\mathbf{x}; \theta_u)}
f(\mathbf{x}, u |\omega_i&gt;0) \,d\mathbf{x}
\end{equation}\]</span>
where
<span class="math display">\[\begin{equation}
f(\mathbf{x}, u | \omega_i &gt; 0) = \frac{D(\mathbf{x}; \phi) p_\cdot(\mathbf{x}; \theta_u) \psi_u}{\sum_{u=1}^U \int D(\mathbf{x}; \phi) p_\cdot(\mathbf{x}; \theta_u) \psi_u \; d\mathbf{x}}.
\end{equation}\]</span></p>
<p>The expected number of detected animals <span class="math inline">\(n\)</span>, replacing @ref(eq:n), is a weighted sum over latent classes:
<span class="math display">\[\begin{equation}
\lambda = \sum_{u=1}^U \psi_u \int D(\mathbf{x}; \phi) p_\cdot(\mathbf{x};\theta_u) \; d\mathbf{x}.
(\#eq:lambdau)
\end{equation}\]</span>
Integration is over points in potential habitat, as usual.</p>
<p><!-- A two-class finite mixture for a parameter $\theta$ is represented by three further parameters: the values $\theta_1$ and $\theta_2$ for the two classes and  $\pi_1$ for the probability of membership in class 1 ($\pi_2 = 1-\pi_1$ for the alternate class). The mean is $\bar \theta = \sum_i \pi_i \theta_i$. The CV is $\mbox{CV}(\theta) = \sqrt{\sum_i \pi_i (\theta_i - \bar \theta)^2} / \bar \theta$. --></p>
</div>
<div id="hybrid-mixtures" class="section level2" number="5.8">
<h2><span class="header-section-number">5.8</span> Hybrid finite mixture models</h2>
<p></p>
<p>We can modify the finite mixture likelihood for data in which the class membership of some or all individuals is known. Indicate the class membership of the <span class="math inline">\(i\)</span>-th individual by a variable <span class="math inline">\(u_i\)</span> that may take values 0, 1, …, <span class="math inline">\(U\)</span>, where <span class="math inline">\(u_i = 0\)</span> indicates an individual of unknown class, and the class frequencies are <span class="math inline">\(n_0\)</span>, <span class="math inline">\(n_1\)</span>, …, <span class="math inline">\(n_U\)</span> (not to be confused with <span class="math inline">\(n_1\)</span>,…,<span class="math inline">\(n_C\)</span> in @ref(eq:CL)). We assume here that detection histories are sorted by class membership, starting with the unknowns.</p>
<p>The expression for <span class="math inline">\(\lambda\)</span> in @ref(eq:lambdau) is unchanged, but we must split <span class="math inline">\(\mbox{Pr}(\Omega | n, \phi, \theta, \psi)\)</span> and include a multinomial term for the observed distribution over classes:</p>
<p><span class="math display">\[\begin{equation}
\begin{split}
\mbox{Pr}(\Omega | n, \phi,\theta, \psi) \propto \; &amp;\prod_{i=1}^{n_0}\sum_{u=1}^U\int\frac{\mbox{Pr}\{\omega_i | x; \theta_u\}}{p_\cdot(\mathbf{x} ; \theta_u)}
f(\mathbf{x} ,u|\omega_i&gt;0) \; d\mathbf{x}  \\
&amp;\times
\prod_{i={n_0+1}}^n  \int \frac{\mbox{Pr}\{\omega_i | x; \theta_{u_i}\}}{p_\cdot(\mathbf{x} ; \theta_{u_i})}
f&#39;(\mathbf{x}  | \omega_i&gt;0; u_i) \; d\mathbf{x}  \\
&amp;\times {n - n_0 \choose n_1, ...,n_U}
\prod_{u=1}^U \left[  \frac{\lambda_u}{\lambda} \right] ^{n_u},
\end{split}
(\#eq:hybrid)
\end{equation}\]</span></p>
<p>where <span class="math inline">\(\lambda_u = \psi_u \int D(\mathbf{x} ) p_\cdot(\mathbf{x} ; \theta_u) \; d\mathbf{x}\)</span>, and the multinomial coefficient <span class="math inline">\({n - n_0 \choose n_1, ...,n_U}\)</span> is a constant that can be omitted. Rather than representing the joint probability density of <span class="math inline">\(\mathbf{x}\)</span> and <span class="math inline">\(u_i\)</span> as in <span class="math inline">\(f(\cdot)\)</span> previously, <span class="math inline">\(f&#39;(\cdot)\)</span> is the probability density of <span class="math inline">\(\mathbf{x}\)</span> for given <span class="math inline">\(u_i\)</span>:
<span class="math display">\[
  f&#39;(\mathbf{x}  | \omega_i &gt; 0; u_i) = \frac{D(\mathbf{x} )p_\cdot(\mathbf{x} ; \theta_{u_i})}{\int D(\mathbf{x} )p_\cdot(\mathbf{x} ; \theta_{u_i}) d\mathbf{x} }.
\]</span></p>
<p>The likelihood conditions on the number of known-class animals detected (<span class="math inline">\(n-n_0\)</span>), rather than modelling class identification as a random process. It assumes that the probability that class will be recorded does not depend on class, and that such recording when it happens is without error.</p>
<p>For homogeneous density the likelihood simplifies to
<span class="math display">\[\begin{equation}
\begin{split}
\mbox{Pr}(\Omega | n, \phi,\theta, \psi) \propto &amp;\prod_{i=1}^{n_0}\sum_{u=1}^U\int\frac{\mbox{Pr}\{\omega_i | x; \theta_u\} \psi_u} {\sum_u a(\theta_u) \psi_u } \; d\mathbf{x}  
\\
&amp;\times
\prod_{i={n_0+1}}^n  \int \frac{\mbox{Pr}\{\omega_i | x; \theta_{u_i}\}}{a(\theta_{u_i})} \;
d\mathbf{x}  
\prod_{u=1}^U {  \left[ \frac{a(\theta_u)\psi_u} {\sum_u a(\theta_u) \psi_u } \right] ^{n_u}},
\end{split}
\end{equation}\]</span></p>
<p>where <span class="math inline">\(a(\theta_u) = \int p_\cdot(\mathbf{x} ; \theta_{u}) \; d\mathbf{x}\)</span>.</p>
</div>
<div id="parameterizations" class="section level2" number="5.9">
<h2><span class="header-section-number">5.9</span> Alternative parameterizations</h2>
<p></p>
<p>The ‘real’ parameters in SECR are typically assumed to be independent (orthogonal). However, some parameter pairs co-vary in predictable ways owing to constraints on animal behaviour. Here it is more straightforward to work with the hazard detection functions.mThe intercept of the detection function <span class="math inline">\(\lambda_0\)</span> declines with increasing <span class="math inline">\(\sigma\)</span>, all else being equal <span class="citation">(<a href="#ref-em14">Efford and Mowat 2014</a>)</span>. This is inevitable if detection is strictly proportional to time spent near a point, given a bivariate home range utilisation model (pdf for activity). Also, home-range size and the SECR parameter <span class="math inline">\(\sigma\)</span> decline with population density <span class="citation">(<a href="#ref-edjq16">Efford et al. 2016</a>)</span>. Allowing for covariation may improve biological insight and lead to more parsimonious models.</p>
<p>Covariation may be ‘hard-wired’ into SECR models by reparameterization. In each case a new ‘surrogate’ parameter is proportional to a combination of the co-varying parameters. One of the co-varying parameters is seen as driving variation, while the other is inferred from the surrogate and the driver. Deviations from the expected covariation are implied when the surrogate is found to vary (i.e. a model with varying surrogate is superior to a model with constant surrogate).</p>
<!-- ### $a = \int_{R^2} p_\cdot(\vec x; \theta) d\vec x$ [@em14] -->
<!-- The effective sampling area $a(\theta)$ meaningfully combines the detection parameters. However, inverting the integration is computationally expensive and will usually be avoided. -->
<p>These parameterizations implement the two covariation models mentioned before, with a third option combining the two:</p>
<ul>
<li><span class="math inline">\((D, a_0, \sigma)\)</span> where <span class="math inline">\(a_0 = 2 \pi \lambda_0 \sigma^2\)</span> and <span class="math inline">\(\lambda_0 = a_0 / (2 \pi \sigma^2)\)</span></li>
<li><span class="math inline">\((D, \lambda_0, k)\)</span> where <span class="math inline">\(k = \sigma \sqrt D\)</span> and <span class="math inline">\(\sigma = k/\sqrt D\)</span></li>
<li><span class="math inline">\((D, a_0, k)\)</span> where <span class="math inline">\(\sigma = k/\sqrt D\)</span> and <span class="math inline">\(\lambda_0 = a_0 / (2 \pi \sigma^2)\)</span></li>
</ul>
<p>In the first option <span class="math inline">\(\sigma\)</span> is the independent (driver) variable; in the other two options <span class="math inline">\(D\)</span> is the driver.</p>
</div>
<div id="model-based-location-of-ac-fxi" class="section level2" number="5.10">
<h2><span class="header-section-number">5.10</span> Model-based location of AC (fxi)</h2>
<p></p>
<p>Assume we have fitted a spatial model by integrating over the unknown locations of AC for a given SECR dataset <span class="math inline">\(\Omega = {\omega_1, \omega_2, ..., \omega_n}\)</span>. We may retrospectively infer the probability density of the AC corresponding to each detection history, using the model and the estimated parameters:
<span class="math display">\[\begin{equation}
f(\mathbf{x} | \omega_i; \hat \phi, \hat \theta) = \frac{ \mbox{Pr} (\omega_i | \mathbf{x}; \hat \theta) D(\mathbf{x} ; \hat \phi)}
{\int_{R^2} \mbox{Pr}(\omega_i | \mathbf{x}; \hat \theta) D(\mathbf{x} ; \hat \phi) \, d \mathbf{x}}.
(\#eq:fxi)
\end{equation}\]</span>
This is equivalent to the posterior distribution of each latent AC in Bayesian applications. See <code>fxi.secr</code> and related functions in <strong>secr</strong>. For known <span class="math inline">\(\theta\)</span> and known <span class="math inline">\(\phi\)</span> (unless <span class="math inline">\(D(\mathbf{x}; \phi)\)</span> uniform) the modal location of the AC for animal <span class="math inline">\(i\)</span> may be estimated by maximizing <span class="math inline">\(\mbox{Pr} (\omega_i | \mathbf{x}; \theta)D(\mathbf{x}; \phi)\)</span> with respect to <span class="math inline">\(\mathbf{x}\)</span>. The distribution often has more than one mode for animals at the edge of a detector array or searched area. It should not be confused with the home range utilisation pdf.</p>
</div>
<div id="telemetrylikelihood" class="section level2" number="5.11">
<h2><span class="header-section-number">5.11</span> Telemetry</h2>
<p>[to be added]</p>
<!--chapter:end:05-theory-special-topics.Rmd-->
</div>
</div>
<div id="part-practical-guide" class="section level1 unnumbered">
<h1 class="unnumbered">(PART*) Practical guide</h1>
</div>
<div id="r-package-secr" class="section level1" number="6">
<h1><span class="header-section-number">6</span> R package secr</h1>
<p></p>
<p>VERY SOFTWARE-SPECIFIC – POSSIBLY MOVE TO APPENDIX</p>
<p>This chapter provides an overview of <strong>secr</strong> <span class="citation">(<a href="#ref-R-secr">Efford 2024</a>)</span>. Following chapters expand on key topics.</p>
<p>To reproduce examples in the book you will need a recent version of <strong>secr</strong> (4.6.6 or later). Text in <code>this font</code> refers to R objects that are documented in online help for the <strong>secr</strong> package, or in base R. R code often generates warnings. Some warnings are merely reminders (e.g., that a default value is used for a key argument). For clarity, we do not display routine warnings for examples in the text.</p>
<p>In the examples we often use the function <a href="https://www.otago.ac.nz/density/html/list.secr.fit.html"><code>list.secr.fit</code></a> to fit several competing models while holding constant other arguments of <code>secr.fit</code>. The result is a single ‘secrlist’ that may be passed to <code>AIC</code>, <code>predict</code> etc.</p>
<div id="history" class="section level2" number="6.1">
<h2><span class="header-section-number">6.1</span> History</h2>
<p><strong>secr</strong> supercedes the Windows program DENSITY, an earlier graphical interface to SECR methods <span class="citation">(<a href="#ref-edr04">Efford, Dawson, and Robbins 2004</a>; <a href="#ref-e12">Efford 2012</a>)</span>. The package was first released in March 2010 and continues to be developed. It implements almost all the methods described by <span class="citation">Borchers and Efford (<a href="#ref-be08">2008</a>)</span>, <span class="citation">Efford, Borchers, and Byrom (<a href="#ref-ebb09">2009</a>)</span>, <span class="citation">Efford (<a href="#ref-e11">2011</a>)</span>, <span class="citation">Efford and Fewster (<a href="#ref-ef13">2013</a>)</span>, <span class="citation">Efford, Borchers, and Mowat (<a href="#ref-ebm13">2013</a>)</span> and <span class="citation">Efford and Mowat (<a href="#ref-em14">2014</a>)</span>. External C++ code <span class="citation">(<a href="#ref-R-Rcpp">Eddelbuettel et al. 2023</a>)</span> is used for computationally intensive operations. Multi-threading on multiple CPUs with <strong>RcppParallel</strong> <span class="citation">(<a href="#ref-R-RcppParallel">Allaire et al. 2023</a>)</span> gives major speed gains. The package is available from <a href="https://CRAN.R-project.org/package=ipsecr">CRAN</a>; the development version is on <a href="https://github.com/MurrayEfford/secr">GitHub</a>.</p>
</div>
<div id="object-classes" class="section level2" number="6.2">
<h2><span class="header-section-number">6.2</span> Object classes</h2>
<p>
</p>
<p><strong>secr</strong> defines a set of R classes<a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a> and methods for data from detector arrays and models fitted to those data. To perform an SECR analysis you construct each of these objects in turn. Fig. @ref(fig:schematic) indicates the relationships among the classes.</p>
<p>(ref:esscap) Essentials of the <strong>secr</strong> package.</p>
<table>
<caption>(#tab:essentialclasses) Essential classes in <strong>secr</strong>.</caption>
<colgroup>
<col width="17%" />
<col width="82%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Class</th>
<th align="left">Data</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>traps</code></td>
<td align="left">locations of detectors; detector type (‘proximity’, ‘multi’, etc.)</td>
</tr>
<tr class="even">
<td align="left"><code>capthist</code></td>
<td align="left">spatial detection histories, including a ‘traps’ object</td>
</tr>
<tr class="odd">
<td align="left"><code>mask</code></td>
<td align="left">raster map of habitat near the detectors</td>
</tr>
<tr class="even">
<td align="left"><code>secr</code></td>
<td align="left">fitted SECR model</td>
</tr>
</tbody>
</table>
<div class="figure">
<img src="figures/schematic3.png" alt="(ref:esscap)" width="80%" />
<p class="caption">
(#fig:schematic)(ref:esscap)
</p>
</div>
<ul>
<li>Each object class (shaded box) comes with methods to display and manipulate the data it contains (e.g. <code>print</code>, <code>summary</code>, <code>plot</code>, <code>rbind</code>, <code>subset</code>).</li>
<li>The function <code>read.capthist</code> forms a ‘capthist’ object from input in two files, one the detector layout (saved as attribute ‘traps’) and the other the capture data.</li>
<li>By default, a habitat mask is generated automatically by <code>secr.fit</code> using a specified buffer around the detectors (traps). The function <code>make.mask</code> gives greater control over this step.</li>
<li>Any of the objects input to <code>secr.fit</code> (traps, capthist, mask) may include a dataframe of covariates saved as an attribute. Covariate names may be used in model formulae; the <code>covariates</code> method is used to extract or replace covariates. Use <code>addCovariates</code> for covariates from spatial data sources (e.g., shapefile or ‘sf’ object)</li>
<li>Fitted secr models may be manipulated with the methods shown on the right.</li>
</ul>
</div>
<div id="functions" class="section level2" number="6.3">
<h2><span class="header-section-number">6.3</span> Functions</h2>
<p>
</p>
<p>For details of how to use <strong>secr</strong> see the help pages and vignettes.</p>
<table>
<caption>(#tab:corefunctions) Core functions of <strong>secr</strong>. S3 methods are marked with an asterisk.</caption>
<colgroup>
<col width="22%" />
<col width="77%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="https://www.otago.ac.nz/density/html/addCovariates.html"><code>addCovariates</code></a></td>
<td align="left">add spatial covariates to traps or mask</td>
</tr>
<tr class="even">
<td align="left"><a href="https://www.otago.ac.nz/density/html/AIC.secr.html"><code>AIC</code></a>*</td>
<td align="left">model selection, model weights</td>
</tr>
<tr class="odd">
<td align="left"><a href="https://www.otago.ac.nz/density/html/covariates.html"><code>covariates</code></a></td>
<td align="left">extract or replace covariates of traps, capthist or mask</td>
</tr>
<tr class="even">
<td align="left"><a href="https://www.otago.ac.nz/density/html/derivedMS.html"><code>derived</code></a>*</td>
<td align="left">compute density from conditional likelihood models</td>
</tr>
<tr class="odd">
<td align="left"><a href="https://www.otago.ac.nz/density/html/make.mask.html"><code>make.mask</code></a></td>
<td align="left">construct habitat mask (= mesh)</td>
</tr>
<tr class="even">
<td align="left"><a href="https://www.otago.ac.nz/density/html/plot.secr.html"><code>plot</code></a>*</td>
<td align="left">plot capthist, traps or mask</td>
</tr>
<tr class="odd">
<td align="left"><a href="https://www.otago.ac.nz/density/html/predict.secr.html"><code>predict</code></a>*</td>
<td align="left">compute ‘real’ parameters for arbitrary levels of predictor variables</td>
</tr>
<tr class="even">
<td align="left"><a href="https://www.otago.ac.nz/density/html/predictDsurface.html"><code>predictDsurface</code></a></td>
<td align="left">evaluate density surface at each point of a mask</td>
</tr>
<tr class="odd">
<td align="left"><a href="https://www.otago.ac.nz/density/html/DENSITY.html"><code>read.capthist</code></a></td>
<td align="left">input captures and trap layout from Density format, one call</td>
</tr>
<tr class="even">
<td align="left"><a href="https://www.otago.ac.nz/density/html/region.N.html"><code>region.N</code></a>*</td>
<td align="left">compute expected and realised population size in specified region</td>
</tr>
<tr class="odd">
<td align="left"><a href="https://www.otago.ac.nz/density/html/secr.fit.html"><code>secr.fit</code></a></td>
<td align="left">maximum likelihood fit; result is a fitted ‘secr’ object</td>
</tr>
<tr class="even">
<td align="left"><a href="https://www.otago.ac.nz/density/html/print.secr.html"><code>summary</code></a>*</td>
<td align="left">summarise capthist, traps, mask, or fitted model</td>
</tr>
<tr class="odd">
<td align="left"><a href="https://www.otago.ac.nz/density/html/traps.html"><code>traps</code></a></td>
<td align="left">extract or replace traps object in capthist</td>
</tr>
</tbody>
</table>
</div>
<div id="detector-types" class="section level2" number="6.4">
<h2><span class="header-section-number">6.4</span> Detector types</h2>
<p>
</p>
<p>Detector type (Table @ref(tab:basicdetectortypes)) is a character value, an attribute of the ‘traps’ object.</p>
<table>
<caption>(#tab:basicdetectortypes) Basic detector types in <strong>secr</strong>. See Appendices @ref(Areaandtransectsearches) and @ref(Telemetry) for area-search and telemetry types.</caption>
<colgroup>
<col width="12%" />
<col width="29%" />
<col width="58%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Type</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">“single”</td>
<td align="left">single-catch trap</td>
<td align="left">catch one animal at a time</td>
</tr>
<tr class="even">
<td align="left">“multi”</td>
<td align="left">multi-catch trap</td>
<td align="left">may catch more than one animal at a time</td>
</tr>
<tr class="odd">
<td align="left">“proximity”</td>
<td align="left">binary proximity</td>
<td align="left">records presence at a point without restricting movement</td>
</tr>
<tr class="even">
<td align="left">“count”<sup>1</sup></td>
<td align="left">Poisson count proximity</td>
<td align="left">[binomN = 0] allows &gt;1 detection per animal per time</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Binomial count proximity</td>
<td align="left">[binomN &gt; 0] up to binomN detections per animal per time</td>
</tr>
</tbody>
</table>
<ol style="list-style-type: decimal">
<li>The “count” detector type is generic for integer data; the actual type depends on the <code>secr.fit</code> argument ‘binomN’.</li>
</ol>
<!-- Acoustic 'signal strength' detectors produce a binary detection vector supplemented by measurements of signal strength, as from an array of microphones. -->
<p>There is limited support in <strong>secr</strong> for the analysis of locational data from telemetry (‘telemetry’ detector type). Telemetry data are used to augment capture–recapture data (Appendix @ref(Telemetry)).</p>
</div>
<div id="input" class="section level2" number="6.5">
<h2><span class="header-section-number">6.5</span> Input</h2>
<p>Data input is covered in the data input vignette <a href="https://www.otago.ac.nz/density/pdfs/secr-datainput.pdf">secr-datainput.pdf</a>. One option is to use text files in the formats used by DENSITY; these accommodate most types of data. Two files are required, one of detector (trap) locations and one of the detections (captures) themselves; the function <code>read.capthist</code> reads both files and constructs a capthist object. It is also possible to construct the capthist object in two stages, first making a traps object (with <code>read.traps</code>) and a captures dataframe, and then combining these with <code>make.capthist</code>. This more general route may be needed for unusual datasets.</p>
</div>
<div id="output-1" class="section level2" number="6.6">
<h2><span class="header-section-number">6.6</span> Output</h2>
<p>Function <code>secr.fit</code> returns an object of class <code>secr</code>. This is an R list with many components. Assigning the output to a named object saves both the fit and the data for further manipulation. Typing the object name at the R prompt invokes <code>print.secr</code> which formats the key results. These include the dataframe of estimates from the <code>predict</code> method for <code>secr</code> objects. Functions are provided for further computations on <code>secr</code> objects (e.g., AIC model selection, model averaging, profile-likelihood confidence intervals, and likelihood-ratio tests). Several of these are listed in Table @ref(tab:corefunctions).</p>
<p></p>
<p>One system of units is used throughout <strong>secr</strong>. Distances are in metres and areas are in hectares (ha). The unit of density for 2-dimensional habitat is animals per hectare. 1 ha = 10000 m<sup>2</sup> = 0.01 km<sup>2</sup>. To convert density to animals per km<sup>2</sup>, multiply by 100. Density in linear habitats (see package <strong>secrlinear</strong>) is expressed in animals per km.</p>
</div>
<div id="documentation" class="section level2" number="6.7">
<h2><span class="header-section-number">6.7</span> Documentation</h2>
<p></p>
<p>The primary documentation for <strong>secr</strong> is in the help pages that accompany the package. Help for a function is obtained in the usual way by typing a question mark at the R prompt, followed by the function name. Note the ‘Index’ link at the bottom of each help page – you will probably need to scroll down to find it. The index may also be accessed with <code>help(package = secr)</code>.</p>
<p>The consolidated help pages are in the <a href="https://CRAN.R-project.org/package=secr/secr.pdf">manual</a>. Searching this pdf is a powerful way to locate a function for a particular task.</p>
<p>Other documentation has traditionally been in the form of pdf vignettes built with <strong>knitr</strong> and available at <a href="https://otago.ac.nz/density/SECRinR" class="uri">https://otago.ac.nz/density/SECRinR</a>. That content will be included progressively in this online book.</p>
<p>The <strong>secr</strong> <a href="https://github.com/MurrayEfford/secr">GitHub repository</a> holds the development version, and bugs may be reported there by raising an Issue. New versions will be posted on <a href="https://cran.r-project.org/package=secr">CRAN</a> and noted on <a href="https://www.otago.ac.nz/density/" class="uri">https://www.otago.ac.nz/density/</a>, but there may be a delay. For information on changes in each version, type at the R prompt:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="fu">news</span> (<span class="at">package =</span> <span class="st">&quot;secr&quot;</span>) </span></code></pre></div>
<p>Help may be sought in online forums such as <a href="http://www.phidot.org/forum/">phidot</a> and <a href="https://groups.google.com/forum/#!forum/secrgroup">secrgroup</a>.</p>
</div>
<div id="using-secr.fit" class="section level2" number="6.8">
<h2><span class="header-section-number">6.8</span> Using <code>secr.fit</code></h2>
<p>We saw <code>secr.fit</code> in action in Chapter @ref(Example). Here we expand on particular arguments.</p>
<div id="starting-values" class="section level3" number="6.8.1">
<h3><span class="header-section-number">6.8.1</span> Starting values</h3>
<p>Maximum likelihood requires a starting value for each coefficient in the model. <strong>secr</strong> relieves the user of this chore by applying an algorithm that works in most cases. The core of the algorithm is exported in function <code>autoini</code>.</p>
<ol style="list-style-type: decimal">
<li>Compute an approximate bivariate normal <span class="math inline">\(\sigma\)</span> from the 2-D dispersion of individual locations:
<span class="math display">\[\begin{equation}
\sigma = \sqrt{\frac {\sum\limits _{i=1}^{n} \sum\limits _{j=1}^{n_i} [
     (x_{i,j} - \overline x_i)^2 + (y_{i,j} - \overline y_i)^2]}
     {2\sum\limits _{i=1}^{n} (n_i-1)}},
\end{equation}\]</span>
where <span class="math inline">\((x_{i,j}, y_{i,j})\)</span> is the location of the <span class="math inline">\(j\)</span>-th detection of individual <span class="math inline">\(i\)</span>. This is implemented in the function <code>RPSV</code> with <code>CC = TRUE</code>. The value is approximate because it ignores that detections are constrained by the locations of the detectors.</li>
<li>Find by numerical search value of <span class="math inline">\(g_0\)</span> that with <span class="math inline">\(\sigma\)</span> predicts the observed mean number of captures per individual <span class="citation">(<a href="#ref-edb09">Efford, Dawson, and Borchers 2009</a>, Appendix B)</span>.</li>
<li>Compute the <a href="#esa">effective sampling area</a> <span class="math inline">\(a(g_0, \sigma)\)</span>.</li>
<li>Compute <span class="math inline">\(D = n/a(g_0, \sigma)\)</span>, where <span class="math inline">\(n\)</span> is the number of individuals detected.</li>
</ol>
<p>After transformation this provides intercepts on the link scale for the core parameters <span class="math inline">\(D, g_0\)</span> and <span class="math inline">\(\sigma\)</span>. For hazard models <span class="math inline">\(\lambda_0\)</span> is first set to <span class="math inline">\(-\log(1 - g_0)\)</span>. Further coefficients are set to zero on the link scale.</p>
<p>Users may provide their own starting values, as either a vector of coefficients or a previously fitted model.</p>
</div>
<div id="models" class="section level3" number="6.8.2">
<h3><span class="header-section-number">6.8.2</span> Models</h3>
<p>The core parameters are ‘real’ parameters in the terminology of MARK <span class="citation">(<a href="#ref-cw">Cooch and White 2023</a>)</span>. Three real parameters are commonly modelled in <strong>secr</strong>: ‘D’ (for density), and ‘g0’ and ‘sigma’ (for the detection function). Other ‘real’ parameters appear in particular contexts. ‘z’ is a shape parameter that is used only when the <a href="#detectfn">detection function</a> has three parameters. Some detection functions primarily model the cumulative hazard of detection, rather than the probability of detection; these use the real parameter ‘lambda0’ in place of ‘g0’. A further ‘real’ parameter is the mixing proportion ‘pmix’, used in <a href="#finite-mixtures">finite mixture models</a> and <a href="#hybrid-mixtures">hybrid mixture models</a>.</p>
<p>By default, each ‘real’ parameter is assumed to be constant over time, space and individual. We specify more interesting, and often better-fitting, models with the ‘model’ argument of <code>secr.fit</code>. Here ‘models’ relates to variation in the parameters that may be explained by known factors and covariates. Models are defined symbolically in <strong>secr</strong> using R formula notation. A separate linear predictor is used for each core parameter. The workings are explained in detail in Chapters @ref(Detection) and @ref(Density).</p>
</div>
<div id="CL" class="section level3" number="6.8.3">
<h3><span class="header-section-number">6.8.3</span> Conditional vs full likelihood</h3>
<p>‘CL’ switches between maximizing the likelihood conditional on <span class="math inline">\(n\)</span> (TRUE) or the full likelihood (FALSE). The conditional option is faster because it does not estimate density. Density (assumed uniform) may be estimated from the conditional fit with <code>derived</code><a href="#fn19" class="footnote-ref" id="fnref19"><sup>19</sup></a>. For Poisson <span class="math inline">\(n\)</span> (the default), the estimate is identical within numerical error to that from the full likelihood. The alternative (binomial <span class="math inline">\(n\)</span>) is obtained by setting the <a href="#details">details argument</a> ‘distribution = “binomial”’.</p>
</div>
<div id="details" class="section level3" number="6.8.4">
<h3><span class="header-section-number">6.8.4</span> The ‘details’ argument</h3>
<p></p>
<p>Many minor and infrequently used arguments are grouped as ‘details’. See [this link] for a list. We mention only the most important here: others appear in later chapters.</p>
<div id="distribution-of-n" class="section level4" number="6.8.4.1">
<h4><span class="header-section-number">6.8.4.1</span> Distribution of <span class="math inline">\(n\)</span></h4>
<p>
</p>
<p>This argument switches between two possibilities for the distribution of <span class="math inline">\(n\)</span>: ‘poisson’ (the default) or ‘binomial’. Binomial <span class="math inline">\(n\)</span> conditions on fixed <span class="math inline">\(N(A)\)</span> where <span class="math inline">\(A\)</span> is the area of the habitat mask. This corresponds to point process with a fixed number of activity centres inside an arbitrary boundary. Estimates of density conditional on <span class="math inline">\(N(A)\)</span> have lower variance, but this is usually an artifact of the conditioning.</p>
</div>
<div id="fast-proximity" class="section level4" number="6.8.4.2">
<h4><span class="header-section-number">6.8.4.2</span> Fast proximity</h4>
<p></p>
<p>Binary and count data collected over several occasions may be collapsed to a single occasion, given certain conditions. Collapsed data lead to the same estimates (e.g., <span class="citation">Efford, Dawson, and Borchers (<a href="#ref-edb09">2009</a>)</span>) with a considerable saving in execution time. Data from binary proximity detectors are modelled as binomial with size equal to the number of occasions. The requirement is that no information is lost that is relevant to the model. This really depends on the model: collapsed data are inadequate for time-dependent models, including those with behavioural responses (Chapter @ref(Detection)).</p>
<p>By default, data are automatically collapsed to speed up processing when the model allows. This is inconvenient if you wish to use AIC to compare a variety of models. The problem is solved by setting ‘details = list(fastproximity = FALSE)’ for all models. Fitting will be slow.</p>
</div>
<div id="fixing-coefficients" class="section level4" number="6.8.4.3">
<h4><span class="header-section-number">6.8.4.3</span> Fixing coefficients</h4>
<p>The ‘details’ component ‘fixedbeta’ may be used to fix certain coefficients while allowing others to vary.</p>
</div>
</div>
<div id="method" class="section level3" number="6.8.5">
<h3><span class="header-section-number">6.8.5</span> Method</h3>
<p></p>
<p>Models are fitted in <code>secr.fit</code> by numerically maximizing the log-likelihood with functions from the <strong>stats</strong> package <span class="citation">(<a href="#ref-R-base">R Core Team 2024</a>)</span>. The default method is ‘Newton-Raphson’ in the function <code>stats::nlm</code>. By default, all reported variances, covariances, standard errors and confidence limits are asymptotic and based on a numerical estimate of the information matrix, as described <a href="#confidenceintervals">here</a>.</p>
<p>The Newton-Raphson algorithm is fast, but it sometimes fails to compute the information matrix correctly, causing some standard errors to be set to NA; see the ‘method’ argument of <code>secr.fit</code> for alternatives. Use <code>confint.secr</code> for profile likelihood intervals and <code>sim.secr</code> for parametric bootstrap intervals (both are slow).</p>
<p>Numerical maximization has some implications for the user. Computation may be slow, especially if there are many points in the mask, and estimates may be sensitive to the particular choice of mask (either explicitly in <code>make.mask</code> or implicitly via the ‘buffer’ argument).</p>
<!--chapter:end:06-secr-package.Rmd-->
</div>
</div>
</div>
<div id="Detection" class="section level1" number="7">
<h1><span class="header-section-number">7</span> Detection model</h1>
<p>The detection model in SECR most commonly models the probability that an individual with a particular activity centre will be detected on a particular occasion at a particular place (detector). If the detector type allows for multiple detections (cues or visits) the model describes the number of detections rather than probability.</p>
<p>A bare-bones detection model is a distance-detection function (or simply ‘detection function’) with two parameters, intercept and spatial scale. There are three sources of complexity and opportunities for customisation:</p>
<ul>
<li>function shape (e.g., halfnormal vs negative exponential) and whether it describes the
probability or hazard of detection,</li>
<li>parameters may depend on other known variables, and</li>
<li>parameters may be modelled as random effects to represent variation of unknown origin.</li>
</ul>
<p>We consider the shape of detection functions in the next section. Modelling parameters as a function of other variables is addressed in the following section on <a href="#linear-submodels">linear submodels</a>. Random effects in <strong>secr</strong> are limited to finite mixture models that we cover in the following chapter on <a href="#individual-heterogeneity">individual heterogeneity</a>.</p>
<div id="detectfn" class="section level2" number="7.1">
<h2><span class="header-section-number">7.1</span> Distance-detection functions</h2>
<p></p>
<p>The probability of detection <span class="math inline">\(g(d)\)</span> at a detector distance <span class="math inline">\(d\)</span> from an activity centre may take one of the simple forms in Table @ref(tab:detectfn). Alternatively, the probability of detection may be derived from <span class="math inline">\(g(d) = 1 - \exp[-\lambda(d)]\)</span> where <span class="math inline">\(\lambda(d)\)</span> is the hazard of detection, itself modelled with one of the simple parametric forms (Table @ref(tab:hazarddetectfn))<a href="#fn20" class="footnote-ref" id="fnref20"><sup>20</sup></a>.
Several further options are provided by <code>secr.fit</code> (see <code>? detectfn</code>), but only ‘HN’,‘HR’, and ‘EX’ or their ‘hazard’ equivalents are commonly used.</p>
<table>
<caption>(#tab:detectfn) Probability detection functions.</caption>
<colgroup>
<col width="8%" />
<col width="30%" />
<col width="14%" />
<col width="48%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Code</th>
<th align="left">Name</th>
<th align="left">Parameters</th>
<th align="left">Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">HN</td>
<td align="left">halfnormal</td>
<td align="left"><span class="math inline">\(g_0, \sigma\)</span></td>
<td align="left"><span class="math inline">\(g(d) = g_0 \exp \left(\frac{-d^2} {2\sigma^2} \right)\)</span></td>
</tr>
<tr class="even">
<td align="left">HR</td>
<td align="left">hazard rate<a href="#fn21" class="footnote-ref" id="fnref21"><sup>21</sup></a></td>
<td align="left"><span class="math inline">\(g_0, \sigma, z\)</span></td>
<td align="left"><span class="math inline">\(g(d) = g_0 [1 - \exp\{{-(^d/_\sigma)^{-z}} \}]\)</span></td>
</tr>
<tr class="odd">
<td align="left">EX</td>
<td align="left">exponential</td>
<td align="left"><span class="math inline">\(g_0, \sigma\)</span></td>
<td align="left"><span class="math inline">\(g(d) = g_0 \exp \{-(^d/_\sigma) \}\)</span></td>
</tr>
</tbody>
</table>
<p><br />
</p>
<table>
<caption>(#tab:hazarddetectfn) Hazard detection functions.</caption>
<colgroup>
<col width="8%" />
<col width="33%" />
<col width="14%" />
<col width="43%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Code</th>
<th align="left">Name</th>
<th align="left">Parameters</th>
<th align="left">Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">HHN</td>
<td align="left">hazard halfnormal</td>
<td align="left"><span class="math inline">\(\lambda_0, \sigma\)</span></td>
<td align="left"><span class="math inline">\(\lambda(d) = \lambda_0 \exp \left(\frac{-d^2} {2\sigma^2} \right)\)</span></td>
</tr>
<tr class="even">
<td align="left">HHR</td>
<td align="left">hazard hazard rate</td>
<td align="left"><span class="math inline">\(\lambda_0, \sigma, z\)</span></td>
<td align="left"><span class="math inline">\(\lambda(d) = \lambda_0 (1 - \exp \{ -(^d/_\sigma)^{-z} \})\)</span></td>
</tr>
<tr class="odd">
<td align="left">HEX</td>
<td align="left">hazard exponential</td>
<td align="left"><span class="math inline">\(\lambda_0, \sigma\)</span></td>
<td align="left"><span class="math inline">\(\lambda(d) = \lambda_0 \exp \{ -(^d/_\sigma) \}\)</span></td>
</tr>
<tr class="even">
<td align="left">HVP</td>
<td align="left">hazard variable power</td>
<td align="left"><span class="math inline">\(\lambda_0, \sigma, z\)</span></td>
<td align="left"><span class="math inline">\(\lambda(d) = \lambda_0 \exp \{ -(^d/_\sigma)^{z} \}\)</span></td>
</tr>
</tbody>
</table>
<p><br />
</p>
<p>The merits of focussing on the hazard<a href="#fn22" class="footnote-ref" id="fnref22"><sup>22</sup></a> are a little arcane. We list them here:</p>
<ol style="list-style-type: decimal">
<li>Quantities on the hazard scale are additive and more tractable for some purposes (e.g. adjusting for effort, computing <a href="#Expected">expected counts</a>).</li>
<li>For some detector types (e.g., Poisson counts) the data are integers, for which <span class="math inline">\(\lambda(d)\)</span> has a direct interpretation as the expected count. However, <span class="math inline">\(\lambda(d)\)</span> can always be derived from <span class="math inline">\(g(d)\)</span> (<span class="math inline">\(\lambda(d) = -\log[1 - g(d)]\)</span>).</li>
<li>Intuitively, there is a close proportionality between <span class="math inline">\(\lambda(d)\)</span> and the height of an individual’s utilization pdf.</li>
</ol>
<p>The ‘hazard variable power’ function<a href="#fn23" class="footnote-ref" id="fnref23"><sup>23</sup></a> is a 3-parameter function modelled on that of <span class="citation">Ergon and Gardner (<a href="#ref-Ergon2013">2013</a>)</span>. The third parameter allows for smooth variation of shape, including both HHN (<span class="math inline">\(z = 2\)</span>) and HEX (<span class="math inline">\(z = 1\)</span>) as special cases.</p>
<div id="choice-of-detection-function-not-critical" class="section level3" number="7.1.1">
<h3><span class="header-section-number">7.1.1</span> Choice of detection function not critical</h3>
<p>The variety of detection functions is daunting. You could try them all and select the “best” by AIC, but we do not recommend this. Fortunately, the choice of function is not critical. We illustrate this with the <a href="#Example">snowshoe hare dataset</a> and <code>list.secr.fit</code><a href="#fn24" class="footnote-ref" id="fnref24"><sup>24</sup></a>. Warnings due to the use of a multi-catch likelihood for single-catch traps are suppressed both here and in other examples.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&#39;HHN&#39;</span>,<span class="st">&#39;HHR&#39;</span>,<span class="st">&#39;HEX&#39;</span>,<span class="st">&#39;HVP&#39;</span>)</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>fits <span class="ot">&lt;-</span> <span class="fu">list.secr.fit</span>(<span class="at">detectfn =</span> df, <span class="at">constant =</span> <span class="fu">list</span>(<span class="at">capthist =</span> hareCH6, </span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>              <span class="at">buffer =</span> <span class="dv">250</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>), <span class="at">names =</span> df)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/choicedfplot-1.png" alt="Four detection functions fitted to snowshoe hare data" width="60%" />
<p class="caption">
(#fig:choicedfplot)Four detection functions fitted to snowshoe hare data
</p>
</div>
<p>The relative fit of the HHR, HVP and HEX models is essentially the same, whereas HHN is distinctly worse:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="fu">AIC</span>(fits, <span class="at">criterion =</span> <span class="st">&#39;AIC&#39;</span>)[, <span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">7</span>,<span class="dv">8</span>)]</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a><span class="do">##                  detectfn npar  logLik   dAIC  AICwt</span></span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a><span class="do">## HHR    hazard hazard rate    4 -599.68  0.000 0.5474</span></span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a><span class="do">## HVP hazard variable power    4 -600.43  1.487 0.2603</span></span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a><span class="do">## HEX    hazard exponential    3 -601.73  2.092 0.1923</span></span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a><span class="do">## HHN     hazard halfnormal    3 -608.07 14.783 0.0000</span></span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/choicedfparmplot-1.png" alt="Parameter estimates from four detection functions (95% CI)." width="604.8" />
<p class="caption">
(#fig:choicedfparmplot)Parameter estimates from four detection functions (95% CI).
</p>
</div>
<p>The third parameter <span class="math inline">\(z\)</span> was estimated as 3.08 for HHR, and
0.67 for HVP.</p>
<p>Fitting the HVP function with <span class="math inline">\(z\)</span> fixed to different values is another way to examine the effect of shape (Fig. @ref(fig:HVPvaryzplot)). Density estimates ranged only from 1.47 to 1.42.</p>
<div class="figure">
<img src="SECRbook_files/figure-html/HVPvaryzplot-1.png" alt="HVP function fitted to snowshoe hare data with $z$ parameter fixed at four different values" width="60%" />
<p class="caption">
(#fig:HVPvaryzplot)HVP function fitted to snowshoe hare data with <span class="math inline">\(z\)</span> parameter fixed at four different values
</p>
</div>
<p>How can different functions produce nearly the same estimates? Remember that <a href="#esa"><span class="math inline">\(\hat D = n/a(\hat \theta)\)</span></a>, and <span class="math inline">\(n\)</span> is the same for all models. Constant <span class="math inline">\(\hat D\)</span> therefore implies constant effective sampling area <span class="math inline">\(a(\hat \theta)\)</span>. In other words, variation in <span class="math inline">\(\hat \lambda_0\)</span> and <span class="math inline">\(\hat \sigma\)</span> ‘washes out’ when they are combined in <span class="math inline">\(a(\hat \theta)\)</span>. Under the four models <span class="math inline">\(a(\hat \theta)\)</span> is estimated as 46.4, 48.4, 45.9 and 46.7 ha.</p>
</div>
<div id="detection-parameters-are-nuisance-parameters-mostly" class="section level3" number="7.1.2">
<h3><span class="header-section-number">7.1.2</span> Detection parameters are nuisance parameters (mostly)</h3>
<p>The detection model and its parameters (<span class="math inline">\(g_0\)</span>, <span class="math inline">\(\lambda_0\)</span>, <span class="math inline">\(\sigma\)</span> etc.) provide the link between our observations and the state of the animal population represented by the parameter <span class="math inline">\(D\)</span> (density, distribution in space, trend etc.). Submodels for <span class="math inline">\(D\)</span> are considered in Chapter @ref(Density). But what interpretation should we attach to the detection parameters themselves?</p>
<p>The intercept <span class="math inline">\(g_0\)</span> is in a sense the probability of that an animal will be detected at the centre of its home range. The spatial scale of detection <span class="math inline">\(\sigma\)</span> relates to the size of the home range. These attributed meanings can aid intuitive understanding. However, we advise against a literal reading. The estimates have meaning only for a specified detection function and cannot meaningfully be compared across functions. Observe the</p>
<p>The halfnormal function is closest to a standard reference, but estimates of halfnormal <span class="math inline">\(\sigma\)</span> are sensitive to infrequent large movements. Care is also needed because some early writers omitted the factor 2 from the denominator, increasing estimates of <span class="math inline">\(\sigma\)</span> by <span class="math inline">\(\sqrt 2\)</span><a href="#fn25" class="footnote-ref" id="fnref25"><sup>25</sup></a>.</p>
<p>Continuing the snowshoe hare example: the estimates of <span class="math inline">\(\lambda_0\)</span> and <span class="math inline">\(\sigma\)</span> from HVP are surprisingy uncertain when considered on their own, yet the HVP estimate of density has about the same precision as other detection functions (Fig. @ref(fig:choicedfparmplot)). How can this be? There is strong covariation in the sampling distributions of the two parameters that we plot using <code>ellipse.secr</code> in Fig. @ref(fig:ellipseHVP).</p>
<div class="figure">
<img src="SECRbook_files/figure-html/ellipseHVP-1.png" alt="Confidence ellipse for HVP detection parameters plotted on the link scale and back-transformed to natural scale. '+' indicates MLE" width="576" />
<p class="caption">
(#fig:ellipseHVP)Confidence ellipse for HVP detection parameters plotted on the link scale and back-transformed to natural scale. ‘+’ indicates MLE
</p>
</div>
</div>
<div id="secr-is-not-distance-sampling" class="section level3" number="7.1.3">
<h3><span class="header-section-number">7.1.3</span> SECR is not distance sampling</h3>
<p>The idea of a distance-detection function originated in distance sampling <span class="citation">(<a href="#ref-bablbt01">Buckland et al. 2001</a>)</span> and <span class="citation">Borchers et al. (<a href="#ref-Borchers2015">2015</a>)</span> provided a unified framework for spatially explicit capture–recapture and distance sampling. Nevertheless, the role of the detection function differs substantially.</p>
<p>In distance sampling, shape matters a lot. In particular, the estimate of density depends on the slope of the detection function near the origin, given the assumption that all animals at the origin are detected <span class="citation">(e.g., <a href="#ref-Buckland2015">Buckland et al. 2015</a>)</span>.</p>
<p>In SECR, no special significance is attached to the origin or the shape of the function. The detection function serves as a spatial filter for a modelled 2-dimensional point pattern of activity centres; the filter must ‘explain’ the frequency of recaptures and their spatial spread. These are the components of the effective sampling area.</p>
<p>The hazard-rate function HR is recommended for distance sampling because it has a distinct ‘shoulder’ near zero distance, and distance sampling is not concerned with the tail (distant observations are often censored). SECR relies on the tail flattening to zero within the region of integration (<a href="#Habitat">habitat mask</a>). Otherwise, the population at risk of detection is determined by the choice of mask, which is usually arbitrary and <em>ad hoc</em>. The hazard-rate function has an extremely long tail (it is not convergent), so there is always a risk of mask-dependence. As an aside - in the snowshoe hare example with detection function HHR we suppressed the warning “predicted relative bias exceeds 0.01 with buffer = 250” that is due to truncation of the long tail.</p>
</div>
<div id="whybother1" class="section level3" number="7.1.4">
<h3><span class="header-section-number">7.1.4</span> Why bother?</h3>
<p>Given the preceding comments you may wonder why we bother with different detection functions at all. In part this is historical: it was not obvious in the beginning that density estimates were so robust. Sometimes it’s just nice to have the flexibility to match the model to animal behaviour. Functions with longer tails (e.g., HEX) accommodate occasional extreme movements that can prevent a short-tailed function (HHN) from fitting at all.</p>
<p>Also, it is desirable to account for any significant lack of fit due to the detection function before modelling effects that may have a more critical effect on density estimates, such as individual heterogeneity and learned responses.</p>
</div>
</div>
<div id="linear-submodels" class="section level2" number="7.2">
<h2><span class="header-section-number">7.2</span> Detection submodels</h2>
<p></p>
<p>Until now we have assumed that there is a single beta parameter for each real parameter. A much richer set of models is obtained by treating each real parameter as a function of covariates. For convenience, the function is linear on the appropriate <a href="#link">link</a> scale. The single ‘beta’ coefficient is then replaced by two or more coefficients (e.g., intercept <span class="math inline">\(\beta_0\)</span> and slope <span class="math inline">\(\beta_1\)</span> of the linear relationship <span class="math inline">\(y = \beta_0 + \beta_1x_1\)</span> where <span class="math inline">\(y\)</span> is a parameter on the link scale and <span class="math inline">\(x_1\)</span> is a covariate). Suppose, for example, that <span class="math inline">\(y\)</span> depends on sampling occasion <span class="math inline">\(s\)</span> then <span class="math inline">\(y(s) = \beta_0 + \beta_1x_1(s)\)</span> and the corresponding real parameter is <span class="math inline">\(y(s)\)</span> back transformed from the link scale.</p>
<p>This may be generalised using the notation of linear models,
<span class="math display">\[\begin{equation}
\mathbf{y} = \mathbf{X} \pmb {\beta},
(\#eq:linearmodel)
\end{equation}\]</span>
where <span class="math inline">\(\mathbf{X}\)</span> is the design matrix,
<!-- rather than \pmb from amsmath, can use \boldsymbol for HTML, \symbf for pdf -->
<span class="math inline">\(\pmb{\beta}\)</span> is a vector of coefficients, and <span class="math inline">\(\mathbf{y}\)</span> is the resulting vector of values on the link scale, one for each row of <span class="math inline">\(\mathbf{X}\)</span>. The first column of the design matrix is a column of 1’s for the intercept <span class="math inline">\(\beta_0\)</span>. Factor (categorical) predictors will usually be represented by several columns of indicator values (0’s and 1’s coding factor levels). See <span class="citation">Cooch and White (<a href="#ref-cw">2023</a>)</span> Chapter 6 for an accessible introduction to linear models and design matrices.</p>
<p>In <strong>secr</strong> each detection parameter (<span class="math inline">\(g_0, \lambda_0, \sigma, z\)</span>) is controlled by a linear submodel on its link scale, i.e. each has its own design matrix. <em>Rows</em> of the design matrix correspond to combinations of session, individual, occasion, and detector, omitting any of these four that is constant (perhaps because there is only one level). Finite-mixture models add further rows to the design matrix that we leave aside for now. <em>Columns</em> after the first are either (i) indicators to represent effects that can be constructed automatically (Table @ref(tab:predictors)), or (ii) user-supplied covariates associated with sessions, individuals, occasions or detectors.</p>
<table>
<caption>(#tab:predictors) Automatically generated predictor variables for detection models</caption>
<colgroup>
<col width="12%" />
<col width="22%" />
<col width="65%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Variable</th>
<th align="left">Description</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">g</td>
<td align="left">group</td>
<td align="left"><a href="#groups">groups</a> are defined by the individual covariate(s) named in the ‘groups’ argument</td>
</tr>
<tr class="even">
<td align="left">t</td>
<td align="left">time factor</td>
<td align="left">one level for each occasion</td>
</tr>
<tr class="odd">
<td align="left">T</td>
<td align="left">time trend</td>
<td align="left">linear trend over occasions on link scale</td>
</tr>
<tr class="even">
<td align="left">b</td>
<td align="left">learned response</td>
<td align="left">step change after first detection</td>
</tr>
<tr class="odd">
<td align="left">B</td>
<td align="left">transient response</td>
<td align="left">depends on detection at preceding occasion (Markovian response)</td>
</tr>
<tr class="even">
<td align="left">bk</td>
<td align="left">animal x site response</td>
<td align="left">site-specific step change</td>
</tr>
<tr class="odd">
<td align="left">Bk</td>
<td align="left">animal x site response</td>
<td align="left">site-specific transient response</td>
</tr>
<tr class="even">
<td align="left">k</td>
<td align="left">site learned response</td>
<td align="left">site effectiveness changes once any animal caught</td>
</tr>
<tr class="odd">
<td align="left">K</td>
<td align="left">site transient response</td>
<td align="left">site effectiveness depends on preceding occasion</td>
</tr>
<tr class="even">
<td align="left">session</td>
<td align="left">session factor</td>
<td align="left">one level for each session</td>
</tr>
<tr class="odd">
<td align="left">Session</td>
<td align="left">session trend</td>
<td align="left">linear trend on link scale</td>
</tr>
<tr class="even">
<td align="left">h2</td>
<td align="left">2-class mixture</td>
<td align="left"><a href="#finite-mixtures">finite mixture model</a> with 2 latent classes</td>
</tr>
<tr class="odd">
<td align="left">ts</td>
<td align="left">marking vs sighting</td>
<td align="left">two levels (marking and sighting occasions)</td>
</tr>
</tbody>
</table>
<p>Each design matrix is constructed automatically when <code>secr.fit</code> is called, using the data and a model formula. Computation of the linear predictor (Eq. @ref(eq:linearmodel)) and back-transformation to the real scale are also automatic. Thus the user need never see the design matrix.</p>
<p>The hard-wired structure of the design matrices precludes some possible submodels: there is no direct way to model <em>spatial</em> variation in a detection parameter. However, spatial effects may be modelled using detector covariates, i.e. as a function of detector location rather than AC location, and a further workaround for parameter <span class="math inline">\(\sigma\)</span> is shown in Appendix @ref(Noneuclidean).</p>
<blockquote>
<p>An aside: linear submodels for parameters are considered by <span class="citation">Cooch and White (<a href="#ref-cw">2023</a>)</span> as a <em>constraint</em> on a more general model. Their default is for each parameter to be fully-time-specific e.g., a Cormack-Jolly-Seber open population survival model would fit a unique detection probability <span class="math inline">\(p\)</span> and survival rate <span class="math inline">\(\phi\)</span> at each time. Our default is for each parameter to be constant (i.e. maximally constrained), and for linear submodels to introduce variation.</p>
</blockquote>
<p>The formula may be constant (<span class="math inline">\(\sim\)</span> 1, the default) or some combination of terms in standard R
formula notation (see <code>?formula</code>). For example, g0 <span class="math inline">\(\sim\)</span> b + T
specifies a model with a learned response and a linear time trend in
g0; the effects are additive on the link scale. Table @ref(tab:examples) has some examples.</p>
<table>
<caption>(#tab:examples) Some examples of the ‘model’ argument in <code>secr.fit</code></caption>
<colgroup>
<col width="31%" />
<col width="68%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Formula</th>
<th align="left">Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">g0 <span class="math inline">\(\sim\)</span> 1</td>
<td align="left">g0 constant across animals, occasions and detectors</td>
</tr>
<tr class="even">
<td align="left">g0 <span class="math inline">\(\sim\)</span> b</td>
<td align="left">learned response affects g0</td>
</tr>
<tr class="odd">
<td align="left">list(g0 <span class="math inline">\(\sim\)</span> b, sigma <span class="math inline">\(\sim\)</span> b)</td>
<td align="left">learned response affects both g0 and sigma</td>
</tr>
<tr class="even">
<td align="left">g0 <span class="math inline">\(\sim\)</span> h2</td>
<td align="left">2-class finite mixture for heterogeneity in g0</td>
</tr>
<tr class="odd">
<td align="left">g0 <span class="math inline">\(\sim\)</span> b + T</td>
<td align="left">learned response in g0 combined with trend over occasions</td>
</tr>
<tr class="even">
<td align="left">sigma <span class="math inline">\(\sim\)</span> g</td>
<td align="left">detection scale sigma differs between groups</td>
</tr>
<tr class="odd">
<td align="left">sigma <span class="math inline">\(\sim\)</span> g*T</td>
<td align="left">group-specific trend in sigma</td>
</tr>
</tbody>
</table>
<!-- Behavioural responses 'b', 'B', 'bk', and 'Bk' refer to individuals whereas 'k' and 'K' refer only to sites.  -->
<p>The common question of how to model sex differences can be answered in several ways. we devote a <a href="#sex">later section</a> to the possibilities (groups, individual covariate, hybrid mixtures etc.).</p>
<div id="covariates" class="section level3" number="7.2.1">
<h3><span class="header-section-number">7.2.1</span> Covariates</h3>
<p></p>
<p>Any name in a formula that is not listed as a variable in Table @ref(tab:predictors) is assumed to refer to a user-supplied covariate. <code>secr.fit</code> looks for user-supplied covariates in data frames embedded in the ‘capthist’ argument, or supplied in the ‘timecov’ and ‘sessioncov’ arguments, or named with the ‘timevaryingcov’ attribute of a traps object, using the first match (Table @ref(tab:covariates)).</p>
<table>
<caption>(#tab:covariates) Types of user-provided covariate for parameters of detection models. The names
of columns in the respective dataframes may be used in model formulae<sup>1</sup>.</caption>
<thead>
<tr class="header">
<th align="left">Covariate type</th>
<th align="left">Data source</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Individual</td>
<td align="left">covariates(capthist)</td>
</tr>
<tr class="even">
<td align="left">Time</td>
<td align="left">timecov argument</td>
</tr>
<tr class="odd">
<td align="left">Detector</td>
<td align="left">covariates(traps(capthist))</td>
</tr>
<tr class="even">
<td align="left">Detector x Time</td>
<td align="left">covariates(traps(capthist))<sup>1</sup></td>
</tr>
<tr class="odd">
<td align="left">Session</td>
<td align="left">sessioncov argument</td>
</tr>
</tbody>
</table>
<ol style="list-style-type: decimal">
<li>Time-varying detector covariates are a special case considered below.</li>
</ol>
<!-- [Hybrid mixture models](#hybrid-mixtures) allow some or all individuals to be assigned permanently to a group (mixture class), while other individuals (ideally a minority) may be of unknown class. -->
<p>A continuous covariate that takes many unique values poses problems for the implementation in <strong>secr</strong>. A multiplicity of values inflates the size of internal lookup tables, both slowing down each likelihood evaluation and potentially exceeding the available memory<a href="#fn26" class="footnote-ref" id="fnref26"><sup>26</sup></a>. A binned covariate should do the job equally well, while saving time and space (see function <code>binCovariate</code> <strong>secr</strong> <span class="math inline">\(\ge\)</span> 4.6.5).</p>
</div>
<div id="time-varying-trap-covariates" class="section level3" number="7.2.2">
<h3><span class="header-section-number">7.2.2</span> Time-varying trap covariates</h3>
<p></p>
<p>A special mechanism is provided for detector-level covariates that take different values on each occasion. Then we expect the dataframe of detector covariates to include a column for each occasion.</p>
<p>A ‘traps’ object may have an attribute ‘timevaryingcov’ that is a list in which each named component is a vector of indices identifying which covariate column to use on each occasion. The name may be used in model formulae. Use <code>timevaryingcov()</code> to extract or replace the attribute.</p>
</div>
<div id="regression-splines" class="section level3" number="7.2.3">
<h3><span class="header-section-number">7.2.3</span> Regression splines</h3>
<p></p>
<p>Modelling a link-linear<a href="#fn27" class="footnote-ref" id="fnref27"><sup>27</sup></a> relationship between a covariate and a parameter may be too restrictive.<br />
Regression splines are a very flexible way to represent non-linear responses in generalized additive models, implemented in the R package <strong>mgcv</strong> <span class="citation">(<a href="#ref-w06">Wood 2006</a>)</span>. <span class="citation">Borchers and Kidney (<a href="#ref-bk14">2014</a>)</span> showed how they may be used to model 2-dimensional trend in density. They used <strong>mgcv</strong> to construct regression spline basis functions from mask x- and y-coordinates, and possibly additional mask covariates, and then passed these as covariates to <code>secr.fit</code>. Smooth, semi-parametric responses are also useful for modelling variation in detection parameters such as <span class="math inline">\(g_0\)</span> and <span class="math inline">\(\sigma\)</span> over time, or in response to numeric individual- or detector-level covariates, when (1) a linear or other parametric response is arbitrary or implausible, and (2) sampling spans a range of times or levels of the covariate(s).</p>
<p>Smooth terms may be used in <strong>secr</strong> model formulae for both density and detection parameters. The covariate is merely wrapped in a call to the smoother function <code>s()</code>. Smoothness is controlled by the argument ‘k’.</p>
<p>For a concrete example, consider a population sampled monthly for a year (i.e., 12 ‘sessions’). If home range size varies seasonally then the parameter sigma may vary in a more-or-less sinusoidal fashion. A linear trend is obviously inadequate, and a quadratic is not much better. However, a sine curve is hard to fit (we would need to estimate its phase, amplitude, mean and spatial scale) and assumes the increase and decrease phases are equally steep. An extreme solution is to treat month as a factor and estimate a separate parameter for each level (month). A smooth (semi-parametric) curve may capture the main features of seasonal variation with fewer parameters.</p>
<p>There are some drawbacks to using smooth terms. The resulting fitted objects are large, on account of the need to store setup information from <strong>mgcv</strong>. The implementation may change in later versions of <strong>mgcv</strong> and <strong>secr</strong>, and smooth models fitted now will not necessarily be compatible with later versions. Setting the intercept of a smooth to zero is not a canned option in <strong>mgcv</strong>, and is not offered in <strong>secr</strong>. It may be achieved by placing a knot at zero and hacking the matrix of basis functions to drop the corresponding column, plus some more jiggling.</p>
</div>
<div id="whybother2" class="section level3" number="7.2.4">
<h3><span class="header-section-number">7.2.4</span> Why bother?</h3>
<p>Detailed modelling of detection parameters may be a waste of energy for the same reasons that the <a href="#whybother1">choice of detection function</a> itself has limited interest. See, for example, the simulation results of <span class="citation">Rahel Sollmann (<a href="#ref-Sollmann2024">2024</a>)</span> on occasion-specific models (<span class="math inline">\(\sim\)</span> t). However, behavioural responses and individual heterogeneity can have a major effect on density estimates, and these deserve attention.</p>
<div id="behavioural-responses" class="section level4" number="7.2.4.1">
<h4><span class="header-section-number">7.2.4.1</span> Behavioural responses</h4>
<p></p>
<p>An individual behavioral response is a change in the probability or hazard of detection on the occasions that follow a detection. Trapping of small mammals provides evidence of species that routinely become trap happy (presumably because they enjoy the bait) or trap shy (presumably because the experience of capture and handling is unpleasant). Positive or negative responses are modelled as a step change in a detection parameter, usually the intercept of the detection function (<span class="math inline">\(g_0\)</span>, <span class="math inline">\(\lambda_0\)</span>).</p>
<p>The response may be permanent (b) or transient (B) (i.e. applying only on the next occasion). In spatial models we also distinguish between a global response, across all detectors, and a local response, specific to the initial detector (suffix ‘k’). This leads to four response models: b, bk, B, and Bk.</p>
<p>We explore these options with Reid’s Wet Swizer Gulch deermouse (<em>Peromyscus maniculatus</em>) dataset from <span class="citation">Otis et al. (<a href="#ref-obwa78">1978</a>)</span>. Mice were trapped on a grid of 99 traps over 6 days. The Sherman traps were treated as multi-catch traps for this analysis. We fit the four behavioural response models and the null model to the morning data.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>cmod <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">&#39;g0~&#39;</span>, <span class="fu">c</span>(<span class="st">&#39;1&#39;</span>,<span class="st">&#39;b&#39;</span>,<span class="st">&#39;B&#39;</span>,<span class="st">&#39;bk&#39;</span>,<span class="st">&#39;Bk&#39;</span>))</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a><span class="co"># convert each character string to a formula and fit the models</span></span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a>fits <span class="ot">&lt;-</span> <span class="fu">list.secr.fit</span>(<span class="at">model =</span> <span class="fu">sapply</span>(cmod, formula), <span class="at">constant =</span> </span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a>    <span class="fu">list</span>(<span class="at">capthist =</span> <span class="st">&#39;deermouse.WSG&#39;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>, <span class="at">buffer =</span> <span class="dv">80</span>), </span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a>    <span class="at">names =</span> cmod)</span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a><span class="fu">AIC</span>(fits, <span class="at">criterion =</span> <span class="st">&#39;AIC&#39;</span>, <span class="at">sort =</span> <span class="cn">FALSE</span>)[<span class="fu">c</span>(<span class="dv">3</span><span class="sc">:</span><span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">8</span>)]</span></code></pre></div>
<pre><code>##       npar  logLik    AIC    dAIC AICwt
## g0~1     3 -663.54 1333.1 129.938     0
## g0~b     4 -643.72 1295.4  92.298     0
## g0~B     4 -651.62 1311.2 108.099     0
## g0~bk    4 -597.57 1203.1   0.000     1
## g0~Bk    4 -621.02 1250.0  46.910     0</code></pre>
<p>All response models are preferred to the null model, but the differences among them are marked: the evidence supports a persistent local response (bk). The density estimates for bk and Bk are close to the null model, whereas the b and B estimates are greater. In our experience this is a common result: a local response is preferred by AIC and has less impact on density estimates than a global response, and there is little penalty for omitting the response from the model.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="fu">collate</span>(fits, <span class="at">realnames =</span> <span class="st">&#39;D&#39;</span>)[<span class="dv">1</span>,,,]</span></code></pre></div>
<pre><code>##       estimate SE.estimate    lcl    ucl
## g0~1    14.089      2.0364 10.629 18.676
## g0~b    18.531      3.3461 13.044 26.324
## g0~B    15.726      2.3351 11.774 21.005
## g0~bk   13.884      2.1108 10.324 18.672
## g0~Bk   13.883      2.0472 10.414 18.506</code></pre>
<p>The estimated magnitude of the responses may be examined with <code>predict(fits[2:5], all.levels = TRUE)</code> but the output is long and we show only the global (b) and local (bk) enduring responses:</p>
<pre><code>## $`g0~b`
##                      estimate   lcl   ucl
## session = WSG, b = 0    0.055 0.031 0.096
## session = WSG, b = 1    0.210 0.163 0.267
## 
## $`g0~bk`
##                       estimate   lcl   ucl
## session = WSG, bk = 0    0.061 0.044 0.085
## session = WSG, bk = 1    0.596 0.454 0.723</code></pre>
<p>Here ‘b = 0’ and ‘bk = 0’ refer to <span class="math inline">\(g_0\)</span> for a naive animal and ‘b = 1’ and ‘bk = 1’ refer to the post-detection values (estimates are shown with 95% limits). It appears that deermice are highly likely to return to traps where they have been caught.</p>
<p>Detector-level ‘behavioural’ response is also possible (predictors k, K in <code>secr.fit</code>). Detection of any individuals at a detector may in principle be facilitated or inhibited by a previous detection there of any other individual. We are not aware of published examples.</p>
<p>The trap-facilitation model fitted to the deermouse data results in a larger and less precise estimate of density (16.78/ha, SE 2.59/ha), with AIC intermediate between the null model and bk (facilitation model <span class="math inline">\(\Delta\)</span>AIC = 73.7 relative to bk). There is a risk of confusing such an effect with simple heterogeneity in the performance of detectors or clumping of activity centres or an individual local response (bk). More investigation is needed.</p>
</div>
</div>
</div>
<div id="varying-effort-1" class="section level2" number="7.3">
<h2><span class="header-section-number">7.3</span> Varying effort</h2>
<p></p>
<p>Researchers are often painfully aware of glitches in their data gathering - traps that were not set, sampling occasions missed or delayed due to weather etc. Even when the actual estimates are robust, as in an example below, it is desirable (therapeutic and scientific) to allow for known irregularities in the data. This is the role of the ‘usage’ matrix as <a href="#varying-effort">described</a> in Chapter @ref(Theory).</p>
<p>The ‘usage’ attribute of a ‘traps’ object in <strong>secr</strong> is a <span class="math inline">\(K\)</span> x <span class="math inline">\(S\)</span> matrix recording the effort (<span class="math inline">\(T_{sk}\)</span>) at each detector <span class="math inline">\(k = 1...K\)</span> and occasion <span class="math inline">\(s = 1...S\)</span>. Effort may be binary (0/1) or continuous. If the attribute is missing (NULL) it will be treated as all ones. Extraction and replacement functions are provided (<code>usage</code> and <code>usage&lt;-</code>, as demonstrated below). All detector types accept usage data in the same format<a href="#fn28" class="footnote-ref" id="fnref28"><sup>28</sup></a>. Binomial count detectors are a special case: when the <code>secr.fit</code> argument binomN = 1, or equivalently binomN = ‘usage’, usage is interpreted as the size of the binomial distribution.</p>
<p>Usage data may be input as extra columns in a file of detector coordinates (see <code>?read.traps</code> and <a href="https://www.otago.ac.nz/density/pdfs/secr-datainput.pdf">secr-datainput.pdf</a>.</p>
<p>Usage data also may be added to an existing traps object, even after it has been included in a capthist object. For example, the traps object in the demonstration dataset ‘captdata’ starts with no usage attribute, but we can add one. Suppose that traps 14 and 15 were not set on occasions 1–3. We construct a binary usage matrix and assign it to the traps object like this:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>K <span class="ot">&lt;-</span> <span class="fu">nrow</span>(<span class="fu">traps</span>(captdata))</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a>S <span class="ot">&lt;-</span> <span class="fu">ncol</span>(captdata)</span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a>mat <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">1</span>, <span class="at">nrow =</span> K, <span class="at">ncol =</span> S)</span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a>mat[<span class="dv">14</span><span class="sc">:</span><span class="dv">15</span>,<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>] <span class="ot">&lt;-</span> <span class="dv">0</span>   <span class="co"># traps 14:15 not set on occasions 1:3</span></span>
<span id="cb24-5"><a href="#cb24-5" tabindex="-1"></a><span class="fu">usage</span>(<span class="fu">traps</span>(captdata)) <span class="ot">&lt;-</span> mat</span></code></pre></div>
<div id="models-1" class="section level3" number="7.3.1">
<h3><span class="header-section-number">7.3.1</span> Models</h3>
<p>The usage attribute of a traps object is applied automatically by <code>secr.fit</code>. Following on from the preceding example, we can confirm our assignment and fit a new model.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="fu">summary</span>(<span class="fu">traps</span>(captdata))    <span class="co"># confirm usage attribute</span></span></code></pre></div>
<pre><code>## Object class       traps 
## Detector type      single 
## Detector number    100 
## Average spacing    30 m 
## x-range            365 635 m 
## y-range            365 635 m 
## 
## Usage range by occasion
##     1 2 3 4 5
## min 0 0 0 1 1
## max 1 1 1 1 1</code></pre>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(captdata, <span class="at">buffer =</span> <span class="dv">100</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>, <span class="at">biasLimit =</span> <span class="cn">NA</span>)</span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a><span class="fu">predict</span>(fit)</span></code></pre></div>
<pre><code>##        link estimate SE.estimate      lcl      ucl
## D       log  5.47346    0.645991  4.34659  6.89249
## g0    logit  0.27473    0.027164  0.22479  0.33102
## sigma   log 29.39668    1.308421 26.94206 32.07494</code></pre>
<p>The result in this case is only subtly different from the model with uniform usage (compare <code>predict(secrdemo.0)</code>). Setting <code>biasLimit = NA</code> avoids a warning message from <code>secr.fit</code> regarding <code>bias.D</code>: this function is usually run by <code>secr.fit</code> after any model fit using the ‘buffer’ argument, but it does not handle varying effort.</p>
<p>Usage is hardwired and will be applied whenever a model is fitted. There are two ways to suppress this. The first is to remove the usage attribute (<code>usage(traps(captdata)) &lt;- NULL</code>). The second is to bypass the attribute for a single fit by calling <code>secr.fit</code> with ‘details = list(ignoreusage = TRUE)’.</p>
<p>For a more informative example, we simulate data from an array of binary proximity detectors (such as automatic cameras) operated over 5 occasions, using the default density (5/ha) and detection parameters (g0 = 0.1, sigma = 25 m) in <code>sim.capthist</code>. We choose to expose all detectors twice as long on occasions 2 and 3 as on occasion 1, and three times as long on occasions 4 and 5:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a>simgrid <span class="ot">&lt;-</span> <span class="fu">make.grid</span>(<span class="at">nx =</span> <span class="dv">10</span>, <span class="at">ny =</span> <span class="dv">10</span>, <span class="at">detector =</span> <span class="st">&#39;proximity&#39;</span>)</span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a><span class="fu">usage</span>(simgrid) <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">3</span>), <span class="at">byrow =</span> <span class="cn">TRUE</span>, <span class="at">nrow =</span> <span class="dv">100</span>, </span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a>    <span class="at">ncol =</span> <span class="dv">5</span>)</span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a>simCH <span class="ot">&lt;-</span> <span class="fu">sim.capthist</span>(simgrid, <span class="at">popn =</span> <span class="fu">list</span>(<span class="at">D =</span> <span class="dv">5</span>, <span class="at">buffer =</span> <span class="dv">100</span>), </span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a>    <span class="at">detectpar =</span> <span class="fu">list</span>(<span class="at">g0 =</span> <span class="fl">0.1</span>, <span class="at">sigma =</span> <span class="dv">25</span>), <span class="at">noccasions =</span> <span class="dv">5</span>, </span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a>    <span class="at">seed =</span> <span class="dv">123</span>)</span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a><span class="fu">summary</span>(simCH)</span></code></pre></div>
<pre><code>## Object class       capthist 
## Detector type      proximity (5) 
## Detector number    100 
## Average spacing    20 m 
## x-range            0 180 m 
## y-range            0 180 m 
## 
## Usage range by occasion
##     1 2 3 4 5
## min 1 2 2 3 3
## max 1 2 2 3 3
## 
## Counts by occasion 
##                     1   2   3   4   5 Total
## n                  15  18  23  29  23   108
## u                  15   7   6   7   1    36
## f                   8   6   9   4   9    36
## M(t+1)             15  22  28  35  36    36
## losses              0   0   0   0   0     0
## detections         26  32  39  54  55   206
## detectors visited  24  28  33  41  44   170
## detectors used    100 100 100 100 100   500</code></pre>
<p>Now we fit four models with a half-normal detection function. The firest model (fit.null) has no adjustment because we ignore the usage information. The second (fit.usage) automatically adjusts for effort. The third (fit.tcov1) again ignores effort, but fits a distinct g0 for each level of effort. The fourth (fit.tcov2) uses a numerical covariate equal to the known effort. The setting <code>fastproximity = FALSE</code> allows all models can be compared by AIC.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="co"># shared arguments for model fits 1-4</span></span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>timedf <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">tfactor =</span> <span class="fu">factor</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">3</span>)), <span class="at">tnumeric =</span> </span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a>    <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">3</span>))</span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a>args <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">capthist =</span> simCH, <span class="at">buffer =</span> <span class="dv">100</span>, <span class="at">biasLimit =</span> <span class="cn">NA</span>, </span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a>    <span class="at">timecov =</span> timedf, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a>models <span class="ot">&lt;-</span> <span class="fu">c</span>(g0 <span class="sc">~</span> <span class="dv">1</span>, g0 <span class="sc">~</span> <span class="dv">1</span>, g0 <span class="sc">~</span> tfactor, g0 <span class="sc">~</span> tnumeric)</span>
<span id="cb31-7"><a href="#cb31-7" tabindex="-1"></a>details <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="fu">list</span>(<span class="fu">list</span>(<span class="at">ignoreusage =</span> <span class="cn">TRUE</span>, <span class="at">fastproximity =</span> </span>
<span id="cb31-8"><a href="#cb31-8" tabindex="-1"></a>    <span class="cn">FALSE</span>)), <span class="dv">4</span>)</span>
<span id="cb31-9"><a href="#cb31-9" tabindex="-1"></a>details[[<span class="dv">2</span>]]<span class="sc">$</span>ignoreusage <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb31-10"><a href="#cb31-10" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" tabindex="-1"></a><span class="co"># review arguments</span></span>
<span id="cb31-12"><a href="#cb31-12" tabindex="-1"></a><span class="fu">data.frame</span>(<span class="at">model =</span> <span class="fu">format</span>(models), <span class="at">ignoreusage =</span> <span class="fu">sapply</span>(details,</span>
<span id="cb31-13"><a href="#cb31-13" tabindex="-1"></a>    <span class="st">&#39;[[&#39;</span>, <span class="st">&#39;ignoreusage&#39;</span>))</span></code></pre></div>
<pre><code>##           model ignoreusage
## 1        g0 ~ 1        TRUE
## 2        g0 ~ 1       FALSE
## 3  g0 ~ tfactor        TRUE
## 4 g0 ~ tnumeric        TRUE</code></pre>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a><span class="co"># fit</span></span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a>fits <span class="ot">&lt;-</span> <span class="fu">list.secr.fit</span>(<span class="at">model =</span> models, <span class="at">details =</span> details, <span class="at">constant =</span> </span>
<span id="cb33-3"><a href="#cb33-3" tabindex="-1"></a>    args, <span class="at">names =</span> <span class="fu">c</span>(<span class="st">&#39;null&#39;</span>,<span class="st">&#39;usage&#39;</span>,<span class="st">&#39;tfactor&#39;</span>,<span class="st">&#39;tnumeric&#39;</span>))</span>
<span id="cb33-4"><a href="#cb33-4" tabindex="-1"></a><span class="fu">AIC</span>(fits, <span class="at">criterion =</span> <span class="st">&#39;AIC&#39;</span>)[,<span class="sc">-</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">6</span>)]</span></code></pre></div>
<pre><code>##                            model npar  logLik   dAIC  AICwt
## usage           D~1 g0~1 sigma~1    3 -737.20  0.000 0.4212
## tnumeric D~1 g0~tnumeric sigma~1    4 -736.24  0.072 0.4063
## tfactor   D~1 g0~tfactor sigma~1    5 -736.09  1.785 0.1725
## null            D~1 g0~1 sigma~1    3 -744.90 15.390 0.0000</code></pre>
<p>From the likelihoods we can see that failure to allow for effort (model ‘null’) dramatically reduces model fit. The model with a factor covariate (‘tfactor’) captures the variation in detection probability, but at the cost of fitting two additional parameters. The model with built-in adjustment for effort (‘usage’) has AIC similar to one with effort as a numeric covariate (‘tnumeric’). How do the estimates compare? This is a task for the <code>collate</code> function.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a><span class="fu">collate</span>(fits, <span class="at">newdata =</span> timedf)[,,<span class="st">&#39;estimate&#39;</span>,<span class="st">&#39;g0&#39;</span>]</span></code></pre></div>
<pre><code>##                         null   usage tfactor tnumeric
## tfactor=1,tnumeric=1 0.21001 0.10112 0.13349  0.12551
## tfactor=2,tnumeric=2 0.21001 0.10112 0.18047  0.18851
## tfactor=2,tnumeric=2 0.21001 0.10112 0.18047  0.18851
## tfactor=3,tnumeric=3 0.21001 0.10112 0.27772  0.27324
## tfactor=3,tnumeric=3 0.21001 0.10112 0.27772  0.27324</code></pre>
<p>The ‘null’ model fits a single g0 across all occasions that is approximately twice the true rate on occasion 1 (0.1). The estimates of g0 from ‘tfactor’ and ‘tnumeric’ mirror the variation in effort. The effort-adjusted ‘usage’ model estimates the fundamental rate for one unit of effort (0.1).</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a><span class="fu">collate</span>(fits)[,,,<span class="st">&#39;D&#39;</span>]</span></code></pre></div>
<pre><code>##          estimate SE.estimate    lcl    ucl
## null       4.9709     0.84830 3.5663 6.9287
## usage      4.9755     0.84881 3.5700 6.9344
## tfactor    4.9703     0.84811 3.5660 6.9277
## tnumeric   4.9698     0.84805 3.5656 6.9271</code></pre>
<p>The density estimates themselves are almost entirely unaffected by the choice of model for g0. This is not unusual <span class="citation">(<a href="#ref-Sollmann2024">Rahel Sollmann 2024</a>)</span>. Nevertheless, the example shows how ‘usage’ allows unbalanced data to be analysed with a minimum of fuss.</p>
</div>
<div id="further-notes-on-varying-effort" class="section level3" number="7.3.2">
<h3><span class="header-section-number">7.3.2</span> Further notes on varying effort</h3>
<ol style="list-style-type: decimal">
<li>Adjustment for varying effort will be more critical in analyses where (i) the variation is confounded with temporal (between-session) or spatial variation in density, and (ii) it is important to estimate the temporal or spatial pattern. For example, if detector usage was consistently high in one part of a landscape, while true density was constant, failure to allow for varying usage might produce a spurious density pattern.</li>
<li>The units of usage determine the units of <span class="math inline">\(g_0\)</span> or <span class="math inline">\(\lambda_0\)</span> in the fitted model. This must be considered when choosing starting values for likelihood maximization. Ordinarily one relies on <code>secr.fit</code> to determine starting values automatically (via <code>autoini</code>), and a simple linear adjustment for usage, averaged across non-zero detectors and occasions, is applied to the value of g0 from <code>autoini</code>.</li>
<li>When occasions are collapsed or detectors are lumped with the <code>reduce</code> method for capthist objects, usage is summed for each aggregated unit.</li>
<li>The function <code>usagePlot</code> displays a bubble plot of spatially varying detector usage on one occasion. The arguments ‘markused’ and ‘markvarying’ of <code>plot.traps</code> may also be useful.</li>
<li>Absolute duration does not always equate with effort. Animal activity may be concentrated in part of the day, or older DNA samples from hair snares may fail to amplify <span class="citation">(<a href="#ref-ebm13">Efford, Borchers, and Mowat 2013</a>)</span>.</li>
<li>Binary or count data from searches of polygons or transects <span class="citation">(<a href="#ref-e11">Efford 2011</a>)</span> do not raise any new issues for including effort, at least when effort is homogeneous across each polygon or transect. Effects of varying polygon or transect size are automatically accommodated in the models of Chapter @ref(areasearches). Models for varying effort within polygons or transects have not been needed for problems encountered to date. Such variation might in any case be accommodated by splitting the searched areas or transects into smaller units that were more nearly homogeneous (see the <code>snip</code> function for splitting transects).</li>
</ol>
<!--chapter:end:08-detection-model.Rmd-->
</div>
</div>
</div>
<div id="individual-heterogeneity" class="section level1" number="8">
<h1><span class="header-section-number">8</span> Individual heterogeneity</h1>
<p></p>
<p>In addition to the variation that can be attributed to covariates (e.g., sex) or specific effects (occasion, learned responses etc.) there may be variation in detection parameters among individuals that is unrelated to known predictors. This goes by the name ‘individual heterogeneity’. Unmodelled individual heterogeneity can be a major source of bias in non-spatial capture–recapture estimates of population size <span class="citation">(<a href="#ref-obwa78">Otis et al. 1978</a>)</span>.</p>
<p>It has long been recognised that SECR removes one major source of individual heterogeneity by modelling differential access to detectors. However, each detection parameter (<span class="math inline">\(g_0, \lambda_0, \sigma\)</span>) is potentially heterogeneous and a source of bias in SECR estimates of density.</p>
<p>Individual heterogeneity may be addressed by treating the parameter as a random effect. This entails integrating the likelihood over the hypothesized distribution of the parameter. Results are unavoidably dependent on the choice of distribution. The distribution may be continuous or discrete. Finite mixture models with a small number of latent classes (2 or 3) are a form of random effect that is particularly easy to implement <span class="citation">(<a href="#ref-p2000">Pledger 2000</a>)</span>. Continuous random effects are usually assumed to follow a normal distribution. There are numerical methods for efficient integration of normal random effects, but these have not been implemented in <strong>secr</strong>. Despite its attractive smoothness, a normal distribution lacks some of the statistical flexibility of finite mixtures. For example, the normal distribution has fixed skewness, whereas a 2-class finite mixture allows varying skewness. The <a href="#finite-mixtures">likelihood</a> for finite mixtures is described separately.</p>
<!-- Variation in detection probability among individuals ('individual -->
<!-- heterogeneity') is a persistent problem in capture--recapture studies. -->
<!-- Ideally, such variation is modelled by grouping individuals into -->
<!-- homogeneous classes (males and females) or including continuous -->
<!-- predictors such as body weight. Finite mixture models are an option -->
<!-- when unmodelled heterogeneity remains (Pledger 2000; Borchers and -->
<!-- Efford 2008). The population is assumed to comprise 2 or more latent -->
<!-- classes differing in detection parameters, with an unknown proportion -->
<!-- in each class. The likelihood uses a weighted sum over the classes, where  -->
<!-- the weight(s) (mixing proportion(s)) are parameters to be estimated. -->
<p>Mixture models are prone to fitting problems caused by multimodality of the likelihood. Some comments are offered below, but a fuller investigation is needed.</p>
<p>The distinction between a finite mixture model and one in which the classes of individuals are known is removed in a hybrid (‘hcov’) model documented <a href="#hybrid-mixtures">here</a>.</p>
<div id="finite-mixture-models-in-secr" class="section level2" number="8.1">
<h2><span class="header-section-number">8.1</span> Finite mixture models in <strong>secr</strong></h2>
<p></p>
<p><strong>secr</strong> allows 2- or 3-class finite mixture models for any ‘real’ detection parameter (e.g., g0, lambda0 or sigma of a halfnormal detection function). Consider a simple example in which we specify a 2-class mixture by adding the predictor ‘h2’ to the model formula:</p>
<p>Continuing with the snowshoe hares:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" tabindex="-1"></a>fit.h2 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(hareCH6, <span class="at">model =</span> lambda0<span class="sc">~</span>h2,</span>
<span id="cb39-2"><a href="#cb39-2" tabindex="-1"></a>                   <span class="at">detectfn =</span> <span class="st">&#39;HEX&#39;</span>, <span class="at">buffer =</span> <span class="dv">250</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb39-3"><a href="#cb39-3" tabindex="-1"></a><span class="fu">coef</span>(fit.h2)</span></code></pre></div>
<pre><code>##                  beta   SE.beta       lcl       ucl
## D            0.424403 0.1333710  0.163001  0.685806
## lambda0     -1.760424 0.1916864 -2.136122 -1.384725
## lambda0.h22  2.099946 0.9121633  0.312139  3.887754
## sigma        3.661579 0.0834537  3.498012  3.825145
## pmix.h22    -3.616802 0.9649853 -5.508138 -1.725465</code></pre>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" tabindex="-1"></a><span class="fu">predict</span>(fit.h2)</span></code></pre></div>
<pre><code>## $`session = wickershamunburne, h2 = 1`
##          link  estimate SE.estimate       lcl       ucl
## D         log  1.528678   0.2047913  1.177038  1.985370
## lambda0   log  0.171972   0.0332698  0.118112  0.250393
## sigma     log 38.922740   3.2539123 33.049694 45.839446
## pmix    logit  0.973835   0.0245886  0.848831  0.995963
## 
## $`session = wickershamunburne, h2 = 2`
##          link   estimate SE.estimate         lcl       ucl
## D         log  1.5286780   0.2047913  1.17703790  1.985370
## lambda0   log  1.4042769   1.6945246  0.21906465  9.001880
## sigma     log 38.9227397   3.2539123 33.04969409 45.839446
## pmix    logit  0.0261654   0.0245886  0.00403728  0.151169</code></pre>
<p><code>secr.fit</code> has expanded the model to include an extra ‘real’ parameter ‘pmix’, for the proportions in the respective latent classes. You could specify this yourself as part of the ‘model’ argument, but <code>secr.fit</code> knows to add it.
The link function for ‘pmix’ defaults to ‘mlogit’ (after the mlogit link in MARK), and any attempt to change the link is ignored.</p>
<p>There are two extra ‘beta’ parameters: lambda0.h22, which is the difference in lambda0 between the classes on the link (logit) scale, and pmix.h22, which is the proportion in the second class, also on the logit scale. Fitted (real) parameter values are reported separately for each mixture class (h2 = 1 and h2 = 2). An important point is that exactly the same estimate of total density is reported for both mixture classes; the actual abundance of each class is D <span class="math inline">\(\times\)</span> pmix.</p>
<p>We now shift to a more interesting example based on the Coulombe’s house mouse <em>Mus musculus</em> dataset <span class="citation">(<a href="#ref-obwa78">Otis et al. 1978</a>)</span>.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" tabindex="-1"></a>morning <span class="ot">&lt;-</span> <span class="fu">subset</span>(housemouse, <span class="at">occ =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>))</span>
<span id="cb43-2"><a href="#cb43-2" tabindex="-1"></a>models <span class="ot">&lt;-</span> <span class="fu">list</span>(lambda0<span class="sc">~</span><span class="dv">1</span>, lambda0<span class="sc">~</span>h2, sigma<span class="sc">~</span>h2, <span class="fu">list</span>(lambda0<span class="sc">~</span>h2,</span>
<span id="cb43-3"><a href="#cb43-3" tabindex="-1"></a>    sigma<span class="sc">~</span>h2))</span>
<span id="cb43-4"><a href="#cb43-4" tabindex="-1"></a>args <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">capthist =</span> morning, <span class="at">buffer =</span> <span class="dv">25</span>, <span class="at">detectfn =</span> <span class="st">&#39;HEX&#39;</span>, </span>
<span id="cb43-5"><a href="#cb43-5" tabindex="-1"></a>    <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb43-6"><a href="#cb43-6" tabindex="-1"></a>fits <span class="ot">&lt;-</span> <span class="fu">list.secr.fit</span>(<span class="at">model =</span> models, <span class="at">constant =</span> args, <span class="at">names =</span></span>
<span id="cb43-7"><a href="#cb43-7" tabindex="-1"></a>    <span class="fu">c</span>(<span class="st">&#39;null&#39;</span>, <span class="st">&#39;h2.lambda0&#39;</span>, <span class="st">&#39;h2.sigma&#39;</span>, <span class="st">&#39;h2.lambda0.sigma&#39;</span>)) </span></code></pre></div>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" tabindex="-1"></a><span class="fu">AIC</span>(fits, <span class="at">criterion =</span> <span class="st">&#39;AIC&#39;</span>, <span class="at">sort =</span> <span class="cn">FALSE</span>)[, <span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">7</span>,<span class="dv">8</span>)]</span></code></pre></div>
<pre><code>##                  npar  logLik   dAIC  AICwt
## null                3 -1270.4 33.345 0.0000
## h2.lambda0          5 -1268.2 32.881 0.0000
## h2.sigma            5 -1255.0  6.580 0.0359
## h2.lambda0.sigma    6 -1250.7  0.000 0.9641</code></pre>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a><span class="fu">collate</span>(fits, <span class="at">realnames =</span> <span class="st">&quot;D&quot;</span>)[<span class="dv">1</span>,,,]</span></code></pre></div>
<pre><code>##                  estimate SE.estimate    lcl    ucl
## null               1291.6      110.91 1091.8 1527.8
## h2.lambda0         1312.2      115.63 1104.4 1559.0
## h2.sigma           1319.3      119.30 1105.4 1574.6
## h2.lambda0.sigma   1285.3      121.70 1068.0 1546.8</code></pre>
<p>Although the best mixture model fits substantially better than the null model (<span class="math inline">\(\Delta\)</span>AIC = 33.3), there is only a
2.6% difference in <span class="math inline">\(\hat D\)</span>.
More complex models are allowed. For example, one might, somewhat outlandishly, fit a learned response to capture that differs between two latent classes, while also allowing sigma to differ between classes:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a>model.h2xbh2s <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(morning, <span class="at">model =</span> <span class="fu">list</span>(lambda0<span class="sc">~</span>h2<span class="sc">*</span>bk, </span>
<span id="cb48-2"><a href="#cb48-2" tabindex="-1"></a>    sigma<span class="sc">~</span>h2), <span class="at">buffer =</span> <span class="dv">25</span>, <span class="at">detectfn =</span> <span class="st">&#39;HEX&#39;</span>)</span></code></pre></div>
<div id="number-of-classes" class="section level3" number="8.1.1">
<h3><span class="header-section-number">8.1.1</span> Number of classes</h3>
<p>The theory of finite mixture models in capture–recapture <span class="citation">(<a href="#ref-p2000">Pledger 2000</a>)</span> allows an indefinite number of classes – 2, 3 or perhaps more. Programmatically, the extension to more classes is obvious (e.g., h3 for a 3-class mixture). The appropriate number of latent classes may be determined by comparing AIC for the fitted models<a href="#fn29" class="footnote-ref" id="fnref29"><sup>29</sup></a>.</p>
<p>Looking on the bright side, it is unlikely that you will ever have enough data to support more than 2 classes. For the data in the example above, the 2-class and 3-class models have identical log likelihood to 4 decimal places, while the latter requires 2 extra parameters to be estimated (this is to be expected as the data were simulated from a null model with no heterogeneity).</p>
</div>
<div id="label-switching" class="section level3" number="8.1.2">
<h3><span class="header-section-number">8.1.2</span> Label switching</h3>
<p>It is a quirk of mixture models that the labeling of the latent classes is arbitrary: the first class in one fit may become the second class in another. This is the phenomenon of ‘label switching’ <span class="citation">(<a href="#ref-Stephens2000">Stephens 2000</a>)</span>.</p>
<p>For example, in the house mouse model ‘h2.lambda0’ the first class is initially dominant, but we can switch that by choosing different starting values for the maximization:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" tabindex="-1"></a>args <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">capthist =</span> morning, <span class="at">model =</span> lambda0<span class="sc">~</span>h2, <span class="at">buffer =</span> <span class="dv">25</span>, </span>
<span id="cb49-2"><a href="#cb49-2" tabindex="-1"></a>    <span class="at">detectfn =</span> <span class="st">&#39;HEX&#39;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb49-3"><a href="#cb49-3" tabindex="-1"></a>starts <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="cn">NULL</span>, <span class="fu">c</span>(<span class="dv">7</span>,<span class="dv">2</span>,<span class="fl">1.3</span>,<span class="dv">2</span>,<span class="dv">0</span>))</span>
<span id="cb49-4"><a href="#cb49-4" tabindex="-1"></a>fitsl <span class="ot">&lt;-</span> <span class="fu">list.secr.fit</span>(<span class="at">start =</span> starts, <span class="at">constant =</span> args, </span>
<span id="cb49-5"><a href="#cb49-5" tabindex="-1"></a>    <span class="at">names =</span> <span class="fu">c</span>(<span class="st">&#39;start1&#39;</span>, <span class="st">&#39;start2&#39;</span>))</span>
<span id="cb49-6"><a href="#cb49-6" tabindex="-1"></a><span class="fu">AIC</span>(fitsl, <span class="at">criterion =</span> <span class="st">&#39;AIC&#39;</span>)[,<span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">8</span>)]</span></code></pre></div>
<pre><code>##                  detectfn npar dAIC AICwt
## start1 hazard exponential    5    0   0.5
## start2 hazard exponential    5    0   0.5</code></pre>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" tabindex="-1"></a><span class="fu">round</span>(<span class="fu">collate</span>(fitsl, <span class="at">realnames=</span><span class="st">&#39;pmix&#39;</span>)[<span class="dv">1</span>,,,],<span class="dv">3</span>)</span></code></pre></div>
<pre><code>##        estimate SE.estimate   lcl   ucl
## start1    0.922       0.087 0.528 0.992
## start2    0.078       0.087 0.008 0.473</code></pre>
<p>Class-specific estimates of the detection parameter (here lambda0) are reversed, but estimates of other parameters are unaffected.</p>
</div>
<div id="multimodality" class="section level3" number="8.1.3">
<h3><span class="header-section-number">8.1.3</span> Multimodality</h3>
<p></p>
<p>The likelihood of a finite mixture model may have multiple modes <span class="citation">(<a href="#ref-Brooks1997">Brooks et al. 1997</a>; <a href="#ref-p2000">Pledger 2000</a>)</span>. The risk is ever-present
that the numerical maximization algorithm will get stuck on a local peak, and in this case the estimates are simply wrong<a href="#fn30" class="footnote-ref" id="fnref30"><sup>30</sup></a>. Slight differences in starting values or numerical method may result in
wildly different answers.</p>
<p>The problem has not been explored fully for SECR models, and care is needed. <span class="citation">Pledger (<a href="#ref-p2000">2000</a>)</span> recommended fitting a model with more classes as a check in the non-spatial case, but this is not proven to work with SECR models. It is desirable to try different starting values. This can be done simply using another model fit. For example:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" tabindex="-1"></a>fit.h2<span class="fl">.2</span> <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(hareCH6, <span class="at">model =</span> lambda0<span class="sc">~</span>h2, <span class="at">buffer =</span> <span class="dv">250</span>, </span>
<span id="cb53-2"><a href="#cb53-2" tabindex="-1"></a>    <span class="at">detectfn =</span> <span class="st">&#39;HEX&#39;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>, <span class="at">start =</span> fit.h2)</span></code></pre></div>
<p>A more time consuming, but illuminating, check on a 2-class model is to plot the profile log likelihood for a range of mixture proportions <span class="citation">(<a href="#ref-Brooks1997">Brooks et al. 1997</a>)</span>. We can use the function <code>pmixprofileLL</code> in <strong>secr</strong> to calculate these profile likelihoods. This requires a maximization step for each value of ‘pmix’; multiple cores may be used in parallel to speed up the computation. <code>pmixprofileLL</code> expects the user to identify the coefficient or ‘beta parameter’ corresponding to ‘pmix’ (argument ‘pmi’):</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" tabindex="-1"></a>pmvals <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="fl">0.01</span>,<span class="fl">0.99</span>,<span class="fl">0.01</span>)</span>
<span id="cb54-2"><a href="#cb54-2" tabindex="-1"></a><span class="co"># use a coarse mask to make it faster</span></span>
<span id="cb54-3"><a href="#cb54-3" tabindex="-1"></a>mask <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(<span class="fu">traps</span>(ovenCH[[<span class="dv">1</span>]]), <span class="at">nx =</span> <span class="dv">32</span>, <span class="at">buffer =</span> <span class="dv">200</span>, </span>
<span id="cb54-4"><a href="#cb54-4" tabindex="-1"></a>    <span class="at">type =</span> <span class="st">&quot;trapbuffer&quot;</span>)</span>
<span id="cb54-5"><a href="#cb54-5" tabindex="-1"></a>profileLL <span class="ot">&lt;-</span> <span class="fu">pmixProfileLL</span>(ovenCH[[<span class="dv">1</span>]], <span class="at">model =</span> <span class="fu">list</span>(lambda0<span class="sc">~</span>h2, </span>
<span id="cb54-6"><a href="#cb54-6" tabindex="-1"></a>    sigma<span class="sc">~</span>h2), <span class="at">pmi =</span> <span class="dv">5</span>, <span class="at">detectfn =</span> <span class="st">&#39;HEX&#39;</span>, <span class="at">CL =</span> <span class="cn">TRUE</span>, <span class="at">pmvals =</span> </span>
<span id="cb54-7"><a href="#cb54-7" tabindex="-1"></a>    pmvals, <span class="at">mask =</span> mask, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb54-8"><a href="#cb54-8" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">2</span>))</span>
<span id="cb54-9"><a href="#cb54-9" tabindex="-1"></a><span class="fu">plot</span>(pmvals, profileLL, <span class="at">xlim =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="at">xlab =</span> <span class="st">&#39;Fixed pmix&#39;</span>, </span>
<span id="cb54-10"><a href="#cb54-10" tabindex="-1"></a>     <span class="at">ylab =</span> <span class="st">&#39;Profile log-likelihood&#39;</span>)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/pmixprofile-1.png" alt="Profile log-likelihood for mixing proportion between 0.01 and 0.99 in a 2-class finite mixture model for ovenbird data from 2005" width="480" />
<p class="caption">
(#fig:pmixprofile)Profile log-likelihood for mixing proportion between 0.01 and 0.99 in a 2-class finite mixture model for ovenbird data from 2005
</p>
</div>
<p>Multimodality is likely to show up as multiple rounded peaks in the profile likelihood. Label switching may cause
some ghost reflections about pmix = 0.5 that can be ignored. If multimodality is found one should accept only estimates for which the maximized likelihood matches that from the highest peak. In the ovenbird example, the maximized log likelihood of the fitted h2 model was -163.8 and the estimated mixing proportion was 0.51, so the correct maximum was found.</p>
<p>Maximization algorithms (argument ‘method’ of <code>secr.fit</code>) differ in their tendency to settle on local maxima; ‘Nelder-Mead’ is probably better than the default ‘Newton-Raphson’. Simulated annealing is sometimes advocated, but it is slow and has not been tried with SECR models.</p>
</div>
</div>
<div id="mitigation" class="section level2" number="8.2">
<h2><span class="header-section-number">8.2</span> Mitigating factors</h2>
<p>Heterogeneity may be demonstrably present yet have little effect on density estimates. Bias in density is a non-linear function of the coefficient of variation of <span class="math inline">\(a_i(\theta)\)</span>. For CV <span class="math inline">\(&lt;20\%\)</span> the bias is likely to be negligible <span class="citation">(<a href="#ref-em14">Efford and Mowat 2014</a>)</span>.</p>
<p>Individual variation in <span class="math inline">\(\lambda_0\)</span> and <span class="math inline">\(\sigma\)</span> may be inversely correlated and therefore compensatory, reducing bias in <span class="math inline">\(\hat D\)</span> <span class="citation">(<a href="#ref-em14">Efford and Mowat 2014</a>)</span>. Bias is a function of heterogeneity in the <a href="#esa">effective sampling area</a> <span class="math inline">\(a(\theta)\)</span> which may vary less than each of the components <span class="math inline">\(\lambda_0\)</span> and <span class="math inline">\(\sigma\)</span>.</p>
<p>It can be illuminating to <a href="#parameterizations">re-parameterize</a> the detection model.</p>
</div>
<div id="hybrid-hcov-model" class="section level2" number="8.3">
<h2><span class="header-section-number">8.3</span> Hybrid ‘hcov’ model</h2>
<p></p>
<p>The hybrid mixture model accepts a 2-level categorical (factor) individual covariate for class membership that may be missing (NA) for any fraction of animals. The name of the covariate to use is specified as argument ‘hcov’ in <code>secr.fit</code>. If the covariate is missing for all individuals then a full 2-class finite mixture model will be fitted (i.e. mixture as a random effect). Otherwise, the random effect applies only to the animals of unknown class; others are modelled with detection parameter values appropriate to their known class. If class is known for all individuals the model is equivalent to a covariate (CL = TRUE) or grouped (CL = FALSE) model. When many or all animals are of known class the mixing parameter may be treated as an estimate of population proportions (probability a randomly selected individual belongs to class <span class="math inline">\(u\)</span>). This is obviously useful for estimating sex ratio free of detection bias. See the hcov help page (?hcov) for implementation details, and <a href="#hybrid-mixtures">here</a> for the theory.</p>
<p>The house mouse dataset includes an individual covariate ‘sex’ with 81 females, 78 males and one unknown.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" tabindex="-1"></a>fit.h <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(morning, <span class="at">model =</span> <span class="fu">list</span>(lambda0<span class="sc">~</span>h2, sigma<span class="sc">~</span>h2), </span>
<span id="cb55-2"><a href="#cb55-2" tabindex="-1"></a>    <span class="at">hcov =</span> <span class="st">&#39;sex&#39;</span>, <span class="at">buffer =</span> <span class="dv">25</span>, <span class="at">detectfn =</span> <span class="st">&#39;HEX&#39;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb55-3"><a href="#cb55-3" tabindex="-1"></a><span class="fu">predict</span>(fit.h)</span></code></pre></div>
<pre><code>## $`session = coulombe, h2 = f`
##          link   estimate SE.estimate        lcl        ucl
## D         log 1310.94360  113.457101 1106.75934 1552.79749
## lambda0   log    0.28640    0.041401    0.21605    0.37965
## sigma     log    2.17857    0.153649    1.89763    2.50109
## pmix    logit    0.46346    0.043121    0.38077    0.54822
## 
## $`session = coulombe, h2 = m`
##          link   estimate SE.estimate        lcl        ucl
## D         log 1310.94360  113.457101 1106.75934 1552.79749
## lambda0   log    0.19836    0.035648    0.13986    0.28133
## sigma     log    2.04753    0.173459    1.73479    2.41664
## pmix    logit    0.53654    0.043121    0.45178    0.61923</code></pre>
</div>
<div id="notes" class="section level2" number="8.4">
<h2><span class="header-section-number">8.4</span> Notes</h2>
<p>It’s worth mentioning a perennial issue of interpretation: Do the latent classes in a finite mixture model have biological reality? The answer is ‘Probably not’ (although the hybrid model blurs this issue). Fitting a finite mixture model does not require or imply that there is a matching structure in the population (discrete types of animal). A mixture model is merely a convenient way to capture heterogeneity.</p>
<p>When more than one real parameter is modelled as a mixture, there is an ambiguity: is the population split once into latent classes common to all real parameters, or is the population split separately for each real parameter? The second option would require a distinct level of the mixing parameter for each real parameter. <strong>secr</strong> implements only the ‘common classes’ option, which saves one parameter.</p>
<!--chapter:end:08-finite-mixtures.Rmd-->
</div>
</div>
<div id="Density" class="section level1" number="9">
<h1><span class="header-section-number">9</span> Density model</h1>
<p></p>
<p>Spatially explicit capture–recapture models allow for population density to vary over space <span class="citation">(<a href="#ref-be08">Borchers and Efford 2008</a>)</span>. Density is the intensity of a spatial Poisson process for activity centres. Models for density may include spatial covariates (e.g., vegetation type, elevation) and spatial trend.</p>
<p>In Chapter @ref(Detection) we introduced <a href="#linear-submodels">linear submodels</a> for detection parameters. Here we consider SECR models in which the population density at any point, considered on the link scale, is also a linear function of <span class="math inline">\(K\)</span> covariates<a href="#fn31" class="footnote-ref" id="fnref31"><sup>31</sup></a>. For density this means</p>
<p><span class="math display">\[\begin{equation}
D(\mathbf{x}; \phi) = f^{-1}[\phi_0 + \sum_{k=1}^K c_k(\mathbf{x}) \, \phi_k],
\end{equation}\]</span>
where <span class="math inline">\(c_k(\mathbf{x})\)</span> is the value of the <span class="math inline">\(k\)</span>-th covariate at point <span class="math inline">\(\mathbf{x}\)</span>, <span class="math inline">\(\phi_0\)</span> is the intercept, <span class="math inline">\(\phi_k\)</span> is the coefficient for the <span class="math inline">\(k\)</span>-th covariate, and <span class="math inline">\(f^{-1}\)</span> is the inverse of the link function. Commonly we model the logarithm of density and <span class="math inline">\(f^{-1}\)</span> is the exponential function.</p>
<p>Although <span class="math inline">\(D(\mathbf{x};\phi)\)</span> is often a smooth function, in <strong>secr</strong> we evaluate it only at the fixed points of the habitat mask (Chapter @ref(Habitat)). A mask defines the region of habitat relevant to a particular study: in the simplest case it is a buffered zone inclusive of the detector locations. More complex masks may exclude interior areas of non-habitat or have an irregular outline.</p>
<p>A density model <span class="math inline">\(D(\mathbf{x};\phi)\)</span> is specified in the ‘model’ argument of <code>secr.fit</code><a href="#fn32" class="footnote-ref" id="fnref32"><sup>32</sup></a>. Spatial covariates, if any, are needed for each mask point; they are stored in the ‘covariates’ attribute of the mask. Results from fitting the model (including the estimated coefficients <span class="math inline">\(\phi\)</span>) are saved in an object of class ‘secr’. To visualise a fitted
density model we first evaluate it at each point on a mask with the function <code>predictDsurface</code> to create an object of class ‘Dsurface’. A Dsurface is a mask with added density data, and plotting a Dsurface is like plotting a mask covariate.</p>
<p>To model variation in a density surface we need to maximize the full likelihood. Maximizing the conditional likelihood (conditional on <span class="math inline">\(n\)</span>, the number of observed individuals) is a way to estimate the observation model; to go from there to a Horvitz-Thompson estimate of density we assume that density is homogeneous. Here we are concerned with inhomogeneous models that are all fitted with <code>CL = FALSE</code> in <code>secr.fit</code>.</p>
<table>
<caption>(#tab:Dexamples) Some examples of models for density in <code>secr.fit</code></caption>
<colgroup>
<col width="28%" />
<col width="71%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Formula</th>
<th align="left">Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">D <span class="math inline">\(\sim\)</span> cover</td>
<td align="left">density varies with ‘cover’, a variable in covariates(mask)</td>
</tr>
<tr class="even">
<td align="left">list(D <span class="math inline">\(\sim\)</span> g, g0 <span class="math inline">\(\sim\)</span> g)</td>
<td align="left">both density and g0 differ between groups</td>
</tr>
<tr class="odd">
<td align="left">D <span class="math inline">\(\sim\)</span> session</td>
<td align="left">session-specific density</td>
</tr>
</tbody>
</table>
<div id="brushtail-possum-example" class="section level2" number="9.1">
<h2><span class="header-section-number">9.1</span> Brushtail possum example</h2>
<p></p>
<p>For illustration we use a brushtail possum (<em>Trichosurus vulpecula</em>) dataset from the Orongorongo Valley, New Zealand. Possums were live-trapped in mixed evergreen forest near Wellington for nearly 40 years <span class="citation">(<a href="#ref-ec04">Efford and Cowan 2004</a>)</span>. Single-catch traps were set for 5 consecutive nights, three times a year. The dataset ‘OVpossumCH’ has data from the years 1996 and 1997. The study grid was bounded by a shingle riverbed to the north and west. See ?OVpossum in <strong>secr</strong> for more details.</p>
<p>First we import data for the habitat mask from a polygon shapefile included with the package:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" tabindex="-1"></a><span class="fu">library</span>(secr)</span>
<span id="cb57-2"><a href="#cb57-2" tabindex="-1"></a>datadir <span class="ot">&lt;-</span> <span class="fu">system.file</span>(<span class="st">&quot;extdata&quot;</span>, <span class="at">package =</span> <span class="st">&quot;secr&quot;</span>)</span>
<span id="cb57-3"><a href="#cb57-3" tabindex="-1"></a>OVforest <span class="ot">&lt;-</span> sf<span class="sc">::</span><span class="fu">st_read</span> (<span class="fu">paste0</span>(datadir, <span class="st">&quot;/OVforest.shp&quot;</span>), </span>
<span id="cb57-4"><a href="#cb57-4" tabindex="-1"></a>    <span class="at">quiet =</span> <span class="cn">TRUE</span>)</span>
<span id="cb57-5"><a href="#cb57-5" tabindex="-1"></a><span class="co"># drop points we don&#39;t need</span></span>
<span id="cb57-6"><a href="#cb57-6" tabindex="-1"></a>leftbank <span class="ot">&lt;-</span> <span class="fu">read.table</span>(<span class="fu">paste0</span>(datadir,<span class="st">&quot;/leftbank.txt&quot;</span>))[<span class="dv">21</span><span class="sc">:</span><span class="dv">195</span>,]  </span>
<span id="cb57-7"><a href="#cb57-7" tabindex="-1"></a><span class="fu">options</span>(<span class="at">digits =</span> <span class="dv">6</span>, <span class="at">width =</span> <span class="dv">95</span>)       </span></code></pre></div>
<p>OVforest is now a simple features (sf) object defined in package <strong>sf</strong>. We build a habitat mask object, selecting the first two polygons in OVforest and discarding the third that lies across the river. The attribute table of the shapefile (and hence OVforest) includes a categorical variable ‘forest’ that is either ‘beech’ (<em>Nothofagus</em> spp.) or ‘nonbeech’ (mixed podocarp-hardwood); `addCovariates’ attaches these data to each cell in the mask.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" tabindex="-1"></a>ovtrap <span class="ot">&lt;-</span> <span class="fu">traps</span>(OVpossumCH[[<span class="dv">1</span>]])</span>
<span id="cb58-2"><a href="#cb58-2" tabindex="-1"></a>ovmask <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(ovtrap, <span class="at">buffer =</span> <span class="dv">120</span>, <span class="at">type =</span> <span class="st">&quot;trapbuffer&quot;</span>,</span>
<span id="cb58-3"><a href="#cb58-3" tabindex="-1"></a>    <span class="at">poly =</span> OVforest[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,], <span class="at">spacing =</span> <span class="fl">7.5</span>, <span class="at">keep.poly =</span> <span class="cn">FALSE</span>)</span>
<span id="cb58-4"><a href="#cb58-4" tabindex="-1"></a>ovmask <span class="ot">&lt;-</span> <span class="fu">addCovariates</span>(ovmask, OVforest[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,])</span></code></pre></div>
<p>Plotting is easy:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">2</span>,<span class="dv">8</span>))</span>
<span id="cb59-2"><a href="#cb59-2" tabindex="-1"></a>forestcol <span class="ot">&lt;-</span> <span class="fu">terrain.colors</span>(<span class="dv">6</span>)[<span class="fu">c</span>(<span class="dv">4</span>,<span class="dv">2</span>)]</span>
<span id="cb59-3"><a href="#cb59-3" tabindex="-1"></a><span class="fu">plot</span>(ovmask, <span class="at">cov=</span><span class="st">&quot;forest&quot;</span>, <span class="at">dots =</span> <span class="cn">FALSE</span>, <span class="at">col =</span> forestcol)</span>
<span id="cb59-4"><a href="#cb59-4" tabindex="-1"></a><span class="fu">plot</span>(ovtrap, <span class="at">add =</span> <span class="cn">TRUE</span>)</span>
<span id="cb59-5"><a href="#cb59-5" tabindex="-1"></a><span class="fu">par</span>(<span class="at">cex =</span> <span class="fl">0.8</span>)</span>
<span id="cb59-6"><a href="#cb59-6" tabindex="-1"></a>terra<span class="sc">::</span><span class="fu">sbar</span>(<span class="at">d =</span> <span class="dv">200</span>, <span class="at">xy =</span> <span class="fu">c</span>(<span class="dv">2674670</span>, <span class="dv">5982930</span>), <span class="at">type =</span> <span class="st">&#39;line&#39;</span>, </span>
<span id="cb59-7"><a href="#cb59-7" tabindex="-1"></a>    <span class="at">divs =</span> <span class="dv">2</span>, <span class="at">below =</span> <span class="st">&quot;metres&quot;</span>, <span class="at">labels =</span> <span class="fu">c</span>(<span class="st">&quot;0&quot;</span>,<span class="st">&quot;100&quot;</span>,<span class="st">&quot;200&quot;</span>), </span>
<span id="cb59-8"><a href="#cb59-8" tabindex="-1"></a>    <span class="at">ticks =</span> <span class="dv">10</span>)</span>
<span id="cb59-9"><a href="#cb59-9" tabindex="-1"></a>terra<span class="sc">::</span><span class="fu">north</span>(<span class="at">xy =</span> <span class="fu">c</span>(<span class="dv">2674670</span>, <span class="dv">5982830</span>), <span class="at">d =</span> <span class="dv">40</span>, <span class="at">label =</span> <span class="st">&quot;N&quot;</span>)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/ovmaskplot-1.png" alt="Orongorongo Valley possum study area" width="95%" />
<p class="caption">
(#fig:ovmaskplot)Orongorongo Valley possum study area
</p>
</div>
<p>We fit some simple models to data from February 1996 (session 49). Some warnings
are suppressed for clarity.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" tabindex="-1"></a>args <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">capthist =</span> OVpossumCH[[<span class="dv">1</span>]], <span class="at">mask =</span> ovmask, <span class="at">trace =</span> </span>
<span id="cb60-2"><a href="#cb60-2" tabindex="-1"></a>    <span class="cn">FALSE</span>)</span>
<span id="cb60-3"><a href="#cb60-3" tabindex="-1"></a>models <span class="ot">&lt;-</span> <span class="fu">list</span>(D <span class="sc">~</span> <span class="dv">1</span>, D <span class="sc">~</span> x <span class="sc">+</span> y, D <span class="sc">~</span> x <span class="sc">+</span> y <span class="sc">+</span> x2 <span class="sc">+</span> y2 <span class="sc">+</span> xy, </span>
<span id="cb60-4"><a href="#cb60-4" tabindex="-1"></a>    D <span class="sc">~</span> forest)</span>
<span id="cb60-5"><a href="#cb60-5" tabindex="-1"></a>names <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&#39;null&#39;</span>,<span class="st">&#39;Dxy&#39;</span>,<span class="st">&#39;Dxy2&#39;</span>, <span class="st">&#39;Dforest&#39;</span>)</span>
<span id="cb60-6"><a href="#cb60-6" tabindex="-1"></a>fits <span class="ot">&lt;-</span> <span class="fu">list.secr.fit</span>(<span class="at">model =</span> models, <span class="at">constant =</span> args, </span>
<span id="cb60-7"><a href="#cb60-7" tabindex="-1"></a>    <span class="at">names =</span> names)</span></code></pre></div>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" tabindex="-1"></a><span class="fu">AIC</span>(fits, <span class="at">criterion =</span> <span class="st">&quot;AIC&quot;</span>)[,<span class="sc">-</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">6</span>)]</span></code></pre></div>
<pre><code>##         npar   logLik  dAIC  AICwt
## Dxy2       8 -1549.32 0.000 0.4429
## Dxy        5 -1552.86 1.086 0.2573
## Dforest    4 -1554.15 1.653 0.1938
## null       3 -1555.75 2.860 0.1060</code></pre>
<p>Each of the inhomogeneous models seems marginally better than the null model, but there is little to choose among them.</p>
<p>To visualise the entire surface we compute predicted density at each mask point. For example, we can plot the quadratic surface like this:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">1</span>,<span class="dv">8</span>))</span>
<span id="cb63-2"><a href="#cb63-2" tabindex="-1"></a>surfaceDxy2 <span class="ot">&lt;-</span> <span class="fu">predictDsurface</span>(fits<span class="sc">$</span>Dxy2)</span>
<span id="cb63-3"><a href="#cb63-3" tabindex="-1"></a><span class="fu">plot</span>(surfaceDxy2, <span class="at">plottype =</span> <span class="st">&quot;shaded&quot;</span>, <span class="at">poly =</span> <span class="cn">FALSE</span>, <span class="at">breaks =</span> </span>
<span id="cb63-4"><a href="#cb63-4" tabindex="-1"></a>      <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">22</span>,<span class="dv">2</span>), <span class="at">title =</span> <span class="st">&quot;Density / ha&quot;</span>, <span class="at">text.cex =</span> <span class="dv">1</span>)</span>
<span id="cb63-5"><a href="#cb63-5" tabindex="-1"></a><span class="co"># graphical elements to be added, including contours of Dsurface</span></span>
<span id="cb63-6"><a href="#cb63-6" tabindex="-1"></a><span class="fu">plot</span>(ovtrap, <span class="at">add =</span> <span class="cn">TRUE</span>)</span>
<span id="cb63-7"><a href="#cb63-7" tabindex="-1"></a><span class="fu">plot</span>(surfaceDxy2, <span class="at">plottype =</span> <span class="st">&quot;contour&quot;</span>, <span class="at">poly =</span> <span class="cn">FALSE</span>, <span class="at">breaks =</span> </span>
<span id="cb63-8"><a href="#cb63-8" tabindex="-1"></a>    <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">22</span>,<span class="dv">2</span>), <span class="at">add =</span> <span class="cn">TRUE</span>)</span>
<span id="cb63-9"><a href="#cb63-9" tabindex="-1"></a><span class="fu">lines</span>(leftbank)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/OVsurface-1.png" alt="Quadratic possum density surface" width="95%" />
<p class="caption">
(#fig:OVsurface)Quadratic possum density surface
</p>
</div>
<p>Following sections expand on the options for specifying and displaying density models.</p>
</div>
<div id="using-the-model-argument-in-secr.fit" class="section level2" number="9.2">
<h2><span class="header-section-number">9.2</span> Using the ‘model’ argument in secr.fit</h2>
<p>The model argument of <code>secr.fit</code> is a list of formulae, one for each ‘real’ parameter<a href="#fn33" class="footnote-ref" id="fnref33"><sup>33</sup></a> in both the state model (usually just D for density) and the observation model (typically g0 or lambda0, and sigma). A model formula defines variation in each parameter as a function of covariates (including geographic coordinates and their polynomial terms) that is linear on the ‘link’ scale, as in a generalized linear model.</p>
<p>The options differ between the state and observation models. D may vary with respect to group, session or point in space; g0, lambda0, and sigma may vary by group, session, occasion or latent class (finite mixture), but not with respect to continuous space. This was a choice made in the software design, aiming to tame the complexity that would result if g0 and sigma were allowed to vary continuously in space.</p>
<p>The predictors ‘group’ and ‘session’ behave for D as they do for other real parameters. They determine variation in the expected density for each group or session that is (by default) uniform across space, leading to a homogeneous Poisson model and a flat surface. No further explanation is therefore needed.</p>
<div id="link-function" class="section level3" number="9.2.1">
<h3><span class="header-section-number">9.2.1</span> Link function</h3>
<p></p>
<p>The default link for D is ‘log’. It is equally feasible in most cases to choose ‘identity’ as the link (see the <code>secr.fit</code> argument ‘link’), and for the null model D <span class="math inline">\(\sim\)</span> 1 the estimate will be the same to numerical accuracy, as will estimates involving only categorical variables (e.g., session). However, with an ‘identity’ link the usual (asymptotic) confidence limits will be symmetrical (unless truncated at zero) rather than asymmetrical. In models with continuous predictors, including spatial trend surfaces, the link function will affect the result, although the difference may be small when the amplitude of variation on the surface is small. Otherwise, serious thought is needed regarding which model is biologically more appropriate: logarithmic or linear.</p>
<p>The ‘identity’ link may cause problems when density is very small or very large because, by default, the maximization method assumes all parameters have similar scale (e.g., <code>typsize = c(1,1,1)</code> for default constant models). Setting <code>typsize</code> manually in a call to <code>secr.fit</code> can fix the problem and speed up fitting. For example, if density is around 0.001/ha (10 per 100 km<span class="math inline">\(^2\)</span>) then call <code>secr.fit(..., typsize = c(0.001,1,1))</code> (<code>typsize</code> has one element for each beta parameter). See <a href="#linkappendix">Appendix 2</a> for more on link functions.</p>
<p>You may wonder why <code>secr.fit</code> is ambivalent regarding the link function: link functions have seemed a necessary part of the machinery for capture–recapture modelling since Lebreton et al. (1992). Their key role is to keep the ‘real’ parameter within feasible bounds (e.g., 0-1 for probabilities). In <code>secr.fit</code> any modelled value of D that falls below zero is truncated at zero (of course this condition will not arise with a log link).</p>
</div>
<div id="built-in-variables" class="section level3" number="9.2.2">
<h3><span class="header-section-number">9.2.2</span> Built-in variables</h3>
<p><code>secr.fit</code> automatically recognises the spatial variables x, y, x2, y2 and xy if they appear in the formula for D. These refer to the x-coordinate, y-coordinate, x-coordinate<sup>2</sup> etc. for each mask point, and will be constructed automatically as needed.</p>
<p>The formula for D may also include the non-spatial variables g (group), session (categorical), and Session (continuous), defined as for modelling g0 and sigma in Chapter @ref(Detection).</p>
<p>The built-in variables offer limited model possibilities:</p>
<table>
<thead>
<tr class="header">
<th>Formula</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>D ~ 1</td>
<td>flat surface (default)</td>
</tr>
<tr class="even">
<td>D ~ x + y</td>
<td>linear trend surface (planar)</td>
</tr>
<tr class="odd">
<td>D ~ x + x2</td>
<td>quadratic trend in east-west direction only</td>
</tr>
<tr class="even">
<td>D ~ x + y + x2 + y2 + xy</td>
<td>quadratic trend surface</td>
</tr>
</tbody>
</table>
<!---
% \subsection*{Orthogonal polynomials}
%
% Specifying a quadratic trend surface as in the previous section is
% both ugly and undesirable because the terms (x, x2 etc.) tend to be
% highly correlated. The easy alternative is to specify an orthogonal
% polynomial (OP) with the R function `poly`. Orthogonal polynomials
% are transformations of the original polynomial variables that have the
% property of 'orthogonality'. You don't need to know how to compute
% them - it's automatic. The last three models could better be expressed:
%
% \begin{tabular} { l l}
% D $\sim$ poly(x,y) & OP linear trend surface (planar) \\
% D $\sim$ poly(x,2) & OP quadratic trend in east-west direction only \\
% D $\sim$ poly(x,y, degree = 2) & OP quadratic trend surface \\
% etc. & \\
% \end{tabular}
% (The argument name 'degree' must be spelled out if there is more than
% one predictor).
% Orthogonal polynomials are new in **secr} 2.9.0. Prediction from
% OP models is tricky -- it requires the 'secr' model object to retain
% the details of how the OP were constructed -- but transparent to the
% user.
%
% Polynomial surfaces (OP and otherwise) take a very limited range of
% shapes. They are also prone to extrapolation errors: the predicted
% surface outside the detector array is often unrealistically high or
% low because it is unconstrained by the data.
--->
</div>
<div id="user-provided-variables" class="section level3" number="9.2.3">
<h3><span class="header-section-number">9.2.3</span> User-provided variables</h3>
<p>More interesting models can be made with variables provided by the user. These are stored in a data frame as the ‘covariates’ attribute of a mask object. Covariates must be defined for every point on a mask.</p>
<p>Variables may be categorical (a factor or character value that can be coerced to a factor) or continuous (a numeric vector). The habitat variable ‘habclass’ constructed in the Examples section of the <code>skink</code> help is an example of a two-class categorical covariate. Remember that categorical variables entail one additional
parameter for each extra level.</p>
<p>There are several ways to create or input mask covariates.</p>
<ol style="list-style-type: decimal">
<li><p>Read columns of covariates along with the x- and y-coordinates
when creating a mask from a dataframe or external file
(<code>read.mask</code>)</p></li>
<li><p>Read the covariates dataframe separately from an external file
(<code>read.table</code>)</p></li>
<li><p>Infer covariate values by computation on in existing mask (see below).</p></li>
<li><p>Infer values for points on an existing mask from a GIS data source, such as a polygon shapefile or other spatial data source (see Appendix @ref(Spatialdata)).</p></li>
</ol>
<p>Use the function <code>addCovariates</code> for the third and fourth options.</p>
</div>
<div id="covariates-computed-from-coordinates" class="section level3" number="9.2.4">
<h3><span class="header-section-number">9.2.4</span> Covariates computed from coordinates</h3>
<p>Higher-order polynomial terms may be added as covariates if required. For example,</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" tabindex="-1"></a><span class="fu">covariates</span>(ovmask)[,<span class="st">&quot;x3&quot;</span>] <span class="ot">&lt;-</span> <span class="fu">covariates</span>(ovmask)<span class="sc">$</span>x<span class="sc">^</span><span class="dv">3</span> </span></code></pre></div>
<p>allows a model like D ~ x + x2 + x3.</p>
<p>If you have a strong prior reason to suspect a particular ‘grain’ to the landscape then this may be also be computed as a new, artificial covariate. This code gives a covariate representing a northwest – southeast trend:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" tabindex="-1"></a><span class="fu">covariates</span>(ovmask)[,<span class="st">&quot;NWSE&quot;</span>] <span class="ot">&lt;-</span> ovmask<span class="sc">$</span>y <span class="sc">-</span> ovmask<span class="sc">$</span>x <span class="sc">-</span> </span>
<span id="cb65-2"><a href="#cb65-2" tabindex="-1"></a>    <span class="fu">mean</span>(ovmask<span class="sc">$</span>y <span class="sc">-</span> ovmask<span class="sc">$</span>x)</span></code></pre></div>
<p>Another trick is to compute distances to a mapped landscape feature. For example, possum density in our Orongorongo example may relate to distance from the river; this corresponds roughly to elevation, which we do not have to hand. The <code>distancetotrap</code> function of <strong>secr</strong> computes distances from mask cells to the nearest vertex on the riverbank, which are precise enough for our purpose.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" tabindex="-1"></a><span class="fu">covariates</span>(ovmask)[,<span class="st">&quot;DTR&quot;</span>] <span class="ot">&lt;-</span> <span class="fu">distancetotrap</span>(ovmask, leftbank)</span></code></pre></div>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">1</span>,<span class="dv">8</span>))</span>
<span id="cb67-2"><a href="#cb67-2" tabindex="-1"></a><span class="fu">plot</span>(ovmask, <span class="at">covariate =</span> <span class="st">&quot;DTR&quot;</span>, <span class="at">breaks =</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">500</span>,<span class="dv">50</span>), </span>
<span id="cb67-3"><a href="#cb67-3" tabindex="-1"></a>     <span class="at">title =</span> <span class="st">&quot;Distance to river m&quot;</span>, <span class="at">dots =</span> <span class="cn">FALSE</span>, <span class="at">inset=</span> <span class="fl">0.07</span>)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/dtrplot-1.png" alt="Orongorongo Valley possum study: distance to river" width="80%" />
<p class="caption">
(#fig:dtrplot)Orongorongo Valley possum study: distance to river
</p>
</div>
</div>
<div id="pre-computed-resource-selection-functions" class="section level3" number="9.2.5">
<h3><span class="header-section-number">9.2.5</span> Pre-computed resource selection functions</h3>
<p>A resource selection function (RSF) was defined by <span class="citation">Boyce et al. (<a href="#ref-bvns02">2002</a>)</span> as “any model that yields values proportional to the probability of use of a resource unit”. An RSF combines habitat information from multiple sources in a single variable. Typically the function is estimated from telemetry data on marked individuals, and primarily describes individual-level behaviour <span class="citation">(3rd-order habitat selection of <a href="#ref-j80">Johnson 1980</a>)</span>.</p>
<p>However, the individual-level RSF is also a plausible hypothesis for 2nd-order habitat selection i.e. for modelling the relationship between habitat and population density. Then we interpret the RSF as a single variable that is believed to be proportional to the expected population density in each cell of a habitat mask.</p>
<p>Suppose, for example, in folder datadir we have a polygon shapefile (RSF.shp, RSF.dbf etc.) with the attribute “rsf” defined for each polygon. Given mask and capthist objects “habmask” and “myCH”, this code fits a SECR model that calibrates the RSF in terms of population density:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" tabindex="-1"></a>rsfshape <span class="ot">&lt;-</span> sf<span class="sc">::</span><span class="fu">st_read</span>(<span class="fu">paste0</span>(datadir, <span class="st">&quot;/RSF.shp&quot;</span>))</span>
<span id="cb68-2"><a href="#cb68-2" tabindex="-1"></a>habmask <span class="ot">&lt;-</span> <span class="fu">addCovariates</span>(habmask, rsfshape, <span class="at">columns =</span> <span class="st">&quot;rsf&quot;</span>)</span>
<span id="cb68-3"><a href="#cb68-3" tabindex="-1"></a><span class="fu">secr.fit</span> (myCH, <span class="at">mask =</span> habmask, <span class="at">model =</span> D <span class="sc">~</span> rsf <span class="sc">-</span> <span class="dv">1</span>)</span></code></pre></div>
<ul>
<li>“rsf” must be known for every pixel in the habitat mask</li>
<li>Usually it make sense to fit the density model through the origin (rsf = 0 implies D = 0). This is not true of habitat suitability indices in general.</li>
</ul>
<p>This is a quite different approach to fitting multiple habitat covariates within <strong>secr</strong>, and one that should be considered. There are usually too few individuals in a SECR study to usefully fit models with multiple covariates of density, even given a large dataset such as our possum example. However, 3rd-order and 2nd-order habitat selection are conceptually distinct, and their relationship is an interesting research topic.</p>
</div>
<div id="regression-splines-1" class="section level3" number="9.2.6">
<h3><span class="header-section-number">9.2.6</span> Regression splines</h3>
<p></p>
<p>Regression splines are a flexible alternative to polynomials for spatial trend analysis. Regression splines are familiar as the smooth terms in ‘generalized additive models’ (gams) implemented (differently) in the base R package <strong>gam</strong> and in R package <strong>mgcv</strong> <span class="citation">(<a href="#ref-w06">Wood 2006</a>)</span>.</p>
<p>Some of the possible smooth terms from <strong>mgcv</strong> can be used in model formulae for <code>secr.fit</code> – see the help page for ‘smooths’ in <strong>secr</strong>. Smooths are specified with terms that look like calls to the functions <code>s</code> and <code>te</code>. Smoothness is determined by the number of knots which is set by the user via the argument ‘k’. The number of knots cannot be determined automatically by the penalty algorithms of <strong>mgcv</strong>.</p>
<p>Here we fit a regression spline with the same number of parameters as a quadratic polynomial, a linear effect of the ‘distance to river’ covariate on log(D), and a nonlinear smooth.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" tabindex="-1"></a>args <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">capthist =</span> OVpossumCH[[<span class="dv">1</span>]], <span class="at">mask =</span> ovmask, <span class="at">trace =</span> </span>
<span id="cb69-2"><a href="#cb69-2" tabindex="-1"></a>    <span class="cn">FALSE</span>)</span>
<span id="cb69-3"><a href="#cb69-3" tabindex="-1"></a>models <span class="ot">&lt;-</span> <span class="fu">list</span>(D <span class="sc">~</span> <span class="fu">s</span>(x,y, <span class="at">k =</span> <span class="dv">6</span>), D <span class="sc">~</span> DTR, D <span class="sc">~</span> <span class="fu">s</span>(DTR, <span class="at">k =</span> <span class="dv">3</span>))</span>
<span id="cb69-4"><a href="#cb69-4" tabindex="-1"></a>RSfits <span class="ot">&lt;-</span> <span class="fu">list.secr.fit</span>(<span class="at">model =</span> models, <span class="at">constant =</span> args, </span>
<span id="cb69-5"><a href="#cb69-5" tabindex="-1"></a>    <span class="at">prefix =</span> <span class="st">&quot;RS&quot;</span>)</span></code></pre></div>
<p>Now add these to the AIC table and plot the ‘AIC-best’ model:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" tabindex="-1"></a><span class="fu">AIC</span>(<span class="fu">c</span>(fits, RSfits), <span class="at">criterion =</span> <span class="st">&quot;AIC&quot;</span>)[,<span class="sc">-</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">6</span>)]</span></code></pre></div>
<pre><code>##         npar   logLik  dAIC  AICwt
## RS3        5 -1552.00 0.000 0.2667
## Dxy2       8 -1549.32 0.628 0.1948
## RS2        4 -1553.36 0.705 0.1875
## Dxy        5 -1552.86 1.714 0.1132
## RS1        8 -1549.93 1.847 0.1059
## Dforest    4 -1554.15 2.281 0.0853
## null       3 -1555.75 3.488 0.0466</code></pre>
<p>(ref:OVdtrcap) Possum density vs distance to river: regression spline <em>k</em> = 3.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" tabindex="-1"></a>newdat <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">DTR =</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">400</span>,<span class="dv">5</span>))</span>
<span id="cb72-2"><a href="#cb72-2" tabindex="-1"></a>tmp <span class="ot">&lt;-</span> <span class="fu">predict</span>(RSfits<span class="sc">$</span>RS3, <span class="at">newdata =</span> newdat)</span>
<span id="cb72-3"><a href="#cb72-3" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar=</span><span class="fu">c</span>(<span class="dv">5</span>,<span class="dv">8</span>,<span class="dv">2</span>,<span class="dv">4</span>), <span class="at">pty =</span> <span class="st">&quot;s&quot;</span>)</span>
<span id="cb72-4"><a href="#cb72-4" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">400</span>,<span class="dv">5</span>), <span class="fu">sapply</span>(tmp, <span class="st">&quot;[&quot;</span>, <span class="st">&quot;D&quot;</span>,<span class="st">&quot;estimate&quot;</span>), </span>
<span id="cb72-5"><a href="#cb72-5" tabindex="-1"></a>    <span class="at">ylim =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">20</span>), <span class="at">xlab =</span> <span class="st">&quot;Distance from river (m)&quot;</span>, </span>
<span id="cb72-6"><a href="#cb72-6" tabindex="-1"></a>    <span class="at">ylab =</span> <span class="st">&quot;Density / ha&quot;</span>, <span class="at">type =</span> <span class="st">&quot;l&quot;</span>)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/OVdtr-1.png" alt="(ref:OVdtrcap)" width="75%" />
<p class="caption">
(#fig:OVdtr)(ref:OVdtrcap)
</p>
</div>
Confidence intervals are computed in <code>predictDsurface</code> by back-transforming <span class="math inline">\(\pm\)</span> 2SE from the link (log) scale:
<div class="figure">
<img src="SECRbook_files/figure-html/CIplot-1.png" alt="Confidence surfaces" width="95%" />
<p class="caption">
(#fig:CIplot)Confidence surfaces
</p>
</div>
<!---
strip.legend(c(2674460, 5982886), legend = seq(0,22,2), col = terrain.colors(11), title="Density / ha" , text.cex = 1)
--->
<p>Multiple predictors may be included in one ‘s’ smooth term, implying interaction. This assumes isotropy – equality of scales on the different predictors – which is appropriate for geographic coordinates such as x and y in this example. In other cases, predictors may be measured on different scales (e.g., structural complexity of vegetation and elevation) and isotropy cannot be assumed. In these cases a tensor-product smooth (<code>te</code>) is appropriate because it is scale-invariant. For <code>te</code>, ‘k’ represents the order of the smooth on each axis, and we must fix the number of knots with ‘fx = TRUE’ to override automatic selection.</p>
<p>For more on the use of regression splines see the documentation for <strong>mgcv</strong>, the <strong>secr</strong> help page `?smooths’, <span class="citation">Wood (<a href="#ref-w06">2006</a>)</span>, and <span class="citation">Borchers and Kidney (<a href="#ref-bk14">2014</a>)</span>.</p>
</div>
</div>
<div id="prediction-and-plotting" class="section level2" number="9.3">
<h2><span class="header-section-number">9.3</span> Prediction and plotting</h2>
<p>
</p>
<p>Fitting a model provides estimates of its coefficients or ‘beta parameters’; use the <code>coef</code> method to extract these from an secr object. The coefficients are usually of little use in themselves, but we can use them to make predictions. In order to plot a fitted model we first predict the height of the density surface at each point on a mask. As we have seen, this is done with <code>predictDsurface</code>, which has arguments <code>(object, mask = NULL, se.D = FALSE, cl.D = FALSE, alpha = 0.05)</code>. By default, prediction is at the mask points used when fitting the model (i.e. object$mask); specify the mask argument to extrapolate the model to a different area.</p>
<p>The output from <code>predictDsurface</code> is a specialised mask object called a Dsurface (class “c(‘Dsurface’, ‘mask’, ‘data.frame’)”). The covariate dataframe of a Dsurface has columns for the predicted density of each group (D.0 if there is only one). Usually when you print a mask you see only the x- and y-coordinates. The <code>print</code> method for Dsurface objects displays both the coordinates and the density values as one dataframe, as also do the <code>head</code> and <code>tail</code> methods.</p>
<p>Use the arguments ‘se.D’ and ‘cl.D’ to request computation of the estimated standard error and/or upper and lower confidence limits for each mask point<a href="#fn34" class="footnote-ref" id="fnref34"><sup>34</sup></a>. If requested, values are saved as additional covariates of the output Dsurface (SE.0, lcl.0, and ucl.0 if there is only one group).</p>
<p>The plot method for a Dsurface object has arguments <code>(x, covariate = "D", group = NULL, plottype = "shaded", scale = 1, ...)</code>. <code>covariate</code> may either be a prefix (one of “D”, “SE”, “lcl”, “ucl”) or any full covariate name. ‘plottype’ may be one of “shaded”, “dots”, “persp”, or “contour”. A coloured legend is displayed centre-right (see ?plot.mask and ?strip.legend for options).</p>
<p>For details on how to specify colours, levels etc. read the help pages for <code>plot.mask</code>, <code>contour</code> and <code>persp</code> (these functions may be controlled by extra arguments to <code>plot.Dsurface</code>, using the ‘dots’ convention).</p>
<p>A plot may be enhanced by the addition of contours. This is a challenge, because the <code>contour</code> function in R requires a rectangular matrix of values, and our mask is not rectangular. We could make it so with the <strong>secr</strong> function <code>rectangularMask</code>, which makes a rectangular Dsurface with missing (NA) values of density at all the external points. <code>plot.Dsurface</code> recognises an irregular mask and attempts to fix this with an internal call to <code>rectangularMask</code>.</p>
</div>
<div id="scaling" class="section level2" number="9.4">
<h2><span class="header-section-number">9.4</span> Scaling</h2>
<p>So far we have ignored the scaling of covariates, including geographic coordinates.</p>
<p><code>secr.fit</code> scales the x- and y-coordinates of mask points to mean = 0, SD = 1 before using the coordinates in a model. Remember this when you come to use the coefficients of a density model. Functions such as <code>predictDsurface</code> take care of scaling automatically. <code>predict.secr</code> uses the scaled values (‘newdata’ x = 0, y = 0), which provides the predicted density at the mask centroid. The mean and SD used in scaling are those saved as the `meanSD’ attribute of a mask (dataframe with columns ‘x’ and ‘y’ and rows ‘mean’ and ‘SD’).</p>
<p>Scaling of covariates other than x and y is up to the user. It is not usually needed.</p>
<p>The numerical algorithms for maximizing the likelihood work best when the absolute expected values are roughly similar for all parameters on their respective ‘link’ scales (i.e. all beta parameters) rather than varying by orders of magnitude. The default link function for D and sigma (log) places the values of these parameters on a scale that is not wildly different to the variation in g0 or lambda0, so this is seldom an issue. In extreme cases you may want to make allowance by setting the <code>typsize</code> argument of <code>nlm</code> or the <code>parscale</code> control argument of <code>optim</code> (via the … argument of <code>secr.fit</code>).</p>
<p>Scaling is not performed routinely by <code>secr.fit</code> for distance calculations. Sometimes, large numeric values in coordinates can cause loss of precision in distance calculations (there are a lot of them at each likelihood evaluation). The problem is serious in datasets that combine large coordinates with small detector spacing, such as the Lake Station <code>skink</code> dataset. Set <code>details = list(centred = TRUE)</code> to force scaling; this may become the default setting in a future version of <strong>secr</strong>.</p>
</div>
<div id="potential-problems" class="section level2" number="9.5">
<h2><span class="header-section-number">9.5</span> Potential problems</h2>
<p></p>
<p>Modelling density surfaces can be tricky. Recognise when model fitting has failed. If there is no asymptotic variance-covariance matrix, the estimates cannot be trusted. Some forensic work may be needed. If in doubt, try repeating the fit, perhaps starting from the previously fitted values (you can use <code>secr.fit(..., start = last.model)</code> where <code>last.model</code> is a previously fitted secr object) or from new arbitrary values. Problems may result when the discretization is too coarse, so try with smaller mask cells.</p>
<p>You can try another optimization method; <code>method = "Nelder-Mead"</code> is generally more robust than the default gradient-based method. Any method may fail to find the true maximum from a given starting point. We have no experience with simulated annealing (‘SANN’ in <code>optim</code>); it is reputedly effective, but slow. In the <code>optim</code> help it is stated ominously that “the ‘SANN’ method depends critically on the settings of the control parameters. It is not a general-purpose method”.</p>
<p>Avoid using ‘[’ to extract subsets from mask, capthist and other secr objects. Use the provided <code>subset</code> methods. It is generally safe to use ‘[[’ to extract one session from a multi-session object, as in our possum example, but this is not guaranteed. With care, it is also possible to replace selected elements in situ, but note that any change in coordinates will require the attribute ‘meanSD’ to be recalculated (see <code>?getMeanSD</code>).</p>
<p>Do you really want to model density on the log scale? If not, change the link.</p>
</div>
<div id="this-is-not-a-density-surface" class="section level2" number="9.6">
<h2><span class="header-section-number">9.6</span> This is not a density surface</h2>
<p></p>
<p>The surfaces we have fitted involve inhomogeneous Poisson models for the distribution of animal home range centres. The models have parameters that determine the relationship of expected density to location or to habitat covariates.</p>
<p>Another type of plot is sometimes presented and described as a ‘density surface’ – the summed posterior distribution of estimated range centres from a Bayesian fit of a homogeneous Poisson model. A directly analogous plot may be obtained from the <strong>secr</strong> function <code>fx.total</code> (see also <span class="citation">Borchers and Efford (<a href="#ref-be08">2008</a>)</span> Section 4.3). The contours associated with the home range centre of each detected individual essentially represent 2-D confidence intervals for its home range centre, given the fitted observation model. Summing these gives a summed probability density surface for the centres of the observed individuals (‘D.fx’), and to this we can add an equivalent scaled probability density surface for the individuals that escaped detection (‘D.nc’). Both components are reported by <code>fx.total</code>, along with their sum (‘D.sum’) which we plot here for the flat possum model:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" tabindex="-1"></a>fxsurface <span class="ot">&lt;-</span> <span class="fu">fx.total</span>(fits<span class="sc">$</span>null)</span></code></pre></div>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">1</span>,<span class="dv">8</span>))</span>
<span id="cb74-2"><a href="#cb74-2" tabindex="-1"></a><span class="fu">plot</span>(fxsurface, <span class="at">covariate =</span> <span class="st">&quot;D.sum&quot;</span>, <span class="at">breaks =</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">30</span>,<span class="dv">2</span>), </span>
<span id="cb74-3"><a href="#cb74-3" tabindex="-1"></a>     <span class="at">poly =</span> <span class="cn">FALSE</span>)</span>
<span id="cb74-4"><a href="#cb74-4" tabindex="-1"></a><span class="fu">plot</span>(ovtrap, <span class="at">add =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/OVfxsurfaceplt-1.png" alt="Total fx surface" width="95%" />
<p class="caption">
(#fig:OVfxsurfaceplt)Total fx surface
</p>
</div>
<p>The plot concerns only one realisation from the underlying Poisson model. It visually invites us to interpret patterns in that realisation that we have not modelled. There are serious problems with the interpretation of such plots as ‘density surfaces’:</p>
<ul>
<li><p>attention is focussed on the individuals that were detected; others that were present but not detected are represented by a smoothly varying base level that dominates in the outer region of the plot (contrast this figure with the previous quadratic and DTR3 models).</p></li>
<li><p>the surface depends on sampling intensity, and as more data are added it will change shape systematically. Ultimately, the surface near the centre of a detector array becomes a set of spikes on a barren plain</p></li>
<li><p>the ‘summed confidence interval’ plot is easily confused with the 2-D surface obtained by summing utilisation distributions across animals</p></li>
<li><p>confidence intervals are not available for the height of the probability density surface.</p></li>
</ul>
<p>The plots are also prone to artefacts. In some examples we see concentric clustering of estimated centres around the trapping grids, apparently ‘repelled’ from the traps themselves (e.g., plot below for a null model of the Waitarere ‘possumCH’ dataset in <strong>secr</strong>). This phenomenon appears to relate to lack of model fit (unpubl. results).</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1" tabindex="-1"></a>fxsurfaceW <span class="ot">&lt;-</span> <span class="fu">fx.total</span>(possum.model<span class="fl">.0</span>)</span></code></pre></div>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">8</span>))</span>
<span id="cb76-2"><a href="#cb76-2" tabindex="-1"></a><span class="fu">plot</span>(fxsurfaceW, <span class="at">covariate =</span> <span class="st">&quot;D.sum&quot;</span>, <span class="at">breaks =</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">5</span>,<span class="fl">0.5</span>), </span>
<span id="cb76-3"><a href="#cb76-3" tabindex="-1"></a>     <span class="at">poly =</span> <span class="cn">FALSE</span>)</span>
<span id="cb76-4"><a href="#cb76-4" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">traps</span>(possumCH), <span class="at">add =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/fxsurfaceWplt-1.png" alt="Waitarere possum fx surface" width="95%" />
<p class="caption">
(#fig:fxsurfaceWplt)Waitarere possum fx surface
</p>
</div>
<p>See <span class="citation">Durbach et al. (<a href="#ref-Durbach2024">2024</a>)</span> for further critique.</p>
</div>
<div id="relativedensity2" class="section level2" number="9.7">
<h2><span class="header-section-number">9.7</span> Relative density</h2>
<p></p>
<p>In rare cases it is useful to model the relative density of tagged animals. This is the best that can be done with data for which the tagged sample was not collected in a way that allows the initial detections to be modelled spatially. One scenario involves acoustic telemetry or other automated detection for which the only animals at risk of detection are those previously marked (cf resighting data, in which unmarked animals are detected and counted, but not identified).</p>
<p>The theory for relative density models was given <a href="#relativedensity1">earlier</a>. A spatial model for relative density is fitted in <strong>secr</strong> by setting <code>details = list(relativeD = TRUE)</code> in the call to <code>secr.fit</code> (<strong>secr</strong> <span class="math inline">\(\ge\)</span> 4.6.5). For example</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1" tabindex="-1"></a><span class="co"># relative density fit, assuming uniform probability of tagging</span></span>
<span id="cb77-2"><a href="#cb77-2" tabindex="-1"></a>fitrd1 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(<span class="at">capthist =</span> OVpossumCH[[<span class="dv">1</span>]], <span class="at">mask =</span> ovmask, </span>
<span id="cb77-3"><a href="#cb77-3" tabindex="-1"></a>    <span class="at">trace =</span> <span class="cn">FALSE</span>, <span class="at">model =</span> D <span class="sc">~</span> <span class="fu">s</span>(DTR, <span class="at">k=</span><span class="dv">3</span>), <span class="at">details =</span> </span>
<span id="cb77-4"><a href="#cb77-4" tabindex="-1"></a>    <span class="fu">list</span>(<span class="at">relativeD =</span> <span class="cn">TRUE</span>))</span>
<span id="cb77-5"><a href="#cb77-5" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">predictDsurface</span>(fitrd1), <span class="at">title =</span> <span class="st">&#39;Naive relative D&#39;</span>)</span>
<span id="cb77-6"><a href="#cb77-6" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">traps</span>(OVpossumCH[[<span class="dv">1</span>]]), <span class="at">add =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/relativeD-1.png" alt="Orongorongo Valley relative density" width="576" />
<p class="caption">
(#fig:relativeD)Orongorongo Valley relative density
</p>
</div>
<p>This surface combines the population density and the probability that an animal was captured at least once, which varies spatially and is therefore confounded with relative population density. Densities are given relative to the intercept of the density model (assigned the arbitrary value 1.0). Absolute densities are not available because the model is fitted by
maximizing the likelihood conditional on <span class="math inline">\(n\)</span>. The relative model has one fewer coefficients than the absolute density model.</p>
<p>A better predictor of the relative density of tagged animals is an approximation to the probability of detection, computed as a mask covariate. We invert the covariate so that the intercept corresponds to the (approximate) maximum relative density.</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" tabindex="-1"></a><span class="co"># detection covariate using ballpark detection parameters</span></span>
<span id="cb78-2"><a href="#cb78-2" tabindex="-1"></a><span class="fu">covariates</span>(ovmask)<span class="sc">$</span>pd <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">-</span><span class="fu">pdot</span>(ovmask, <span class="fu">traps</span>(OVpossumCH[[<span class="dv">1</span>]]), </span>
<span id="cb78-3"><a href="#cb78-3" tabindex="-1"></a>       <span class="at">detectpar =</span> <span class="fu">list</span>(<span class="at">g0 =</span> <span class="fl">0.0974198</span>, <span class="at">sigma =</span> <span class="fl">27.6354961</span>), </span>
<span id="cb78-4"><a href="#cb78-4" tabindex="-1"></a>       <span class="at">noccasions =</span> <span class="dv">5</span>)  </span>
<span id="cb78-5"><a href="#cb78-5" tabindex="-1"></a><span class="co"># fit relative density model with new predictor...</span></span>
<span id="cb78-6"><a href="#cb78-6" tabindex="-1"></a>fitrd2 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(<span class="at">capthist =</span> OVpossumCH[[<span class="dv">1</span>]], <span class="at">mask =</span> ovmask, </span>
<span id="cb78-7"><a href="#cb78-7" tabindex="-1"></a>    <span class="at">trace =</span> <span class="cn">FALSE</span>, <span class="at">model =</span> D <span class="sc">~</span> pd, <span class="at">details =</span> </span>
<span id="cb78-8"><a href="#cb78-8" tabindex="-1"></a>    <span class="fu">list</span>(<span class="at">relativeD =</span> <span class="cn">TRUE</span>))</span>
<span id="cb78-9"><a href="#cb78-9" tabindex="-1"></a><span class="co"># ...and with both predictors</span></span>
<span id="cb78-10"><a href="#cb78-10" tabindex="-1"></a>fitrd3 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(<span class="at">capthist =</span> OVpossumCH[[<span class="dv">1</span>]], <span class="at">mask =</span> ovmask, </span>
<span id="cb78-11"><a href="#cb78-11" tabindex="-1"></a>    <span class="at">trace =</span> <span class="cn">FALSE</span>, <span class="at">model =</span> D <span class="sc">~</span> pd <span class="sc">+</span> <span class="fu">s</span>(DTR,<span class="at">k=</span><span class="dv">3</span>), </span>
<span id="cb78-12"><a href="#cb78-12" tabindex="-1"></a>    <span class="at">details =</span> <span class="fu">list</span>(<span class="at">relativeD =</span> <span class="cn">TRUE</span>))</span></code></pre></div>
<div class="sourceCode" id="cb79"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1" tabindex="-1"></a><span class="co"># compare and plot</span></span>
<span id="cb79-2"><a href="#cb79-2" tabindex="-1"></a><span class="fu">AIC</span>(fitrd1, fitrd2, fitrd3, <span class="at">criterion =</span> <span class="st">&#39;AIC&#39;</span>)[,<span class="sc">-</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">6</span>)]</span></code></pre></div>
<pre><code>##                                    model npar   logLik    dAIC  AICwt
## fitrd3 D~pd + s(DTR, k = 3) g0~1 sigma~1    5 -1576.18   0.000 0.7973
## fitrd2                 D~pd g0~1 sigma~1    3 -1579.55   2.739 0.2027
## fitrd1      D~s(DTR, k = 3) g0~1 sigma~1    4 -1642.90 131.449 0.0000</code></pre>
<div class="sourceCode" id="cb81"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">predictDsurface</span>(fitrd3), <span class="at">title =</span> <span class="st">&#39;Relative D, tagged&#39;</span>)</span>
<span id="cb81-2"><a href="#cb81-2" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">traps</span>(OVpossumCH[[<span class="dv">1</span>]]), <span class="at">add =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/relativeD3-1.png" alt="Orongorongo Valley relative density of tagged possums" width="95%" />
<p class="caption">
(#fig:relativeD3)Orongorongo Valley relative density of tagged possums
</p>
</div>
<!-- An alternative is to feed the likelihood a pre-calculated probability of detection, coincidentally available as the mask covariate 'pd'.  -->
<!-- ```{r relativeD4} -->
<!-- fit4 <- secr.fit(capthist = OVpossumCH[[1]], mask = ovmask, trace = FALSE, -->
<!--          model = D ~ DTR, details = list(externalpdot = 'pd')) -->
<!-- coef(fit4) -->
<!-- ``` -->
</div>
<div id="userfnappendix" class="section level2" number="9.8">
<h2><span class="header-section-number">9.8</span> Appendix 1. User-provided model functions</h2>
<p>Some density models cannot be coded in the generalized linear model form of the model argument. To alleviate this problem, a model may be specified as an R function that is passed to <code>secr.fit</code>, specifically as the component ‘userDfn’ of the list argument ‘details’. We document this feature here, although you may never use it.</p>
<p>The userDfn function must follow some rules.</p>
<ul>
<li><p>It should accept four arguments, the first a vector of parameter
values or a character value (below), and the second a ‘mask’ object, a
data frame of x and y coordinates for points at which density must
be predicted.</p>
<table>
<colgroup>
<col width="42%" />
<col width="57%" />
</colgroup>
<thead>
<tr class="header">
<th>Argument</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Dbeta</td>
<td>coefficients of density model, or one of c(‘name’, ‘parameters’)</td>
</tr>
<tr class="even">
<td>mask</td>
<td>habitat mask object</td>
</tr>
<tr class="odd">
<td>ngroup</td>
<td>number of groups</td>
</tr>
<tr class="even">
<td>nsession</td>
<td>number of sessions</td>
</tr>
</tbody>
</table></li>
<li><p>When called with <code>Dbeta = "name"</code>, the function should return a character string to identify the density model in
output. (This should not depend on the values of other arguments).</p></li>
<li><p>When called with <code>Dbeta = 'parameters'</code>, the function should return a character vector naming each parameter. (When used this way, the call always includes the <code>mask</code> argument, so information regarding the model may be retrieved from any attributes of <code>mask</code> that have been set by the user).</p></li>
<li><p>Otherwise, the function should return a numeric array with <code>dim = c(nmask, ngroup, nsession)</code> where nmask is the number of points (rows in mask). Each element in the array is the predicted density (natural scale, in animals / hectare) for each point, group and session. This is simpler than it sounds, as usually there will be a single session and single group.</p></li>
</ul>
<p>The coefficients form the density part of the full vector of beta coefficients used by the likelihood maximization function (<code>nlm</code> or <code>optim</code>). Ideally, the first one should correspond to an intercept or overall density, as this is what appears in the output of <code>predict.secr</code>. If transformation of density to the `link’ scale is required then it should be
hard-coded in userDfn.</p>
<p>Covariates are available to user-provided functions, but within the function they must be extracted ‘manually’ (e.g., <code>covariates(mask)$habclass</code> rather than just ‘habclass’). To pass other arguments (e.g., a basis for splines),
add attribute(s) to the mask.</p>
<p>It will usually be necessary to specify starting values for optimisation manually with the start argument of <code>secr.fit</code>.</p>
<p>If the parameter values in <code>Dbeta</code> are invalid the function should return an array of all zero values.</p>
<p>Here is a ‘null’ userDfn that emulates D <span class="math inline">\(\sim\)</span> 1 with log link</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1" tabindex="-1"></a>userDfn0 <span class="ot">&lt;-</span> <span class="cf">function</span> (Dbeta, mask, ngroup, nsession) {</span>
<span id="cb82-2"><a href="#cb82-2" tabindex="-1"></a>    <span class="cf">if</span> (Dbeta[<span class="dv">1</span>] <span class="sc">==</span> <span class="st">&quot;name&quot;</span>) <span class="fu">return</span> (<span class="st">&quot;0&quot;</span>)</span>
<span id="cb82-3"><a href="#cb82-3" tabindex="-1"></a>    <span class="cf">if</span> (Dbeta[<span class="dv">1</span>] <span class="sc">==</span> <span class="st">&quot;parameters&quot;</span>) <span class="fu">return</span> (<span class="st">&quot;intercept&quot;</span>)</span>
<span id="cb82-4"><a href="#cb82-4" tabindex="-1"></a>    D <span class="ot">&lt;-</span> <span class="fu">exp</span>(Dbeta[<span class="dv">1</span>])   <span class="co"># constant for all points</span></span>
<span id="cb82-5"><a href="#cb82-5" tabindex="-1"></a>    tempD <span class="ot">&lt;-</span> <span class="fu">array</span>(D, <span class="at">dim =</span> <span class="fu">c</span>(<span class="fu">nrow</span>(mask), ngroup, nsession))</span>
<span id="cb82-6"><a href="#cb82-6" tabindex="-1"></a>    <span class="fu">return</span>(tempD)</span>
<span id="cb82-7"><a href="#cb82-7" tabindex="-1"></a>}</span></code></pre></div>
<p>We can compare the result using userDfn0 to a fit of the same model using the ‘model’ argument. Note how the model description combines ‘user.’ and the name ‘0’.</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb83-1"><a href="#cb83-1" tabindex="-1"></a>model<span class="fl">.0</span> <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(captdata, <span class="at">model =</span> D <span class="sc">~</span> <span class="dv">1</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb83-2"><a href="#cb83-2" tabindex="-1"></a>userDfn<span class="fl">.0</span> <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(captdata, <span class="at">details =</span> <span class="fu">list</span>(<span class="at">userDfn =</span> </span>
<span id="cb83-3"><a href="#cb83-3" tabindex="-1"></a>    userDfn0), <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb83-4"><a href="#cb83-4" tabindex="-1"></a><span class="fu">AIC</span>(model<span class="fl">.0</span>, userDfn<span class="fl">.0</span>)[,<span class="sc">-</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">6</span>)]</span></code></pre></div>
<pre><code>##                            model npar   logLik dAICc AICcwt
## model.0         D~1 g0~1 sigma~1    3 -756.909     0    0.5
## userDfn.0 D~userD.0 g0~1 sigma~1    3 -756.909     0    0.5</code></pre>
<div class="sourceCode" id="cb85"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb85-1"><a href="#cb85-1" tabindex="-1"></a><span class="fu">predict</span>(model<span class="fl">.0</span>)</span></code></pre></div>
<pre><code>##        link  estimate SE.estimate       lcl      ucl
## D       log  5.473467   0.6459913  4.346593  6.89249
## g0    logit  0.274725   0.0271644  0.224787  0.33102
## sigma   log 29.396682   1.3084213 26.942060 32.07494</code></pre>
<div class="sourceCode" id="cb87"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1" tabindex="-1"></a><span class="fu">predict</span>(userDfn<span class="fl">.0</span>)</span></code></pre></div>
<pre><code>##        link  estimate SE.estimate       lcl       ucl
## D       log  5.473472   0.6459916  4.346597  6.892494
## g0    logit  0.274725   0.0271644  0.224787  0.331021
## sigma   log 29.396679   1.3084211 26.942058 32.074935</code></pre>
<p>Not very exciting, maybe, but reassuring!</p>
<p>Now let’s try a more complex example. First create a test dataset with an east-west density step (this could be done more precisely with <code>sim.popn</code> + <code>sim.capthist</code>):</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb89-1"><a href="#cb89-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb89-2"><a href="#cb89-2" tabindex="-1"></a>ch <span class="ot">&lt;-</span> <span class="fu">subset</span>(captdata, <span class="fu">centroids</span>(captdata)[,<span class="dv">1</span>]<span class="sc">&gt;</span><span class="dv">500</span> <span class="sc">|</span> </span>
<span id="cb89-3"><a href="#cb89-3" tabindex="-1"></a>    <span class="fu">runif</span>(<span class="dv">76</span>) <span class="sc">&gt;</span> <span class="fl">0.75</span>)</span>
<span id="cb89-4"><a href="#cb89-4" tabindex="-1"></a><span class="fu">plot</span>(ch)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/stepch-1.png" alt="Test data" width="576" />
<p class="caption">
(#fig:stepch)Test data
</p>
</div>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" tabindex="-1"></a><span class="co"># also make a mask and assign the x coordinate to covariate &#39;X&#39;</span></span>
<span id="cb90-2"><a href="#cb90-2" tabindex="-1"></a>msk <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(<span class="fu">traps</span>(ch), <span class="at">buffer =</span> <span class="dv">100</span>, <span class="at">type =</span> <span class="st">&#39;trapbuffer&#39;</span>)</span>
<span id="cb90-3"><a href="#cb90-3" tabindex="-1"></a><span class="fu">covariates</span>(msk)<span class="sc">$</span>X <span class="ot">&lt;-</span> msk<span class="sc">$</span>x</span></code></pre></div>
<p>Now define a sigmoid function of covariate X:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb91-1"><a href="#cb91-1" tabindex="-1"></a>sigmoidfn <span class="ot">&lt;-</span> <span class="cf">function</span> (Dbeta, mask, ngroup, nsession) {</span>
<span id="cb91-2"><a href="#cb91-2" tabindex="-1"></a>    scale <span class="ot">&lt;-</span> <span class="fl">7.5</span>   <span class="co"># arbitrary &#39;width&#39; of step</span></span>
<span id="cb91-3"><a href="#cb91-3" tabindex="-1"></a>    <span class="cf">if</span> (Dbeta[<span class="dv">1</span>] <span class="sc">==</span> <span class="st">&quot;name&quot;</span>) <span class="fu">return</span> (<span class="st">&quot;sig&quot;</span>)</span>
<span id="cb91-4"><a href="#cb91-4" tabindex="-1"></a>    <span class="cf">if</span> (Dbeta[<span class="dv">1</span>] <span class="sc">==</span> <span class="st">&quot;parameters&quot;</span>) <span class="fu">return</span> (<span class="fu">c</span>(<span class="st">&quot;D1&quot;</span>, <span class="st">&quot;threshold&quot;</span>, <span class="st">&quot;D2&quot;</span>))</span>
<span id="cb91-5"><a href="#cb91-5" tabindex="-1"></a>    X2 <span class="ot">&lt;-</span> (<span class="fu">covariates</span>(mask)<span class="sc">$</span>X <span class="sc">-</span> Dbeta[<span class="dv">2</span>]) <span class="sc">/</span> scale</span>
<span id="cb91-6"><a href="#cb91-6" tabindex="-1"></a>    D <span class="ot">&lt;-</span> Dbeta[<span class="dv">1</span>] <span class="sc">+</span> <span class="dv">1</span> <span class="sc">/</span> (<span class="dv">1</span><span class="sc">+</span><span class="fu">exp</span>(<span class="sc">-</span>X2)) <span class="sc">*</span> (Dbeta[<span class="dv">3</span>] <span class="sc">-</span> Dbeta[<span class="dv">1</span>])</span>
<span id="cb91-7"><a href="#cb91-7" tabindex="-1"></a>    tempD <span class="ot">&lt;-</span> <span class="fu">array</span>(D, <span class="at">dim =</span> <span class="fu">c</span>(<span class="fu">nrow</span>(mask), ngroup, nsession))</span>
<span id="cb91-8"><a href="#cb91-8" tabindex="-1"></a>    <span class="fu">return</span>(tempD)</span>
<span id="cb91-9"><a href="#cb91-9" tabindex="-1"></a>}</span></code></pre></div>
<p>Fit null model and sigmoid model:</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1" tabindex="-1"></a>fit<span class="fl">.0</span> <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ch, <span class="at">mask =</span> msk, <span class="at">link =</span> <span class="fu">list</span>(<span class="at">D =</span> <span class="st">&quot;identity&quot;</span>), </span>
<span id="cb92-2"><a href="#cb92-2" tabindex="-1"></a>    <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## Warning: multi-catch likelihood used for single-catch traps</code></pre>
<div class="sourceCode" id="cb94"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb94-1"><a href="#cb94-1" tabindex="-1"></a>fit.sigmoid <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ch, <span class="at">mask =</span> msk, <span class="at">details =</span> </span>
<span id="cb94-2"><a href="#cb94-2" tabindex="-1"></a>    <span class="fu">list</span>(<span class="at">userDfn =</span> sigmoidfn), <span class="at">start=</span><span class="fu">c</span>(<span class="fl">2.7</span>, <span class="dv">500</span>, <span class="fl">5.8</span>, <span class="sc">-</span><span class="fl">1.2117</span>, </span>
<span id="cb94-3"><a href="#cb94-3" tabindex="-1"></a>    <span class="fl">3.4260</span>), <span class="at">link =</span> <span class="fu">list</span>(<span class="at">D =</span> <span class="st">&quot;identity&quot;</span>), <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## Warning: multi-catch likelihood used for single-catch traps</code></pre>
<div class="sourceCode" id="cb96"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb96-1"><a href="#cb96-1" tabindex="-1"></a><span class="fu">coef</span>(fit<span class="fl">.0</span>)</span></code></pre></div>
<pre><code>##           beta   SE.beta      lcl       ucl
## D      3.61230 0.5242363  2.58482  4.639788
## g0    -1.08172 0.1618207 -1.39888 -0.764556
## sigma  3.39562 0.0556146  3.28661  3.504620</code></pre>
<div class="sourceCode" id="cb98"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb98-1"><a href="#cb98-1" tabindex="-1"></a><span class="fu">coef</span>(fit.sigmoid)</span></code></pre></div>
<pre><code>##                  beta    SE.beta       lcl        ucl
## D.D1          1.68480  0.5140078   0.67736   2.692233
## D.threshold 514.27855 16.6652067 481.61535 546.941758
## D.D2          5.87518  1.0463780   3.82431   7.926040
## g0           -1.07969  0.1617379  -1.39669  -0.762691
## sigma         3.39328  0.0554231   3.28466   3.501911</code></pre>
<div class="sourceCode" id="cb100"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb100-1"><a href="#cb100-1" tabindex="-1"></a><span class="fu">AIC</span>(fit<span class="fl">.0</span>, fit.sigmoid)[,<span class="sc">-</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">6</span>)]</span></code></pre></div>
<pre><code>##                                model npar   logLik  dAICc AICcwt
## fit.sigmoid D~userD.sig g0~1 sigma~1    5 -519.779  0.000      1
## fit.0               D~1 g0~1 sigma~1    3 -527.232 10.063      0</code></pre>
<p>The sigmoid model has improved fit, but there is a lot of uncertainty in the two density levels. The average of the fitted levels D1 and D2 (3.78) is not far from the fitted homogeneous level (3.6123).</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb102-1"><a href="#cb102-1" tabindex="-1"></a>beta <span class="ot">&lt;-</span> <span class="fu">coef</span>(fit.sigmoid)[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,<span class="st">&#39;beta&#39;</span>]</span>
<span id="cb102-2"><a href="#cb102-2" tabindex="-1"></a>X2 <span class="ot">&lt;-</span> (<span class="dv">300</span><span class="sc">:</span><span class="dv">700</span> <span class="sc">-</span> beta[<span class="dv">2</span>]) <span class="sc">/</span> <span class="dv">15</span></span>
<span id="cb102-3"><a href="#cb102-3" tabindex="-1"></a>D <span class="ot">&lt;-</span> beta[<span class="dv">1</span>] <span class="sc">+</span> <span class="dv">1</span> <span class="sc">/</span> (<span class="dv">1</span><span class="sc">+</span><span class="fu">exp</span>(<span class="sc">-</span>X2)) <span class="sc">*</span> (beta[<span class="dv">3</span>] <span class="sc">-</span> beta[<span class="dv">1</span>])</span>
<span id="cb102-4"><a href="#cb102-4" tabindex="-1"></a><span class="fu">plot</span> (<span class="dv">300</span><span class="sc">:</span><span class="dv">700</span>, D, <span class="at">type =</span> <span class="st">&#39;l&#39;</span>, <span class="at">xlab =</span> <span class="st">&#39;X&#39;</span>, <span class="at">ylab =</span> <span class="st">&#39;Density&#39;</span>, </span>
<span id="cb102-5"><a href="#cb102-5" tabindex="-1"></a>      <span class="at">ylim =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">7</span>))</span>
<span id="cb102-6"><a href="#cb102-6" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v =</span> beta[<span class="dv">2</span>], <span class="at">lty =</span> <span class="dv">2</span>)</span>
<span id="cb102-7"><a href="#cb102-7" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">h =</span> <span class="fu">coef</span>(fit<span class="fl">.0</span>)[<span class="dv">1</span>,<span class="dv">1</span>], <span class="at">lty =</span> <span class="dv">1</span>, <span class="at">col =</span> <span class="st">&#39;blue&#39;</span>)</span>
<span id="cb102-8"><a href="#cb102-8" tabindex="-1"></a><span class="fu">rug</span>(<span class="fu">unique</span>(<span class="fu">traps</span>(ch)<span class="sc">$</span>x), <span class="at">col =</span> <span class="st">&#39;red&#39;</span>)</span>
<span id="cb102-9"><a href="#cb102-9" tabindex="-1"></a><span class="fu">text</span>(<span class="dv">400</span>, <span class="fl">2.2</span>, <span class="st">&#39;D1&#39;</span>)</span>
<span id="cb102-10"><a href="#cb102-10" tabindex="-1"></a><span class="fu">text</span>(<span class="dv">620</span>, <span class="fl">6.4</span>, <span class="st">&#39;D2&#39;</span>)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/stepplot-1.png" alt="Step function" width="432" />
<p class="caption">
(#fig:stepplot)Step function
</p>
</div>
</div>
<div id="linkappendix" class="section level2" number="9.9">
<h2><span class="header-section-number">9.9</span> Appendix 2. More on link functions</h2>
<p>From <strong>secr</strong> 4.5.0 there is a scaled identity link ‘i1000’ that multiplies each real parameter value by 1000. Then <code>secr.fit(..., link = list(D = 'i1000'))</code> is a fast alternative to specifying <code>typsize</code> for low absolute density.</p>
<p>Going further, you can even define your own <em>ad hoc</em> link function. To do this, provide the following functions in your workspace (your name ‘xxx’ combined with standard prefixes) and use your name to specify the link:</p>
<table>
<colgroup>
<col width="12%" />
<col width="30%" />
<col width="57%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Purpose</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>xxx</td>
<td>transform to link scale</td>
<td>i100 &lt;- function(x) x * 100</td>
</tr>
<tr class="even">
<td>invxxx</td>
<td>transform from link scale</td>
<td>invi100 &lt;- function(x) x / 100</td>
</tr>
<tr class="odd">
<td>se.invxxx</td>
<td>transform SE from link scale</td>
<td>se.invi100 &lt;- function (beta, sebeta) sebeta / 100</td>
</tr>
<tr class="even">
<td>se.xxx</td>
<td>transform SE to link scale</td>
<td>se.i100 &lt;- function (real, sereal) sereal * 100</td>
</tr>
</tbody>
</table>
<p>Following this example, you would call <code>secr.fit(..., link = list(D = 'i100'))</code>.
To see the internal transformations for the standard link functions, type <code>secr:::transform</code>, <code>secr:::untransform</code>, <code>secr:::se.untransform</code> or <code>secr:::se.transform</code>.</p>
<!--chapter:end:08-density-model.Rmd-->
</div>
</div>
<div id="Habitat" class="section level1" number="10">
<h1><span class="header-section-number">10</span> Habitat mask</h1>
<p>A mask represents habitat in the vicinity of detectors that is potentially occupied by the species of interest. Understanding habitat masks and how to define and manipulate them is central to spatially explicit capture–recapture. This chapter summarises what users need to know about masks in <strong>secr</strong>. Early sections apply regardless of software.</p>
<div id="background" class="section level2" number="10.1">
<h2><span class="header-section-number">10.1</span> Background</h2>
<p>We start with an intuitive explanation of the need for habitat masks. Devices such as traps or cameras record animals moving in a general region. If the devices span a patch of habitat with a known boundary then we use a mask to define that geographical unit. More commonly, detectors are placed in continuous habitat and the boundary of the region sampled is ill-defined. This is because the probability of detecting an animal tapers off gradually with distance.</p>
<p>Vagueness regarding the region sampled is addressed in spatially explicit capture–recapture by considering a larger and more inclusive region, the habitat mask. Its extent is not critical, except that it should be at least large enough to account for all detected animals.</p>
<p>Next we refine this intuitive explanation for each of the dominant methods for fitting SECR models: maximum likelihood and Markov-chain Monte Carlo (MCMC) sampling. Each grapples in a slightly different way with the awkward fact that, although we wish to model detection as a function of distance from the activity centre, the activity centre of each animal is at an unknown location.</p>
<div id="maximum-likelihood-and-the-area-of-integration" class="section level3" number="10.1.1">
<h3><span class="header-section-number">10.1.1</span> Maximum likelihood and the area of integration</h3>
<p>The likelihood developed for SECR by <span class="citation">Borchers and Efford (<a href="#ref-be08">2008</a>)</span> allows for the unknown centres by numerically integrating them out of the likelihood (crudely, by summing over all possible locations of detected animals, weighting each by a detection probability). Although the integration might, in principle, have infinite spatial bounds, it is practical to restrict attention to a smaller region, the ‘area of integration’. As long as the probability weights get close to zero before we reach the boundary, we don’t need to worry too much about the size of the region.</p>
<p>In <strong>secr</strong> the habitat mask equates to the area of integration: the likelihood is evaluated by summing values across a fine mesh of points. This is the primary function of the habitat mask; we consider other functions <a href="#maskwhatfor">later</a>.</p>
</div>
<div id="mcmc-and-the-bayesian-state-space" class="section level3" number="10.1.2">
<h3><span class="header-section-number">10.1.2</span> MCMC and the Bayesian ‘state space’</h3>
<p>MCMC methods for spatial capture–recapture developed by Royle and coworkers <span class="citation">(<a href="#ref-rcsg14">Royle et al. 2014</a>)</span> take a slightly different tack. The activity centres are treated as a large number of unobserved (latent) variables. The MCMC algorithm ‘samples’ from the posterior distribution of location for each animal, whether detected or not. The term ‘state space’ is used for the set of permitted locations; usually this is a continuous (not discretized) rectangular region.</p>
</div>
</div>
<div id="maskwhatfor" class="section level2" number="10.2">
<h2><span class="header-section-number">10.2</span> What is a mask for?</h2>
<p>Masks serve multiple purposes in addition to the basic one we have just introduced. We distinguish five functions of a habitat mask and there may be more:</p>
<ol style="list-style-type: decimal">
<li><p>To define the outer limit of the area of integration. Habitat beyond the mask may be occupied, but animals centred there have negligible chance of being detected.</p></li>
<li><p>To facilitate computation. By defining the area of integration as a list of discrete points (the centres of grid cells, each with notionally uniform density) we transform the relatively messy task of numerical integration into the much simpler one of summation.</p></li>
<li><p>To distinguish habitat sites from non-habitat sites within the outer limit. Habitat cells have the potential to be occupied. Treating non-habitat as if it is habitat can cause habitat-specific density to be underestimated.</p></li>
<li><p>To store habitat covariates for spatial models of density. Covariates for modelling a density surface are provided for each point on the mask.</p></li>
<li><p>To define a region for which a post-hoc estimate of population size is required. This may differ from the mask used to fit the model.</p></li>
</ol>
<p>The first point raises the question of where the outer limit should lie (i.e., the buffer width), and the second raises the question of how coarse the discretization (i.e., the cell size) can be without damaging the estimates. Later sections address each of the five points in turn, after an introductory section describing the particular implementation of habitat masks in the R package <strong>secr</strong>.</p>
</div>
<div id="masks-in-secr" class="section level2" number="10.3">
<h2><span class="header-section-number">10.3</span> Masks in <strong>secr</strong></h2>
<p>A habitat mask is represented in <strong>secr</strong> by a set of <em>square</em> grid cells. Their combined area may be almost any shape and may include holes. An object of class ‘mask’ is a 2-column dataframe with additional attributes (cell area etc.); each row gives the x- and y-coordinates of the centre of one cell.</p>
<div id="masks-generated-automatically-by-secr.fit" class="section level3" number="10.3.1">
<h3><span class="header-section-number">10.3.1</span> Masks generated automatically by <code>secr.fit</code></h3>
<p>A mask is used whenever a model is fitted with the function <code>secr.fit</code>, even if none is specified in the ‘mask’ argument. When no mask is provided, one is constructed automatically using the value of the ‘buffer’ argument. For example</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb103-1"><a href="#cb103-1" tabindex="-1"></a><span class="fu">library</span>(secr)</span>
<span id="cb103-2"><a href="#cb103-2" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(captdata, <span class="at">buffer =</span> <span class="dv">80</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>The mask is saved as a component of the fitted model (‘secr’ object); we can plot it and overlay the traps:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb104-1"><a href="#cb104-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>))</span>
<span id="cb104-2"><a href="#cb104-2" tabindex="-1"></a><span class="fu">plot</span>(fit<span class="sc">$</span>mask, <span class="at">dots =</span> <span class="cn">FALSE</span>, <span class="at">mesh =</span> <span class="st">&quot;grey&quot;</span>, <span class="at">col =</span> <span class="st">&quot;white&quot;</span>)</span>
<span id="cb104-3"><a href="#cb104-3" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">traps</span>(captdata), <span class="at">detpar =</span> <span class="fu">list</span>(<span class="at">pch =</span> <span class="dv">16</span>, <span class="at">cex =</span> <span class="dv">1</span>), <span class="at">add =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="figure" style="text-align: center">
<img src="SECRbook_files/figure-html/bufferplot-1.png" alt=" Mask (grey grid) generated automatically in `secr.fit` by buffering around the detectors (red dots) (80-m buffer, 30-m detector spacing)" width="336" />
<p class="caption">
(#fig:bufferplot) Mask (grey grid) generated automatically in <code>secr.fit</code> by buffering around the detectors (red dots) (80-m buffer, 30-m detector spacing)
</p>
</div>
<p>The mask is generated by forming a grid that extends ‘buffer’ metres north, south, east and west of the detectors and dropping centroids that are more than ‘buffer’ metres from the nearest detector (hence the rounded corners). The obvious question “How wide should the buffer be?” is addressed in a later section. The spacing of mask points (i.e. width of grid cells) is set arbitrarily to 1/64th of the east-west dimension - in this example the spacing is 6.7 metres.</p>
</div>
<div id="masks-constructed-with-make.mask" class="section level3" number="10.3.2">
<h3><span class="header-section-number">10.3.2</span> Masks constructed with <code>make.mask</code></h3>
<p>A mask may also be prepared in advance and provided to <code>secr.fit</code> in the ‘mask’ argument. This overrides the automatic process of the preceding section, and the value of ‘buffer’ is discarded. The function <code>make.mask</code> provides precise control over the the size of the cells, the extent of the mask, and much more. We introduce <code>make.mask</code> here with a simple example based on a ‘hollow grid’:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb105-1"><a href="#cb105-1" tabindex="-1"></a>hollowgrid <span class="ot">&lt;-</span> <span class="fu">make.grid</span>(<span class="at">nx =</span> <span class="dv">10</span>, <span class="at">ny =</span> <span class="dv">10</span>, <span class="at">spacing =</span> <span class="dv">30</span>, <span class="at">hollow =</span> <span class="cn">TRUE</span>)</span>
<span id="cb105-2"><a href="#cb105-2" tabindex="-1"></a>hollowmask <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(hollowgrid, <span class="at">buffer =</span> <span class="dv">80</span>, <span class="at">spacing =</span> <span class="dv">15</span>, <span class="at">type =</span> <span class="st">&quot;trapbuffer&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb106"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb106-1"><a href="#cb106-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>))</span>
<span id="cb106-2"><a href="#cb106-2" tabindex="-1"></a><span class="fu">plot</span>(hollowmask, <span class="at">dots =</span> <span class="cn">FALSE</span>, <span class="at">mesh =</span> <span class="st">&quot;grey&quot;</span>, <span class="at">col =</span> <span class="st">&quot;white&quot;</span>)</span>
<span id="cb106-3"><a href="#cb106-3" tabindex="-1"></a><span class="fu">plot</span>(hollowgrid, <span class="at">detpar =</span> <span class="fu">list</span>(<span class="at">pch =</span> <span class="dv">16</span>, <span class="at">cex =</span> <span class="dv">1</span>), <span class="at">add =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="figure" style="text-align: center">
<img src="SECRbook_files/figure-html/simplemakemask-1.png" alt="Mask (grey grid) generated with `make.mask` (80-m buffer, 30-m trap spacing, 15-m mask spacing). Grid cells in the centre were dropped because they were more than 80 m from any trap." width="336" />
<p class="caption">
(#fig:simplemakemask)Mask (grey grid) generated with <code>make.mask</code> (80-m buffer, 30-m trap spacing, 15-m mask spacing). Grid cells in the centre were dropped because they were more than 80 m from any trap.
</p>
</div>
<p>We chose a coarser grid (spacing 15 metres) relative to the trap spacing. This, combined with the hole in the centre, results in a mask with many fewer rows (764 rows compared to 3980). Setting the type to “trapbuffer” trims a few grid cells from the corners,</p>
<p>If we collected data <code>hollowCH</code> with the hollow grid we could fit a SECR model using <code>hollowmask</code>. For illustration we simulate some data using default settings in <code>sim.capthist</code> (5 occasions, D = 5/ha, g0 = 0.2, sigma = 25 m).</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb107-1"><a href="#cb107-1" tabindex="-1"></a>hollowCH <span class="ot">&lt;-</span> <span class="fu">sim.capthist</span>(hollowgrid, <span class="at">seed =</span> <span class="dv">123</span>)</span>
<span id="cb107-2"><a href="#cb107-2" tabindex="-1"></a>fit2 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(hollowCH, <span class="at">mask =</span> hollowmask, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb107-3"><a href="#cb107-3" tabindex="-1"></a><span class="fu">predict</span>(fit2)</span></code></pre></div>
<pre><code>##        link  estimate SE.estimate       lcl      ucl
## D       log  5.080738   1.0785347  3.366836  7.66711
## g0    logit  0.204695   0.0443094  0.131169  0.30497
## sigma   log 26.180121   3.2416697 20.557723 33.34021</code></pre>
<p>Fitting is fast because there are few traps and few mask points. As before, the mask is retained in the output, so –</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb109-1"><a href="#cb109-1" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;Number of rows in hollow mask =&quot;</span>, <span class="fu">nrow</span>(fit2<span class="sc">$</span>mask), <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)</span></code></pre></div>
<pre><code>## Number of rows in hollow mask = 764</code></pre>
</div>
</div>
<div id="bufferwidth" class="section level2" number="10.4">
<h2><span class="header-section-number">10.4</span> How wide should the buffer be?</h2>
<p>The general answer is ‘Wide enough that any bias in estimated densities is negligible’. Excessive truncation of the mask results in positive bias that depends on the sampling regime (detector layout and sampling duration) and the detection function, particularly its spatial scale and shape.</p>
<p>The penalty for using an over-wide buffer is that fitting will be slower for a given mask spacing. It is usually smart to accept this penalty rather than search for the narrowest acceptable buffer. We therefore avoid detailed investigation of mask truncation bias<a href="#fn35" class="footnote-ref" id="fnref35"><sup>35</sup></a>.</p>
<p>Two factors are critical when selecting a buffer width –</p>
<ol style="list-style-type: decimal">
<li>The spatial scale of detection, which is usually a function of home-range movements.</li>
<li>The shape of the detection function, particularly the length of its tail.</li>
</ol>
<p>These must be considered together. The following comments assume the default half-normal detection function, which has a short tail and spatial scale parameter <span class="math inline">\(\sigma_{HN}\)</span>, unless stated otherwise.</p>
<div id="a-rule-of-thumb-for-buffer-width" class="section level3" number="10.4.1">
<h3><span class="header-section-number">10.4.1</span> A rule of thumb for buffer width</h3>
<p>As a rule of thumb, a buffer of <span class="math inline">\(4\sigma_{HN}\)</span> is likely to be adequate (result in truncation bias of less than 0.1%). A pilot estimate of <span class="math inline">\(\sigma_{HN}\)</span> may be found for a particular dataset (capthist object) with the function <code>RPSV</code> with the argument ‘CC’ set to TRUE:</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb111-1"><a href="#cb111-1" tabindex="-1"></a><span class="fu">RPSV</span>(captdata, <span class="at">CC =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] 25.629</code></pre>
<p>This is an approximation based on a circular bivariate normal distribution that ignores the truncation of recaptures due to the finite extent of the detector array <span class="citation">(<a href="#ref-cc58">Calhoun and Casby 1958</a>)</span>.</p>
</div>
<div id="buffer-width-for-heavy-tailed-detection-functions" class="section level3" number="10.4.2">
<h3><span class="header-section-number">10.4.2</span> Buffer width for heavy-tailed detection functions</h3>
<p>Heavy-tailed detection functions such as the hazard-rate (HR, HHR) can be problematic because they require an unreasonably large buffer for stable density estimates. They are better avoided unless there is a natural boundary.</p>
</div>
<div id="hands-free-buffer-selection-suggest.buffer" class="section level3" number="10.4.3">
<h3><span class="header-section-number">10.4.3</span> Hands-free buffer selection: <code>suggest.buffer</code></h3>
<p>The <code>suggest.buffer</code> function is an alternative to the <span class="math inline">\(4\sigma_{HN}\)</span> rule of thumb for data from point detectors (not polygon or transect detectors). It has the advantage of allowing for the geometry of the detector array (specifically, the length of edge) and the duration of sampling. The algorithm is obscure and undocumented (this is only a suggestion!); it uses an approximation to the bias computed by function <code>bias.D</code>. The first argument of <code>suggest.buffer</code> may be a capthist object or a fitted model. With a capthist object as input:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb113-1"><a href="#cb113-1" tabindex="-1"></a><span class="fu">suggest.buffer</span>(captdata, <span class="at">detectfn =</span> <span class="st">&#39;HN&#39;</span>, <span class="at">RBtarget =</span> <span class="fl">0.001</span>)</span></code></pre></div>
<pre><code>## Warning: using automatic &#39;detectpar&#39; g0 = 0.2369, sigma = 30.75</code></pre>
<pre><code>## [1] 105</code></pre>
<p>When the input is only a capthist object, the suggested buffer width relies on an estimate of <span class="math inline">\(\sigma_{HN}\)</span> that is itself biased (RPSV(captdata, CC=TRUE)). We see <a href="#suggest">later</a> how the suggested changes given an unbiased estimate of <span class="math inline">\(\sigma_{HN}\)</span>. Actual bias due to mask truncation will also exceed the target (RB = 0.1%) because of the limitations of the <em>ad hoc</em> algorithm, so that is not to be taken too literally.</p>
</div>
<div id="suggest" class="section level3" number="10.4.4">
<h3><span class="header-section-number">10.4.4</span> Retrospective buffer checks</h3>
<p>Once a model has been fitted with a particular buffer width or mask, the estimated detection parameters may be used to check whether the buffer width is likely to have resulted in mask truncation bias. We highlight two of these:</p>
<ol style="list-style-type: decimal">
<li><p><code>secr.fit</code> automatically checks a mask generated from its ‘buffer’ argument (i.e. when the ‘mask’ argument is missing), using <code>bias.D</code> as in <code>suggest.buffer</code>. A warning is given when the predicted truncation bias exceeds a threshold (default 1%). The threshold is controlled by the ‘biasLimit’ argument, which may be set to NA to suppress the check. The check cannot be performed for some detector types, and the embedded integration can give rise to cryptic error messages.</p></li>
<li><p><code>esa.plot</code> provides a quick visualisation of the change in estimated density as buffer width changes. It is a handy check on any fitted model, and may also be used with pilot parameter values. The name of the function derives from its reliance on calculation of the <a href="#esa">effective sampling area</a> (esa or <span class="math inline">\(a(\hat \theta)\)</span>).</p></li>
</ol>
<div class="sourceCode" id="cb116"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb116-1"><a href="#cb116-1" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(captdata, <span class="at">buffer =</span> <span class="dv">100</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<div class="sourceCode" id="cb117"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb117-1"><a href="#cb117-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">pty =</span> <span class="st">&quot;s&quot;</span>, <span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">2</span>), <span class="at">mgp =</span> <span class="fu">c</span>(<span class="fl">2.5</span>,<span class="fl">0.8</span>,<span class="dv">0</span>), <span class="at">las =</span> <span class="dv">1</span>)</span>
<span id="cb117-2"><a href="#cb117-2" tabindex="-1"></a><span class="fu">esa.plot</span>(fit, <span class="at">ylim =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">10</span>))</span>
<span id="cb117-3"><a href="#cb117-3" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v =</span> <span class="dv">4</span> <span class="sc">*</span> <span class="fl">25.6</span>, <span class="at">col =</span> <span class="st">&quot;red&quot;</span>, <span class="at">lty =</span> <span class="dv">2</span>)</span></code></pre></div>
<div class="figure" style="text-align: center">
<img src="SECRbook_files/figure-html/habitatesaplot-1.png" alt="Effect of varying buffer width on estimated density (y-axis). Vertical line indicates rule-of-thumb buffer width" width="336" />
<p class="caption">
(#fig:habitatesaplot)Effect of varying buffer width on estimated density (y-axis). Vertical line indicates rule-of-thumb buffer width
</p>
</div>
<p>The esa plot supports the prediction that increasing buffer width beyond the rule-of-thumb value has no discernable effect on the estimated density (Fig. @ref(fig:habitatesaplot)).</p>
<p>The function <code>mask.check</code> examines the effect of buffer width and mask spacing (cell size) by computing the likelihood or re-fitting an entire model. The function generates either the log likelihood or the estimated density for each cell in a matrix where rows correspond to different buffer widths and columns correspond to different mask spacings. The function is limited to single-session models and is slow compared to <code>esa.plot</code>. See <code>?mask.check</code> for more.</p>
<p>Note also that <code>suggest.buffer</code> may be used retrospectively (with a fitted model as input), and</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb118-1"><a href="#cb118-1" tabindex="-1"></a><span class="fu">suggest.buffer</span>(fit)</span></code></pre></div>
<pre><code>## [1] 100</code></pre>
<p>which is coincidental, but encouraging!</p>
</div>
<div id="buffer-using-non-euclidean-distances" class="section level3" number="10.4.5">
<h3><span class="header-section-number">10.4.5</span> Buffer using non-euclidean distances</h3>
<p>If you intend to use a non-Euclidean distance metric then it makes sense to use this also when defining the mask, specifically to drop mask points that are distant from any detector according to the metric. See Appendix @ref(Noneuclidean) for an example. Modelling with non-Euclidean distances also requires the user to provide <code>secr.fit</code> with a matrix of user-computed distances between detectors and mask points.</p>
</div>
</div>
<div id="maskspacing" class="section level2" number="10.5">
<h2><span class="header-section-number">10.5</span> Grid cell size and the effects of discretization</h2>
<p>Using a set of discrete locations (mask points) to represent the locations of animals is numerically convenient, and by making grid cells small enough we can certainly eliminate any effect of discretization. However, reducing cell size increases the number of cells and slows down model fitting. Trials with varying cell size (mask spacing) provide reassurance that discretization has not distorted the analysis.</p>
<p>In this section we report results from trials with four very different datasets. Three of these are datasets from <strong>secr</strong> (Maryland ovenbirds, ovenCH; Waitarere possums, possumCH; Arizona horned lizards, hornedlizardCH) for which details are given in the <strong>secr</strong> documentation. A fourth dataset is from a 2003 black bear (<em>Ursus americanus</em>) study by Jared Laufenberg, Frank van Manen and Joe Clark in the Great Smoky Mountains of Tennessee using hair snares and DNA microsatellites.</p>
<p>The reference scale was <span class="math inline">\(\sigma\)</span> estimated earlier by fitting a half-normal detection model. In each case masks were constructed with constant buffer width <span class="math inline">\(4\sigma\)</span> and different spacings in the range <span class="math inline">\(0.2\sigma\)</span> to <span class="math inline">\(3\sigma\)</span>. This resulted in widely varying numbers of mask points (Fig. @ref(fig:maskpoints)).</p>
<div class="figure">
<img src="figures/maskrows.png" alt="Effect of mask spacing on number of mask points for four test datasets. Detector configurations varied: a single searched square (horned lizards), a single elongated hollow grid of mistnets (ovenbirds), multiple hollow grids of cage traps (Waitarere possums), hair snares along a dense irregular network of trails (black bears)" width="60%" />
<p class="caption">
(#fig:maskpoints)Effect of mask spacing on number of mask points for four test datasets. Detector configurations varied: a single searched square (horned lizards), a single elongated hollow grid of mistnets (ovenbirds), multiple hollow grids of cage traps (Waitarere possums), hair snares along a dense irregular network of trails (black bears)
</p>
</div>
<div class="figure">
<img src="figures/maskspacing.png" alt="Effect of mask spacing on estimates of density from null model. Bias is relative to the estimate using the narrowest spacing. The Arizona horned lizard data appeared especially robust to mask spacing, which may be due to the method (search of a large contiguous area) or duration (14 sampling occasions) [@ry08]" width="90%" />
<p class="caption">
(#fig:maskspacing)Effect of mask spacing on estimates of density from null model. Bias is relative to the estimate using the narrowest spacing. The Arizona horned lizard data appeared especially robust to mask spacing, which may be due to the method (search of a large contiguous area) or duration (14 sampling occasions) <span class="citation">(<a href="#ref-ry08">Royle and Young 2008</a>)</span>
</p>
</div>
<p>The results in Fig. @ref(fig:maskspacing) suggest that, for a uniform density model, any mask spacing less than <span class="math inline">\(\sigma\)</span> is adequate; <span class="math inline">\(0.6\sigma\)</span> provides a considerable safety margin. The effect of detector spacing on the relationship has not been examined. Referring back to Fig. @ref(fig:maskpoints), a mask of about 1000 points will usually be adequate with a <span class="math inline">\(4\sigma\)</span> buffer.</p>
<p>The default spacing in <code>secr.fit</code> and <code>make.mask</code> is determined by dividing the x-dimension of the buffered area by 64. The resulting mask typically has about 4000 points, which is overkill. Substantial improvements in speed can be obtained with coarser masks, obtained by reducing ‘nx’ or ‘spacing’ arguments of <code>make.mask</code>.</p>
<p>For completeness, we revisit the question of buffer width using the <code>esa.plot</code> function with each of the four test datasets (Fig. @ref(fig:bufferbias)).</p>
<div class="figure">
<img src="figures/maskesa.png" alt="Approximate relative bias due to mask truncation for four datasets. Bias is relative to the estimate using the widest buffer" width="75%" />
<p class="caption">
(#fig:bufferbias)Approximate relative bias due to mask truncation for four datasets. Bias is relative to the estimate using the widest buffer
</p>
</div>
</div>
<div id="excluding-areas-of-non-habitat" class="section level2" number="10.6">
<h2><span class="header-section-number">10.6</span> Excluding areas of non-habitat</h2>
<p>Our focus so far has been on choosing a buffer width to set the outer boundary of a habitat mask, assuming that the actual boundary is arbitrary. We can call these ‘masks of convenience’ (Fig. @ref(fig:masktypes) a); numerical accuracy and computation speed are the only constraints. At the other extreme, a mask may represent a natural island of habitat surrounded by non-habitat (Fig. @ref(fig:masktypes) c). A geographical map, possibly in the form of an ESRI shapefile, is then sufficient to define the mask. Between these extremes there are may be a habitat mosaic including both some non-habitat near the detectors and some habitat further away, so neither the buffered mask of convenience nor the habitat island is a good match (Fig. @ref(fig:masktypes) b).</p>
<div class="figure">
<img src="figures/masktypes.png" alt="Types of habitat mask (grey mesh) defined in relation to habitat (green) and detectors (red dots). (a) mask of convenience defined by a buffer around detectors in continuous habitat, (b) mask of convenience excluding non-habitat (c) fully sampled habitat island" width="100%" />
<p class="caption">
(#fig:masktypes)Types of habitat mask (grey mesh) defined in relation to habitat (green) and detectors (red dots). (a) mask of convenience defined by a buffer around detectors in continuous habitat, (b) mask of convenience excluding non-habitat (c) fully sampled habitat island
</p>
</div>
<p>Exclusion of non-habitat (Fig. @ref(fig:masktypes) b,c) is achieved by providing <code>make.mask</code> with a digital map of the habitat in the ‘poly’ argument. The digital map may be an R object defining spatial polygons as described in Appendix @ref(Spatialdata), or simply a 2-column matrix or dataframe of coordinates. This simple example uses the coordinates in <code>possumarea</code>:</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb120-1"><a href="#cb120-1" tabindex="-1"></a>clippedmask <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(<span class="fu">traps</span>(possumCH), <span class="at">type =</span> <span class="st">&#39;trapbuffer&#39;</span>, <span class="at">buffer =</span> <span class="dv">400</span>, </span>
<span id="cb120-2"><a href="#cb120-2" tabindex="-1"></a>                        <span class="at">poly =</span> possumarea)</span></code></pre></div>
<p><span style="color: green;">Tip:</span> By default, data for the ‘poly’ argument are retained as an attribute of the mask. With some data sources this grossly inflates the size of the mask, and it is better to discard the attribute with <code>keep.poly = FALSE</code>.</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb121-1"><a href="#cb121-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>))</span>
<span id="cb121-2"><a href="#cb121-2" tabindex="-1"></a><span class="fu">plot</span>(clippedmask, <span class="at">border =</span> <span class="dv">100</span>, <span class="at">ppoly =</span> <span class="cn">FALSE</span>)</span>
<span id="cb121-3"><a href="#cb121-3" tabindex="-1"></a><span class="fu">polygon</span>(possumarea, <span class="at">col =</span> <span class="st">&#39;lightgreen&#39;</span>, <span class="at">border =</span> <span class="cn">NA</span>)</span>
<span id="cb121-4"><a href="#cb121-4" tabindex="-1"></a><span class="fu">plot</span>(clippedmask, <span class="at">dots =</span> <span class="cn">FALSE</span>, <span class="at">mesh =</span> <span class="fu">grey</span>(<span class="fl">0.4</span>), <span class="at">col =</span> <span class="cn">NA</span>, </span>
<span id="cb121-5"><a href="#cb121-5" tabindex="-1"></a>    <span class="at">add =</span> <span class="cn">TRUE</span>, <span class="at">polycol =</span> <span class="st">&#39;blue&#39;</span>)</span>
<span id="cb121-6"><a href="#cb121-6" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">traps</span>(possumCH), <span class="at">detpar =</span> <span class="fu">list</span>(<span class="at">pch =</span> <span class="dv">16</span>, <span class="at">cex =</span> <span class="fl">0.8</span>), </span>
<span id="cb121-7"><a href="#cb121-7" tabindex="-1"></a>    <span class="at">add =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="figure" style="text-align: center">
<img src="SECRbook_files/figure-html/plotpossummask-1.png" alt="Mask computed by clipping to a polygon -- the shoreline of the 'peninsula' at Waitarere separating the Tasman Sea (left) from the estuary of the Manawatu River (right)" width="384" />
<p class="caption">
(#fig:plotpossummask)Mask computed by clipping to a polygon – the shoreline of the ‘peninsula’ at Waitarere separating the Tasman Sea (left) from the estuary of the Manawatu River (right)
</p>
</div>
<p>The virtue of clipping non-habitat is that the estimate of density then relates to the area of habitat rather than the sum of habitat and non-habitat. For most uses habitat-based density would seem the more meaningful parameter.</p>
</div>
<div id="mask-covariates" class="section level2" number="10.7">
<h2><span class="header-section-number">10.7</span> Mask covariates</h2>
<p>Masks may have a ‘covariates’ attribute that is a dataframe just like the ‘covariates’ attributes of traps and capthist objects. The data frame has one row for each row (point) on the mask, and one column for each covariate. Covariates may be categorical (factor-valued) or continuous<a href="#fn36" class="footnote-ref" id="fnref36"><sup>36</sup></a>. Mask covariates are used for modelling [density surfaces] (D), not for modelling detection parameters (g0, lambda0, sigma)<a href="#fn37" class="footnote-ref" id="fnref37"><sup>37</sup></a>. The dataframe may include unused covariates.</p>
<div id="adding-covariates" class="section level3" number="10.7.1">
<h3><span class="header-section-number">10.7.1</span> Adding covariates</h3>
<p>Mask covariates are always added after a mask is first constructed. Extending the earlier example, we can add a covariate for the computed distance to shore:</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb122-1"><a href="#cb122-1" tabindex="-1"></a><span class="fu">covariates</span>(clippedmask) <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">d.to.shore =</span> </span>
<span id="cb122-2"><a href="#cb122-2" tabindex="-1"></a>    <span class="fu">distancetotrap</span>(clippedmask, possumarea))</span></code></pre></div>
<p>The function <code>addCovariates</code> makes it easy to extract data for each mask cell from a spatial data source. Its usage is</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb123-1"><a href="#cb123-1" tabindex="-1"></a><span class="fu">addCovariates</span> (object, spatialdata, <span class="at">columns =</span> <span class="cn">NULL</span>, </span>
<span id="cb123-2"><a href="#cb123-2" tabindex="-1"></a>    <span class="at">strict =</span> <span class="cn">FALSE</span>, <span class="at">replace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>Values are extracted for the point in the data source corresponding to the centre point of each grid cell. The spatial data source (<code>spatialdata</code>) should be one of</p>
<ul>
<li>ESRI polygon shapefile name (excluding .shp)</li>
<li>sf spatial object, package <strong>sf</strong> <span class="citation">(<a href="#ref-R-sf">Pebesma 2018</a>)</span></li>
<li>RasterLayer, package <strong>raster</strong> <span class="citation">(<a href="#ref-R-raster">Hijmans 2023a</a>)</span></li>
<li>SpatRaster,,package <strong>terra</strong> <span class="citation">(<a href="#ref-R-terra">Hijmans 2023b</a>)</span></li>
<li>SpatialPolygonsDataFrame, package <strong>sp</strong> <span class="citation">(<a href="#ref-R-sp">Pebesma and Bivand 2005</a>)</span></li>
<li>SpatialGridDataFrame, package <strong>sp</strong></li>
<li>another mask with covariates</li>
<li>a traps object with covariates</li>
</ul>
<p>One or more input columns may be selected by name. The argument ‘strict’ generates a warning if points lie outside a mask used as a spatial data source.</p>
</div>
<div id="repairing-missing-values" class="section level3" number="10.7.2">
<h3><span class="header-section-number">10.7.2</span> Repairing missing values</h3>
<p>Covariate values become NA for points not in the data source for addCovariates. Modelling will fail until a valid value is provided for every mask point (ignoring covariates not used in models). If only a few values are missing at only a few points it is usually acceptable to interpolate them from surrounding non-missing values. For continuous covariates we suggest linear interpolation with the function <code>interp</code> in the <strong>akima</strong> package <span class="citation">(<a href="#ref-R-akima">Akima and Gebhardt 2022</a>)</span>. The following short function provides an interface:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb124-1"><a href="#cb124-1" tabindex="-1"></a>repair <span class="ot">&lt;-</span> <span class="cf">function</span> (mask, covariate, ...) {</span>
<span id="cb124-2"><a href="#cb124-2" tabindex="-1"></a>    NAcov <span class="ot">&lt;-</span> <span class="fu">is.na</span>(<span class="fu">covariates</span>(mask)[,covariate])</span>
<span id="cb124-3"><a href="#cb124-3" tabindex="-1"></a>    OK <span class="ot">&lt;-</span> <span class="fu">subset</span>(mask, <span class="sc">!</span>NAcov)</span>
<span id="cb124-4"><a href="#cb124-4" tabindex="-1"></a>    <span class="fu">require</span>(akima)</span>
<span id="cb124-5"><a href="#cb124-5" tabindex="-1"></a>    irect <span class="ot">&lt;-</span> akima<span class="sc">::</span><span class="fu">interp</span> (<span class="at">x =</span> OK<span class="sc">$</span>x, <span class="at">y =</span> OK<span class="sc">$</span>y, <span class="at">z =</span> </span>
<span id="cb124-6"><a href="#cb124-6" tabindex="-1"></a>        <span class="fu">covariates</span>(OK)[,covariate],...)</span>
<span id="cb124-7"><a href="#cb124-7" tabindex="-1"></a>    irectxy <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(<span class="at">x =</span> irect<span class="sc">$</span>x, <span class="at">y =</span> irect<span class="sc">$</span>y)</span>
<span id="cb124-8"><a href="#cb124-8" tabindex="-1"></a>    i <span class="ot">&lt;-</span> <span class="fu">nearesttrap</span>(mask[NAcov,], irectxy)</span>
<span id="cb124-9"><a href="#cb124-9" tabindex="-1"></a>    <span class="fu">covariates</span>(mask)[,covariate][NAcov] <span class="ot">&lt;-</span> irect[[<span class="dv">3</span>]][i]</span>
<span id="cb124-10"><a href="#cb124-10" tabindex="-1"></a>    mask</span>
<span id="cb124-11"><a href="#cb124-11" tabindex="-1"></a>}</span></code></pre></div>
<p>To demonstrate <code>repair</code> we deliberately remove a swathe of covariate values from a copy of our clippedmask and then attempt to interpolate them (Fig. @ref(fig:fillindemo)):</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb125-1"><a href="#cb125-1" tabindex="-1"></a>damagedmask <span class="ot">&lt;-</span> clippedmask</span>
<span id="cb125-2"><a href="#cb125-2" tabindex="-1"></a><span class="fu">covariates</span>(damagedmask)<span class="sc">$</span>d.to.shore[<span class="dv">500</span><span class="sc">:</span><span class="dv">1000</span>] <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb125-3"><a href="#cb125-3" tabindex="-1"></a>repaired <span class="ot">&lt;-</span> <span class="fu">repair</span>(damagedmask, <span class="st">&#39;d.to.shore&#39;</span>, <span class="at">nx=</span><span class="dv">60</span>, <span class="at">ny=</span><span class="dv">50</span>)</span></code></pre></div>
<p>The interpolation may potentially be improved by varying the <code>interp</code> arguments nx and ny (passed via the … argument of <code>repair</code>). Although extrapolation is available (with linear = FALSE, extrap = TRUE) it did not work in this case, and there remain some unfilled cells (Fig. @ref(fig:fillindemo)c).</p>
<p>Categorical covariates pose a larger problem. Simply copying the closest valid value may suffice to allow modelling to proceed, and this is a good solution for the few NA cells in Fig. @ref(fig:fillindemo)c. The result should always be checked visually by plotting the covariate: strange patterns may result.</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb126-1"><a href="#cb126-1" tabindex="-1"></a>copynearest <span class="ot">&lt;-</span> <span class="cf">function</span> (mask, cov) {</span>
<span id="cb126-2"><a href="#cb126-2" tabindex="-1"></a>    NAcov <span class="ot">&lt;-</span> <span class="fu">is.na</span>(<span class="fu">covariates</span>(mask)[,cov])</span>
<span id="cb126-3"><a href="#cb126-3" tabindex="-1"></a>    OK <span class="ot">&lt;-</span> <span class="fu">subset</span>(mask, <span class="sc">!</span>NAcov)</span>
<span id="cb126-4"><a href="#cb126-4" tabindex="-1"></a>    i <span class="ot">&lt;-</span> <span class="fu">nearesttrap</span>(mask, OK)</span>
<span id="cb126-5"><a href="#cb126-5" tabindex="-1"></a>    <span class="fu">covariates</span>(mask)[,cov][NAcov] <span class="ot">&lt;-</span> <span class="fu">covariates</span>(OK)[i[NAcov],cov]</span>
<span id="cb126-6"><a href="#cb126-6" tabindex="-1"></a>    mask</span>
<span id="cb126-7"><a href="#cb126-7" tabindex="-1"></a>}</span>
<span id="cb126-8"><a href="#cb126-8" tabindex="-1"></a>completed <span class="ot">&lt;-</span> <span class="fu">copynearest</span>(repaired, <span class="st">&#39;d.to.shore&#39;</span>)</span></code></pre></div>
<div class="figure" style="text-align: center">
<img src="SECRbook_files/figure-html/fillindemo-1.png" alt="Interpolation of missing values in mask covariate (artificial example). (a) True coverage, (b) Swathe of missing values, (c) Repaired by linear interpolation. Cells in the west and east that lie outside the convex hull of non-missing points are not interpolated and remain missing, (d) repair completed by filling remaining NA cells with value from nearest non-missing cell" width="624" />
<p class="caption">
(#fig:fillindemo)Interpolation of missing values in mask covariate (artificial example). (a) True coverage, (b) Swathe of missing values, (c) Repaired by linear interpolation. Cells in the west and east that lie outside the convex hull of non-missing points are not interpolated and remain missing, (d) repair completed by filling remaining NA cells with value from nearest non-missing cell
</p>
</div>
<p>See Chapter @ref(Density) for more on the use of mask covariates.</p>
</div>
</div>
<div id="regional-population-size" class="section level2" number="10.8">
<h2><span class="header-section-number">10.8</span> Regional population size</h2>
<p>Population density <span class="math inline">\(D\)</span> is the primary parameter in this implementation of spatially explicit capture–recapture (SECR). The number of individuals (population size <span class="math inline">\(N(A)\)</span>) is treated as a derived parameter. The rationale for this is that population size is ill-defined in many classical sampling scenarios in continuous habitat (Figs. 7a,b). Population size is well-defined for a habitat island (Fig. @ref(fig:masktypes) c). Population size may also be well-defined for a persistent swarm, colony, herd, pack or flock, although group living is incompatible with the usual SECR assumption of independence e.g. <span class="citation">Bischof et al. (<a href="#ref-Bischof2020">2020</a>)</span>.</p>
<p>Population size on a habitat island <span class="math inline">\(A\)</span> may be derived from an SECR model by the simple calculation <span class="math inline">\(\hat N = \hat D|A|\)</span> if density is uniform. The same calculation yields the expected population in any area <span class="math inline">\(A^\prime\)</span>. Calculations get more tricky if density is not uniform as then <span class="math inline">\(\hat N = \int_{A^\prime} D(\mathbf{x}) \, d\mathbf{x}\)</span> (computing the volume under the density surface) <span class="citation">(<a href="#ref-ef13">Efford and Fewster 2013</a>)</span>.</p>
<p>Function <code>region.N</code> calculates <span class="math inline">\(\hat N\)</span> for a previously fitted SECR model (secr object) and region <span class="math inline">\(A^\prime\)</span>, along with standard errors and confidence intervals <span class="citation">(<a href="#ref-ef13">Efford and Fewster 2013</a>)</span>. The default region is the mask used to fit the model, but this is generally arbitrary, as we have seen, and users would be wise to specify the ‘region’ argument explicitly. That may be a new mask with different extent<a href="#fn38" class="footnote-ref" id="fnref38"><sup>38</sup></a> and cell size. Any covariates used to fit the model must also be present in the new ‘region’ mask.</p>
</div>
<div id="plotting-masks" class="section level2" number="10.9">
<h2><span class="header-section-number">10.9</span> Plotting masks</h2>
<p>The default plot of a mask shows each point as a grey dot. We have used <code>dots = FALSE</code> throughout this document to emphasise the gridcell structure. That is especially handy when we use the plot method to display mask covariates:</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb127-1"><a href="#cb127-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>), <span class="at">xpd=</span><span class="cn">TRUE</span>)</span>
<span id="cb127-2"><a href="#cb127-2" tabindex="-1"></a><span class="fu">plot</span>(clippedmask, <span class="at">covariate =</span> <span class="st">&#39;d.to.shore&#39;</span>, <span class="at">dots =</span> <span class="cn">FALSE</span>, </span>
<span id="cb127-3"><a href="#cb127-3" tabindex="-1"></a>    <span class="at">border=</span><span class="dv">100</span>, <span class="at">title =</span> <span class="st">&#39;Distance to shore m&#39;</span>, <span class="at">polycol =</span> <span class="st">&#39;blue&#39;</span>)</span>
<span id="cb127-4"><a href="#cb127-4" tabindex="-1"></a><span class="fu">plotMaskEdge</span>(clippedmask, <span class="at">add =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="figure" style="text-align: center">
<img src="SECRbook_files/figure-html/plotmask-1.png" alt="Plot of a computed continuous covariate across a clipped mask, with outer margin" width="624" />
<p class="caption">
(#fig:plotmask)Plot of a computed continuous covariate across a clipped mask, with outer margin
</p>
</div>
<p>The legend may be suppressed with <code>legend = FALSE</code>. See <code>?plot.mask</code> for details. We used <code>plotMaskEdge</code> to add a line around the perimeter.</p>
</div>
<div id="more-on-creating-and-manipulating-masks" class="section level2" number="10.10">
<h2><span class="header-section-number">10.10</span> More on creating and manipulating masks</h2>
<div id="arguments-of-make.mask" class="section level3" number="10.10.1">
<h3><span class="header-section-number">10.10.1</span> Arguments of <code>make.mask</code></h3>
<p>The usage statement for <code>make.mask</code> is included as a reminder of various options and defaults that have not been covered in this vignette. See <code>?make.mask</code> for details.</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb128-1"><a href="#cb128-1" tabindex="-1"></a><span class="fu">make.mask</span> (traps, <span class="at">buffer =</span> <span class="dv">100</span>, <span class="at">spacing =</span> <span class="cn">NULL</span>, <span class="at">nx =</span> <span class="dv">64</span>, <span class="at">ny =</span> <span class="dv">64</span>,</span>
<span id="cb128-2"><a href="#cb128-2" tabindex="-1"></a>    <span class="at">type =</span> <span class="fu">c</span>(<span class="st">&quot;traprect&quot;</span>, <span class="st">&quot;trapbuffer&quot;</span>, <span class="st">&quot;pdot&quot;</span>, <span class="st">&quot;polygon&quot;</span>, </span>
<span id="cb128-3"><a href="#cb128-3" tabindex="-1"></a>    <span class="st">&quot;clusterrect&quot;</span>, <span class="st">&quot;clusterbuffer&quot;</span>, <span class="st">&quot;rectangular&quot;</span>, <span class="st">&quot;polybuffer&quot;</span>),</span>
<span id="cb128-4"><a href="#cb128-4" tabindex="-1"></a>    <span class="at">poly =</span> <span class="cn">NULL</span>, <span class="at">poly.habitat =</span> <span class="cn">TRUE</span>, <span class="at">cell.overlap =</span> <span class="fu">c</span>(<span class="st">&quot;centre&quot;</span>,</span>
<span id="cb128-5"><a href="#cb128-5" tabindex="-1"></a>    <span class="st">&quot;any&quot;</span>, <span class="st">&quot;all&quot;</span>), <span class="at">keep.poly =</span> <span class="cn">TRUE</span>, <span class="at">check.poly =</span> <span class="cn">TRUE</span>, </span>
<span id="cb128-6"><a href="#cb128-6" tabindex="-1"></a>    <span class="at">pdotmin =</span> <span class="fl">0.001</span>, <span class="at">random.origin =</span> <span class="cn">FALSE</span>, ...)</span></code></pre></div>
</div>
<div id="mask-attributes-saved-by-make.mask" class="section level3" number="10.10.2">
<h3><span class="header-section-number">10.10.2</span> Mask attributes saved by <code>make.mask</code></h3>
<p>Mask objects generated by <code>make.mask</code> include several attributes not usually on view. Use <code>str</code> to reveal them. Three are simply saved copies of the arguments ‘polygon’, ‘poly.habitat’ and ‘type’, and ‘covariates’ has been discussed already.</p>
<p>The attribute ‘spacing’ is the distance in metres between adjacent grid cell centres in either x- or y- directions.</p>
<p>The attribute ‘area’ is the area of a single grid cell in hectares (1 ha = 10000 m<sup>2</sup>, so area = spacing<sup>2</sup> / 10000; retrieve with <code>attr(mask, 'area')</code>). Use the function <code>maskarea</code> to find the total area of all mask cells; for example, here is the area in hectares of the clipped Waitarere possum mask.</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb129-1"><a href="#cb129-1" tabindex="-1"></a><span class="fu">maskarea</span>(clippedmask)</span></code></pre></div>
<pre><code>## [1] 205.06</code></pre>
<p>The attribute ‘boundingbox’ is a 2-column dataframe with the x- and y-coordinates of the corners of the smallest rectangle containing all grid cells.</p>
<p>The attribute ‘meanSD’ is a 2-column dataframe with the means and standard deviations of the x- and y-coordinates. These are used to standardize the coordinates if they appear directly in a model formula (e.g., D ~ x + y).</p>
</div>
<div id="linear-habitat" class="section level3" number="10.10.3">
<h3><span class="header-section-number">10.10.3</span> Linear habitat</h3>
<p>Models for data from linear habitats analysed in the package <strong>secrlinear</strong> <span class="citation">(<a href="#ref-R-secrlinear">Efford 2023b</a>)</span> use the class ‘linearmask’ that inherits from ‘mask’. Linear masks have additional attributes ‘SLDF’ and ‘graph’ to describe linear habitat networks. See <a href="https://CRAN.R-project.org/package=secrlinear/vignettes/secrlinear-vignette.pdf">secrlinear-vignette.pdf</a> for details.</p>
</div>
<div id="dropping-points-from-a-mask" class="section level3" number="10.10.4">
<h3><span class="header-section-number">10.10.4</span> Dropping points from a mask</h3>
<p>If the mask you want cannot be obtained directly with <code>make.mask</code> then use either <code>subset</code> (batch) or <code>deleteMaskPoints</code> (interactive; unreliable in RStudio). This ensures that the attributes are updated properly. Do not simply extract the required points from the mask dataframe by subscripting (<code>[</code>).</p>
</div>
<div id="multi-session-masks" class="section level3" number="10.10.5">
<h3><span class="header-section-number">10.10.5</span> Multi-session masks</h3>
<p>Fitting a SECR model to a multi-session capthist requires a mask for each session. If a single mask is passed to <code>secr.fit</code> then it will be replicated and must be appropriate for all sessions. The alternative is to provide a list of masks, one per session, in the correct order; <code>make.mask</code> generates such a list from a list of traps objects. See Chapter @ref(Multisession) for details.</p>
</div>
<div id="artificial-habitat-maps" class="section level3" number="10.10.6">
<h3><span class="header-section-number">10.10.6</span> Artificial habitat maps</h3>
<p>Function <code>randomHabitat</code> generates somewhat realistic maps of habitat that may be used in simulations. It assigns mask pixels to ‘habitat’ and ‘non-habitat’ according to an algorithm that clusters habitat cells together. The classification is saved as a covariate in the output mask, from which non-habitat cells may be dropped entirely (this was used to generate the green habitat background in Fig. @ref(fig:masktypes) b).</p>
</div>
<div id="mask-vs-raster" class="section level3" number="10.10.7">
<h3><span class="header-section-number">10.10.7</span> Mask vs raster</h3>
<p>Mask objects have a lot in common with objects of the RasterLayer S4 class defined in the package <strong>raster</strong> <span class="citation">(<a href="#ref-R-raster">Hijmans 2023a</a>)</span>. However, they are much simpler: no projection is specified and grid cells must be square.</p>
<p>A mask object may be exported as a RasterLayer using the <code>raster</code> method defined in <strong>secr</strong> for mask objects. This allows you to nominate a covariate to provide values for the RasterLayer, and to specify a projection.</p>
</div>
</div>
<div id="warnings" class="section level2" number="10.11">
<h2><span class="header-section-number">10.11</span> Warnings</h2>
<p>Use of an inappropriate mask spacing is a common source of problems. Model fitting can be painfully slow if the mask has too many cells. Choose the spacing (cell size) as described in <a href="#maskspacing">Grid cell size…</a>. A single mask for widely scattered clusters of traps should drop cells from wide inter-cluster spaces (set ‘type = trapbuffer’).</p>
<!--chapter:end:08-habitat.Rmd-->
</div>
</div>
<div id="Multisession" class="section level1" number="11">
<h1><span class="header-section-number">11</span> Multiple sessions</h1>
<p>A ‘session’ in <strong>secr</strong> is a block of sampling that may be treated as independent from all other sessions. For example, sessions may correspond to trapping grids that are far enough apart that they sample non-overlapping sets of animals. Multi-session data and models combine data from several sessions. Sometimes this is merely a convenience, but it also enables the fitting of models with parameter values that apply across sessions – data are then effectively pooled with respect to those parameters.</p>
<p>Dealing with multiple sessions adds another layer of complexity, and raises some entirely new issues. This chapter tries for a coherent view of multi-session analyses, covering material that is otherwise scattered.</p>
<div id="input-1" class="section level2" number="11.1">
<h2><span class="header-section-number">11.1</span> Input</h2>
<p>A multi-session capthist object is essentially an R list of single-session capthist objects. We assume the functions <code>read.capthist</code> or <code>make.capthist</code> will be used for data input (simulated data are considered separately later on).</p>
<div id="detections" class="section level3" number="11.1.1">
<h3><span class="header-section-number">11.1.1</span> Detections</h3>
<p>Entering session-specific detections is simple because all detection data are placed in one file or dataframe. Each session uses a character-valued code (the session identifier) in the first column. For demonstration let’s assume you have a file ‘msCHcapt.txt’ with data for 3 sessions, each sampled on 4 occasions.</p>
<pre><code>## # Session ID Occasion Detector sex 
## 1 1 3 H4 f
## 1 10 2 A1 f
## 1 11 4 D2 m
## 1 12 1 B3 f
## .
## .
## 2 1 2 A8 m
## 2 1 4 A8 m
## 2 10 4 A5 f
## 2 11 2 A6 f
## .
## .
## 3 1 4 D6 m
## 3 10 3 A1 m
## 3 11 2 G3 m
## 3 11 4 H6 m
## .
## .</code></pre>
<p>(clipped lines are indicated by ‘. .’).</p>
<p>Given a trap layout file ‘msCHtrap.txt’ with the coordinates of the detector sites (A1, A2 etc.), the following call of <code>read.capthist</code> will construct a single-session capthist object for each unique code value and combine these in a multi-session capthist:</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb132-1"><a href="#cb132-1" tabindex="-1"></a>msCH <span class="ot">&lt;-</span> <span class="fu">read.capthist</span>(<span class="st">&#39;data/msCHcapt.txt&#39;</span>, <span class="st">&#39;data/msCHtrap.txt&#39;</span>, <span class="at">covnames =</span> <span class="st">&#39;sex&#39;</span>)</span></code></pre></div>
<pre><code>## No errors found :-)</code></pre>
<p>Use the <code>summary</code> method or <code>str(msCH)</code> to examine <code>msCH</code>. Session-by-session output from <code>summary</code> can be excessive; the ‘terse’ option gives a more compact summary across sessions (columns).</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb134-1"><a href="#cb134-1" tabindex="-1"></a><span class="fu">summary</span>(msCH, <span class="at">terse =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>##             1  2  3
## Occasions   4  4  4
## Detections 52 55 42
## Animals    31 31 27
## Detectors  64 64 64</code></pre>
<p>Sessions are ordered in <code>msCH</code> according to their identifiers (‘1’ before ‘2’, ‘Albert’ before ‘Beatrice’ etc.). The order becomes important for matching with session-specific trap layouts and masks, as we see later. The vector of session names (identifiers) may be retrieved with <code>session(msCH)</code> or <code>names(msCH)</code>.</p>
</div>
<div id="empty-sessions" class="section level3" number="11.1.2">
<h3><span class="header-section-number">11.1.2</span> Empty sessions</h3>
<p>It is possible for there to be no detections in some sessions (but not all!). To create a session with no detections, include a dummy row with the value of the noncapt argument as the animal identifier; the default noncapt value is ‘NONE’. The dummy row should have occasion number equal to the number of occasions and some nonsense value (e.g. 0) in each of the other fields (trapID etc.).</p>
<p>Including individual covariates as additional columns seems to cause trouble in the present version of secr if some sessions are empty, and should be avoided. We drop them from the example file ‘msCHcapt2.txt’:</p>
<pre><code>## # Session ID Occasion Detector
## 1 19 2 A1
## 1 28 2 A5
## 1 37 2 A6
## .
## .
## 3 25 1 A5
## 3 16 4 A5
## 3 21 3 A6
## 3 6 1 A7
## .
## .
## 4 NONE 4 0</code></pre>
<p>Then,</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb137-1"><a href="#cb137-1" tabindex="-1"></a>msCH2 <span class="ot">&lt;-</span> <span class="fu">read.capthist</span>(<span class="st">&#39;data/msCHcapt2.txt&#39;</span>, <span class="st">&#39;data/msCHtrap.txt&#39;</span>)</span></code></pre></div>
<pre><code>## Session 4 
## No live releases</code></pre>
<div class="sourceCode" id="cb139"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb139-1"><a href="#cb139-1" tabindex="-1"></a><span class="fu">summary</span>(msCH2, <span class="at">terse =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>##             1  2  3  4
## Occasions   4  4  4  4
## Detections 63 52 50  0
## Animals    39 29 31  0
## Detectors  64 64 64 64</code></pre>
<p>Empty sessions trigger an error in <code>verify.capthist</code>; to fit a model suppress verification (e.g., <code>secr.fit(msCH2, verify = FALSE)</code>).</p>
<p>If the first session is empty then either direct the <code>autoini</code> option to a later session with e.g., <code>details = list(autoini = 2)</code> or provide initial values manually in the <code>start</code> argument.</p>
</div>
<div id="detector-layouts" class="section level3" number="11.1.3">
<h3><span class="header-section-number">11.1.3</span> Detector layouts</h3>
<p>All sessions may share the same detector layout. Then the ‘trapfile’ argument of <code>read.capthist</code> is a single name, as in the example above. The trap layout is repeated as an attribute of each component (single-session) capthist.</p>
<p>Alternatively, each session may have its own detector layout. Unlike the detection data, each session-specific layout is specified in a separate input file or traps object. For <code>read.capthist</code> the ‘trapfile’ argument is then a vector of file names, one for each session. For <code>make.capthist</code>, the ‘traps’ argument may be a list of traps objects, one per session. The first trap layout is used for the first session, the second for the second session, etc.</p>
</div>
</div>
<div id="manipulation" class="section level2" number="11.2">
<h2><span class="header-section-number">11.2</span> Manipulation</h2>
<p>The standard extraction and manipulation functions of <strong>secr</strong> (<code>summary</code>, <code>verify</code>, <code>covariates</code>, <code>subset</code>, <code>reduce</code> etc.) mostly allow for multi-session input, applying the manipulation to each component session in turn. The function <code>ms</code> returns TRUE if its argument is a multi-session object and FALSE otherwise.</p>
<p>Plotting a multi-session capthist object (e.g., <code>plot(msCH)</code>) will create one new plot for each session unless you specify <code>add = TRUE</code>.</p>
<p>Methods that extract attributes from multi-session capthist object will generally return a list in which each component is the result from one session. Thus for the ovenbird mistnetting data <code>traps(ovenCH)</code> extracts a list of 5 traps objects, one for each annual session 2005–2009.</p>
<p>The <code>subset</code> method for capthist objects has a ‘sessions’ argument for selecting particular session(s) of a multi-session object.</p>
<table>
<caption>(#tab:multisession) Manipulation of multi-session capthist objects.</caption>
<colgroup>
<col width="15%" />
<col width="27%" />
<col width="30%" />
<col width="26%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">Purpose</th>
<th align="left">Input</th>
<th align="left">Output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>join</code></td>
<td align="left">collapse sessions</td>
<td align="left">multi-session capthist</td>
<td align="left">single-session capthist</td>
</tr>
<tr class="even">
<td align="left"><code>MS.capthist</code></td>
<td align="left">build multi-session capthist</td>
<td align="left">several single-session capthist</td>
<td align="left">multi-session capthist</td>
</tr>
<tr class="odd">
<td align="left"><code>split</code></td>
<td align="left">subdivide capthist</td>
<td align="left">single-session capthist</td>
<td align="left">multi-session capthist</td>
</tr>
</tbody>
</table>
<p>The <code>split</code> method for capthist objects (<code>?split.capthist</code>) may be used to break a single-session capthist object into a multi-session object, segregating detections by some attribute of the individuals, or by occasion or detector groupings.</p>
</div>
<div id="fitting" class="section level2" number="11.3">
<h2><span class="header-section-number">11.3</span> Fitting</h2>
<p>Given multi-session capthist input, <code>secr.fit</code> automatically fits a multi-session model by maximizing the product of session-specific likelihoods <span class="citation">(<a href="#ref-ebb09">Efford, Borchers, and Byrom 2009</a>)</span>. For fitting a model separately to each session see the later section on <a href="#fasterfitting">Faster fitting…</a>.</p>
<div id="habitat-masks" class="section level3" number="11.3.1">
<h3><span class="header-section-number">11.3.1</span> Habitat masks</h3>
<p>The default mechanism for constructing a habitat mask in <code>secr.fit</code> is to buffer around the trap layout. This extends to multi-session data; buffering is applied to each trap layout in turn.</p>
<p>Override the default buffering mechanism by specifying the ‘mask’ argument of <code>secr.fit</code>. This is necessary if you want to –</p>
<ol style="list-style-type: decimal">
<li>reduce or increase mask spacing (pixel size; default 1/64 x-range)</li>
<li>clip the mask to exclude non-habitat</li>
<li>include mask covariates (predictors of local density)</li>
<li>define non-Euclidean distances (Appendix @ref(Noneuclidean))</li>
<li>specify a rectangular mask (type = “traprect” vs type = “trapbuffer”)</li>
</ol>
<p>For any of these you are likely to use the <code>make.mask</code> function (the manual alternative is usually too painful to contemplate). If <code>make.mask</code> is provided with a list of traps objects as its ‘traps’ argument then the result is a list of mask objects - effectively, a multi-session mask.</p>
<p>If <code>addCovariates</code> receives a list of masks and a single spatial data source then it will add the requested covariate(s) to each mask and return a new list of masks. The single spatial data source is expected to span all the regions; mask points that are not covered receive NA covariate values. As an alternative to a single spatial data source, the <code>spatialdata</code> argument may be a list of spatial data sources, one per mask, in the order of the sessions in the corresponding capthist object.</p>
<p>To eliminate any doubt about the matching of session-specific masks to session-specific detector arrays it is always worth plotting one over the other. We don’t have an interesting example, but</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb141-1"><a href="#cb141-1" tabindex="-1"></a>masks <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(<span class="fu">traps</span>(msCH), <span class="at">buffer =</span> <span class="dv">80</span>, <span class="at">nx =</span> <span class="dv">32</span>, <span class="at">type =</span> <span class="st">&#39;trapbuffer&#39;</span>)</span>
<span id="cb141-2"><a href="#cb141-2" tabindex="-1"></a><span class="fu">par</span> (<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>), <span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">1</span>))</span>
<span id="cb141-3"><a href="#cb141-3" tabindex="-1"></a><span class="cf">for</span> (sess <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(msCH)) {</span>
<span id="cb141-4"><a href="#cb141-4" tabindex="-1"></a>    <span class="fu">plot</span>(masks[[sess]])</span>
<span id="cb141-5"><a href="#cb141-5" tabindex="-1"></a>    <span class="fu">plot</span>(<span class="fu">traps</span>(msCH)[[sess]], <span class="at">add =</span> <span class="cn">TRUE</span>)</span>
<span id="cb141-6"><a href="#cb141-6" tabindex="-1"></a>    <span class="fu">mtext</span>(<span class="at">side=</span><span class="dv">3</span>, <span class="fu">paste</span>(<span class="st">&#39;session&#39;</span>, sess))</span>
<span id="cb141-7"><a href="#cb141-7" tabindex="-1"></a>}</span></code></pre></div>
<p><img src="SECRbook_files/figure-html/plotmasks-1.png" width="864" /></p>
</div>
<div id="session-models" class="section level3" number="11.3.2">
<h3><span class="header-section-number">11.3.2</span> Session models</h3>
<p>The default in <code>secr.fit</code> is to treat all parameters as constant across sessions. For detection functions parameterized in terms of cumulative hazard (e.g., ‘HHN’ or ‘HEX’) this is equivalent to <code>model = list(D ~ 1, lambda0 ~ 1, sigma ~ 1)</code>. Two automatic predictors are provided specifically for multi-session models: ‘session’ and ‘Session’.</p>
<div id="session-stratified-estimates" class="section level4" number="11.3.2.1">
<h4><span class="header-section-number">11.3.2.1</span> Session-stratified estimates</h4>
<p>A model with lowercase ‘session’ fits a distinct value of the parameter (D, g0, lambda0, sigma) for each level of <code>factor(session(msCH))</code>.</p>
</div>
<div id="session-covariates" class="section level4" number="11.3.2.2">
<h4><span class="header-section-number">11.3.2.2</span> Session covariates</h4>
<p>Other variation among sessions may be modelled with session-specific covariates. These are provided to <code>secr.fit</code> on-the-fly in the argument ‘sessioncov’ (they cannot be embedded in the capthist object like detector or individual covariates). The value for ‘sessioncov’ should be a dataframe with one row per session. Each column is a potential predictor in a model formula; other columns are ignored.</p>
<p>Session covariates are extremely flexible. The linear trend of the ‘Session’ predictor may be emulated by defining a covariate <code>sessnum = 0:(R-1)</code> where <code>R</code> is the number of sessions. Sessions of different types may be distinguished by a factor-valued covariate. Supposing for the ovenbird dataset we wished to distinguish years 2005 and 2006 from 2007, 2008 and 2009, we could use <code>earlylate = factor(c('early','early','late','late','late'))</code>. Quantitative habitat attributes might also be coded as session covariates.</p>
</div>
<div id="simpletrend" class="section level4" number="11.3.2.3">
<h4><span class="header-section-number">11.3.2.3</span> Trend across sessions</h4>
<p>
</p>
<p><strong>secr</strong> is primarily for estimating closed population density (density at one point in time), but multi-session data may also be modelled to describe population trend over time. A trend model for density may be interesting if the sessions fall in some natural sequence, such as a series of annual samples (as in the ovenbird dataset ovenCH). A model with initial uppercase ‘Session’ fits a <em>trend</em> across sessions using the session number as the predictor. The fitted trend is linear on the link scale; using the default link function for density (‘log’) this corresponds to exponential growth or decline if samples are equally spaced in time.</p>
<p>The pre-fitted model <code>ovenbird.model.D</code> provides an example. The coefficient ‘D.Session’ is the rate of change in log(D):</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb142-1"><a href="#cb142-1" tabindex="-1"></a><span class="fu">coef</span>(ovenbird.model.D)</span></code></pre></div>
<pre><code>##                beta  SE.beta      lcl       ucl
## D          0.031710 0.191460 -0.34354  0.406964
## D.Session -0.063859 0.070152 -0.20135  0.073636
## g0        -3.561926 0.150623 -3.85714 -3.266712
## sigma      4.364108 0.081148  4.20506  4.523156</code></pre>
<p>The overall finite rate of increase (equivalent to Pradel’s lambda) is given by</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb144-1"><a href="#cb144-1" tabindex="-1"></a>beta <span class="ot">&lt;-</span> <span class="fu">coef</span>(ovenbird.model.D)[<span class="st">&#39;D.Session&#39;</span>,<span class="st">&#39;beta&#39;</span>]</span>
<span id="cb144-2"><a href="#cb144-2" tabindex="-1"></a>sebeta <span class="ot">&lt;-</span> <span class="fu">coef</span>(ovenbird.model.D)[<span class="st">&#39;D.Session&#39;</span>,<span class="st">&#39;SE.beta&#39;</span>]</span>
<span id="cb144-3"><a href="#cb144-3" tabindex="-1"></a><span class="fu">exp</span>(beta)</span></code></pre></div>
<pre><code>## [1] 0.93814</code></pre>
<p>Confidence intervals may also be back-transformed with <code>exp</code>. To back-transform the SE use the delta-method approximation <code>exp(beta) * sqrt(exp(sebeta^2)-1)</code> = 0.06589.</p>
<p>This is fine for a single overall lambda. However, if you are interested in successive estimates (session 1 to session 2, session 2 to session 3 etc.) the solution is slightly more complicated. Here we describe a simple option using ‘backward difference’ coding of the levels of the factor session, specified with the details argument ‘contrasts’. This coding is provided by the function <code>contr.sdif</code> in the MASS package (e.g., Venables and Ripley 1999 Section 6.2).</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb146-1"><a href="#cb146-1" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ovenCH, <span class="at">model =</span> D<span class="sc">~</span>session, <span class="at">buffer =</span> <span class="dv">300</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>,</span>
<span id="cb146-2"><a href="#cb146-2" tabindex="-1"></a>    <span class="at">details =</span> <span class="fu">list</span>(<span class="at">contrasts =</span> <span class="fu">list</span>(<span class="at">session =</span> MASS<span class="sc">::</span>contr.sdif)))</span>
<span id="cb146-3"><a href="#cb146-3" tabindex="-1"></a><span class="fu">coef</span>(fit)</span></code></pre></div>
<p>A more sophisticated version is provided in Appendix @ref(Trend).</p>
</div>
</div>
</div>
<div id="simulation" class="section level2" number="11.4">
<h2><span class="header-section-number">11.4</span> Simulation</h2>
<p>Back at the start of this document we used <code>sim.capthist</code> to generate <code>msCH</code>, a simple multi-session capthist. Here we look at various extensions. Generating SECR data is a 2-stage process. The first stage simulates the locations of animals to create an object of class ‘popn’; the second stage generates samples from that population according to a particular sampling regime (detector array, number of occasions etc.).</p>
<div id="simulating-multi-session-populations" class="section level3" number="11.4.1">
<h3><span class="header-section-number">11.4.1</span> Simulating multi-session populations</h3>
<p>By default <code>sim.capthist</code> uses <code>sim.popn</code> to generate a new population independently for each session. Centres are placed within a rectangular region obtained by buffering around a ‘core’ (the traps object passed to <code>sim.capthist</code>).</p>
<p>The session-specific populations may also be prepared in advance as a list of ‘popn’ objects (use nsessions &gt; 1 in <code>sim.popn</code>). This allows greater control. In particular, the population density may be varied among sessions by making argument D a vector of session-specific densities. Other arguments of <code>sim.popn</code> do not yet accept multi-session input – it might be useful for ‘core’ to accept a list of traps objects (or a list of mask objects if model2D = “IHP”).</p>
<p>We can also put aside the basic assumption of independence among sessions and simulate a single population open to births, deaths and movement between sessions. This does not correspond to any model that can be fitted in <code>secr</code>, but it allows the effects of non-independence to be examined. See <code>?turnover</code> for further explanation.</p>
</div>
<div id="multi-session-sampling" class="section level3" number="11.4.2">
<h3><span class="header-section-number">11.4.2</span> Multi-session sampling</h3>
<p>A multi-session population prepared in advance is passed as the popn argument of <code>sim.capthist</code>, replacing the usual list (D, buffer etc.).</p>
<p>The argument ‘traps’ may be a list of length equal to nsessions. Each component potentially differs not just in detector locations, but also with respect to detector type (‘detector’) and resighting regime (‘markocc’). The argument ‘noccasions’ may also be a vector with a different number of occasions in each session.</p>
</div>
</div>
<div id="problems" class="section level2" number="11.5">
<h2><span class="header-section-number">11.5</span> Problems</h2>
<p>There are problems specific to multi-session data.</p>
<div id="failure-of-autoini" class="section level3" number="11.5.1">
<h3><span class="header-section-number">11.5.1</span> Failure of autoini</h3>
<p>Numerical maximization of the likelihood requires a starting set of parameter values. This is either computed internally with the function <code>autoini</code> or provided by the user. Given multi-session data, the default procedure is for <code>secr.fit</code> to apply <code>autoini</code> to the first session only. If the data for that session are inadequate or result in parameter estimates that are extreme with respect to the remaining sessions then model fitting may abort. One solution is to provide start values manually, but that can be laborious. A quick fix is often to switch the session used to compute starting values by changing the details option ‘autoini’. For example</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb147-1"><a href="#cb147-1" tabindex="-1"></a>fit0 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ovenCH, <span class="at">mask =</span> msk, <span class="at">details =</span> <span class="fu">list</span>(<span class="at">autoini =</span> <span class="dv">2</span>), <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>A further option is to combine the session data into a single-session capthist object with <code>details = list(autoini = "all")</code>; the combined capthist is used only by <code>autoini</code>.</p>
</div>
<div id="covariates-with-incompatible-factor-levels" class="section level3" number="11.5.2">
<h3><span class="header-section-number">11.5.2</span> Covariates with incompatible factor levels</h3>
<p>Individual or detector covariates used in a multi-session model obviously must appear in each of the component sessions. It is less obvious, and sometimes annoying, that a factor (categorical) covariate should have exactly the same levels in the same order in each component session. The <code>verify</code> methods for capthist objects checks that this is in fact the case (remember that <code>verify</code> is called by <code>secr.fit</code> unless you suppress it).</p>
<p>A common example might be an individual covariate ‘sex’ with the levels “f” and “m”. If by chance only males are detected in one of the sessions, and as a result the factor has a single level “m” in that session, then <code>verify</code> will give a warning.</p>
<p>The solution is to force all sessions to use the same factor levels. The function <code>shareFactorLevels</code> is provided for this purpose.</p>
</div>
</div>
<div id="fasterfitting" class="section level2" number="11.6">
<h2><span class="header-section-number">11.6</span> Speed</h2>
<p>Fitting a multi-session model with each parameter stratified by session is unnecessarily slow. In this case no data are pooled across sessions and it is better to fit each session separately. If your data are already in a multi-session capthist object then the speedy solution is</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb148-1"><a href="#cb148-1" tabindex="-1"></a>fits <span class="ot">&lt;-</span> <span class="fu">lapply</span>(ovenCH, secr.fit, <span class="at">mask =</span> msk, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb148-2"><a href="#cb148-2" tabindex="-1"></a><span class="fu">class</span>(fits) <span class="ot">&lt;-</span> <span class="st">&#39;secrlist&#39;</span></span>
<span id="cb148-3"><a href="#cb148-3" tabindex="-1"></a><span class="fu">predict</span>(fits)</span></code></pre></div>
<pre><code>## $`2005`
##        link   estimate SE.estimate        lcl         ucl
## D       log  0.8470512   0.3052967  0.4270073   1.6802889
## g0    logit  0.0232638   0.0081941  0.0116112   0.0460657
## sigma   log 88.0547834  19.3632001 57.5147945 134.8113115
## 
## $`2006`
##        link   estimate SE.estimate        lcl        ucl
## D       log  1.0269346   0.2936838  0.5927662  1.7791074
## g0    logit  0.0301267   0.0092786  0.0163967  0.0547144
## sigma   log 73.0194401  11.7105482 53.4308605 99.7894958
## 
## $`2007`
##        link   estimate SE.estimate        lcl         ucl
## D       log  1.0779686  0.28808051  0.6442276   1.8037356
## g0    logit  0.0347638  0.00932753  0.0204598   0.0584709
## sigma   log 76.0913073 11.51819506 56.6519567 102.2010073
## 
## $`2008`
##        link   estimate SE.estimate        lcl        ucl
## D       log  1.4680979   0.4886900  0.7777202  2.7713201
## g0    logit  0.0282982   0.0112531  0.0128898  0.0609879
## sigma   log 52.2235113  10.4785159 35.3799419 77.0859132
## 
## $`2009`
##        link   estimate SE.estimate        lcl         ucl
## D       log  0.5335786  0.19969184  0.2624320   1.0848756
## g0    logit  0.0245406  0.00877139  0.0121196   0.0490595
## sigma   log 98.4486255 22.10810940 63.7390897 152.0594648</code></pre>
<p>The first line (<code>lapply</code>) creates a list of ‘secr’ objects. The <code>predict</code> method works once we set the class attribute to ‘secrlist’ (or you could <code>lapply(fits, predict)</code>).</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb150-1"><a href="#cb150-1" tabindex="-1"></a>fits2 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ovenCH, <span class="at">model=</span><span class="fu">list</span>(D<span class="sc">~</span>session, g0<span class="sc">~</span>session, </span>
<span id="cb150-2"><a href="#cb150-2" tabindex="-1"></a>    sigma<span class="sc">~</span>session), <span class="at">mask =</span> msk, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>What if we wish to compare ths model with a less general one (i.e. with some parameter values shared across sessions)? For that we need the number of parameters, log likelihood and AIC summed across sessions:</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb151-1"><a href="#cb151-1" tabindex="-1"></a><span class="fu">apply</span>(<span class="fu">AIC</span>(fits)[,<span class="dv">3</span><span class="sc">:</span><span class="dv">5</span>],<span class="dv">2</span>,sum)</span></code></pre></div>
<pre><code>##   npar logLik    AIC 
##   15.0 -925.9 1881.8</code></pre>
<div class="sourceCode" id="cb153"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb153-1"><a href="#cb153-1" tabindex="-1"></a><span class="fu">AIC</span>(fits2)[,<span class="dv">3</span><span class="sc">:</span><span class="dv">5</span>]</span></code></pre></div>
<pre><code>##       npar logLik   AIC
## fits2   15 -1e+10 2e+10</code></pre>
<p>AICc is not a simple sum of session-specific AICc and should be calculated manually (hint: use <code>sapply(ovenCH, nrow)</code> for session-specific sample sizes).</p>
<p>The unified model fit and separate model fits with <code>lapply</code> give essentially the same answers, and the latter approach is faster by a factor of 15.</p>
<p>Using <code>lapply</code> does not work if some arguments of <code>secr.fit</code> other than ‘capthist’ themselves differ among sessions (as when ‘mask’ is a list of session-specific masks). Then we can use either a ‘for’ loop or the slightly more demanding function <code>mapply</code>, with the same gain in speed.</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb155-1"><a href="#cb155-1" tabindex="-1"></a><span class="co"># one mask per session</span></span>
<span id="cb155-2"><a href="#cb155-2" tabindex="-1"></a>masks <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(<span class="fu">traps</span>(ovenCH), <span class="at">buffer =</span> <span class="dv">300</span>, <span class="at">nx =</span> <span class="dv">32</span>, </span>
<span id="cb155-3"><a href="#cb155-3" tabindex="-1"></a>    <span class="at">type =</span> <span class="st">&#39;trapbuffer&#39;</span>)  </span>
<span id="cb155-4"><a href="#cb155-4" tabindex="-1"></a>fits3 <span class="ot">&lt;-</span> <span class="fu">list.secr.fit</span>(ovenCH, <span class="at">mask =</span> masks, <span class="at">constant =</span> </span>
<span id="cb155-5"><a href="#cb155-5" tabindex="-1"></a>    <span class="fu">list</span>(<span class="at">trace =</span> <span class="cn">FALSE</span>))</span></code></pre></div>
</div>
<div id="caveats" class="section level2" number="11.7">
<h2><span class="header-section-number">11.7</span> Caveats</h2>
<div id="independence-is-a-strong-assumption" class="section level3" number="11.7.1">
<h3><span class="header-section-number">11.7.1</span> Independence is a strong assumption</h3>
<p>If sessions are not truly independent then expect confidence intervals to be too short. This is especially likely when a trend model is fitted to temporal samples with incomplete population turnover between sessions. The product likelihood assumes a new realisation of the underlying population process for each session. If in actuality much of the sampled population remains the same (the same individuals in the same home ranges) then the precision of the trend coefficient will be overstated. Either an open population model is needed (e.g., <strong>openCR</strong> <span class="citation">(<a href="#ref-es20">Efford and Schofield 2020</a>)</span>) or extra work will be needed to obtain credible confidence limits for the trend (probably some form of bootstrapping).</p>
</div>
<div id="parameters-are-assumed-constant-by-default" class="section level3" number="11.7.2">
<h3><span class="header-section-number">11.7.2</span> Parameters are assumed constant by default</h3>
<p>Output from <code>predict.secr</code> for a multi-session model is automatically stratified by session even when the model does not include ‘session’, ‘Session’ or any session covariate as a predictor (the output simply repeats the constant estimates for each session).</p>
<!--chapter:end:08-multisession.Rmd-->
</div>
</div>
</div>
<div id="sex" class="section level1" number="12">
<h1><span class="header-section-number">12</span> Sex differences</h1>
<p>It is common for males and females to differ in their behaviour in relation to detectors. Sex is commonly recorded for trapped animals or those detected with automatic cameras, and hair samples used to identify individuals by their DNA can also reveal sex given suitable sex-specific markers. SECR models that allow for sex differences are therefore of particular interest.</p>
<p>There are many ways to model sex differences in <strong>secr</strong>, and each of these has already been mentioned in a general context. Here we enumerate the possibilities and comment on their usefulness.</p>
<p>Unlike some effects, the relevance of sex may be obvious from the beginning. You may therefore be happy to structure other aspects of the model around your chosen way to include sex. Alternately, other desiderata may constrain the treatment of sex. The example below shows that several different ways of including sex lead to the same estimates.</p>
<div id="models-2" class="section level2" number="12.1">
<h2><span class="header-section-number">12.1</span> Models</h2>
<p>We list the possible models in order of usefulness (your mileage may vary; see also the <a href="#decisionchart">decision chart</a> below):</p>
<ol style="list-style-type: decimal">
<li>Hybrid mixture model</li>
<li>Conditional likelihood with individual covariate</li>
<li>Separate sessions</li>
<li>Full likelihood with groups</li>
</ol>
<div id="hybrid-mixtures-1" class="section level3" number="12.1.1">
<h3><span class="header-section-number">12.1.1</span> Hybrid mixtures</h3>
<p>This accommodates occasional missing values and estimates the sex ratio as a parameter (pmix). The method works for both conditional and full likelihood. If estimated (<code>CL = FALSE</code>) density <span class="math inline">\(D\)</span> is common to the two classes.</p>
</div>
<div id="individual-covariate" class="section level3" number="12.1.2">
<h3><span class="header-section-number">12.1.2</span> Individual covariate</h3>
<p>Including an individual covariate in the model directly requires conditional likelihood (<code>CL = TRUE</code>). Spatial variation in density cannot be modelled. include a categorical (factor) covariate in model formulae (e.g., g0 <span class="math inline">\(\sim\)</span>
sex). To get sex-specific densities then specify <code>groups = "sex"</code> in <code>derived</code>.</p>
</div>
<div id="sex-as-session" class="section level3" number="12.1.3">
<h3><span class="header-section-number">12.1.3</span> Sex as session</h3>
<p>It is possible to model data for the two sexes as different sessions (most easily, by coding ‘female’ or ‘male’ in the first column of the capture file read with <code>read.capthist</code>). Sex differences are then modelled by including a ‘session’ term in relevant model formulae (e.g., g0 <span class="math inline">\(\sim\)</span> session).</p>
</div>
<div id="groups-1" class="section level3" number="12.1.4">
<h3><span class="header-section-number">12.1.4</span> Groups</h3>
<p><a href="#groups">Groups</a> were described earlier. Use full likelihood (<code>CL = FALSE</code>), define <code>groups = "sex"</code> or similar, and include a group term ‘g’ in relevant formulae (e.g., g0 <span class="math inline">\(\sim\)</span> g).</p>
<p>‘CL’ and ‘groups’ are arguments of <code>secr.fit</code>.</p>
</div>
</div>
<div id="demonstration" class="section level2" number="12.2">
<h2><span class="header-section-number">12.2</span> Demonstration</h2>
<p>We re-analyse the morning house mouse data already analysed in Chapter @ref(individual-heterogeneity). For all methods except ‘hybrid mixtures we have to discard one individual of unknown sex (hence capthist marked with ’x’). Close inspection of the results shows that the methods are equivalent.</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb156-1"><a href="#cb156-1" tabindex="-1"></a>morning <span class="ot">&lt;-</span> <span class="fu">subset</span>(housemouse, <span class="at">occ =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>)) <span class="co"># includes one mouse with sex unknown</span></span>
<span id="cb156-2"><a href="#cb156-2" tabindex="-1"></a>morningx <span class="ot">&lt;-</span> <span class="fu">subset</span>(housemouse, <span class="sc">!</span><span class="fu">is.na</span>(<span class="fu">covariates</span>(housemouse)<span class="sc">$</span>sex), <span class="at">occ =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>))</span>
<span id="cb156-3"><a href="#cb156-3" tabindex="-1"></a>morningxs <span class="ot">&lt;-</span> <span class="fu">split</span>(morningx, <span class="fu">covariates</span>(morningx)<span class="sc">$</span>sex)  <span class="co"># split into two sessions</span></span></code></pre></div>
<div class="sourceCode" id="cb157"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb157-1"><a href="#cb157-1" tabindex="-1"></a><span class="co"># conditional likelihood</span></span>
<span id="cb157-2"><a href="#cb157-2" tabindex="-1"></a>hybridxCL  <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(morningx, <span class="at">model =</span> <span class="fu">list</span>(lambda0<span class="sc">~</span>h2, sigma<span class="sc">~</span>h2),</span>
<span id="cb157-3"><a href="#cb157-3" tabindex="-1"></a>             <span class="at">CL =</span> <span class="cn">TRUE</span>, <span class="at">buffer =</span> <span class="dv">25</span>, <span class="at">detectfn =</span> <span class="st">&#39;HEX&#39;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>,  <span class="at">hcov =</span> <span class="st">&#39;sex&#39;</span>)</span>
<span id="cb157-4"><a href="#cb157-4" tabindex="-1"></a>xCL        <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(morningx, <span class="at">model =</span> <span class="fu">list</span>(lambda0<span class="sc">~</span>sex, sigma<span class="sc">~</span>sex), </span>
<span id="cb157-5"><a href="#cb157-5" tabindex="-1"></a>             <span class="at">CL =</span> <span class="cn">TRUE</span>, <span class="at">buffer =</span> <span class="dv">25</span>, <span class="at">detectfn =</span> <span class="st">&#39;HEX&#39;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb157-6"><a href="#cb157-6" tabindex="-1"></a>sessionxCL <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(morningxs, <span class="at">model =</span> <span class="fu">list</span>(lambda0<span class="sc">~</span>session, sigma<span class="sc">~</span>session), </span>
<span id="cb157-7"><a href="#cb157-7" tabindex="-1"></a>             <span class="at">CL =</span> <span class="cn">TRUE</span>, <span class="at">buffer =</span> <span class="dv">25</span>, <span class="at">detectfn =</span> <span class="st">&#39;HEX&#39;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<div class="sourceCode" id="cb158"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb158-1"><a href="#cb158-1" tabindex="-1"></a>fitsCL <span class="ot">&lt;-</span> <span class="fu">secrlist</span>(hybridxCL,xCL,sessionxCL)</span>
<span id="cb158-2"><a href="#cb158-2" tabindex="-1"></a><span class="fu">predict</span>(fitsCL, <span class="at">all.levels =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## $hybridxCL
## $hybridxCL$`session = coulombe, h2 = f`
##          link estimate SE.estimate     lcl     ucl
## lambda0   log  0.28819    0.041538 0.21758 0.38171
## sigma     log  2.17887    0.153222 1.89866 2.50043
## pmix    logit  0.46619    0.043007 0.38363 0.55064
## 
## $hybridxCL$`session = coulombe, h2 = m`
##          link estimate SE.estimate     lcl     ucl
## lambda0   log  0.20098    0.036023 0.14183 0.28478
## sigma     log  2.05123    0.173553 1.73830 2.42051
## pmix    logit  0.53381    0.043007 0.44936 0.61637
## 
## 
## $xCL
## $xCL$`session = coulombe, sex = f`
##         link estimate SE.estimate     lcl     ucl
## lambda0  log  0.28819    0.041539 0.21758 0.38171
## sigma    log  2.17887    0.153222 1.89866 2.50043
## 
## $xCL$`session = coulombe, sex = m`
##         link estimate SE.estimate     lcl     ucl
## lambda0  log  0.20098    0.036023 0.14183 0.28478
## sigma    log  2.05123    0.173555 1.73830 2.42051
## 
## 
## $sessionxCL
## $sessionxCL$`session = f`
##         link estimate SE.estimate     lcl     ucl
## lambda0  log  0.28818    0.041538 0.21758 0.38171
## sigma    log  2.17887    0.153223 1.89866 2.50044
## 
## $sessionxCL$`session = m`
##         link estimate SE.estimate     lcl     ucl
## lambda0  log  0.20098    0.036023 0.14184 0.28478
## sigma    log  2.05123    0.173554 1.73829 2.42050</code></pre>
<div class="sourceCode" id="cb160"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb160-1"><a href="#cb160-1" tabindex="-1"></a><span class="co"># full likelihood</span></span>
<span id="cb160-2"><a href="#cb160-2" tabindex="-1"></a>hybridx  <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(morningx, <span class="at">model =</span> <span class="fu">list</span>(lambda0<span class="sc">~</span>h2, sigma<span class="sc">~</span>h2), <span class="at">hcov =</span> <span class="st">&#39;sex&#39;</span>, </span>
<span id="cb160-3"><a href="#cb160-3" tabindex="-1"></a>             <span class="at">CL =</span> <span class="cn">FALSE</span>, <span class="at">buffer =</span> <span class="dv">25</span>, <span class="at">detectfn =</span> <span class="st">&#39;HEX&#39;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb160-4"><a href="#cb160-4" tabindex="-1"></a>sessionx <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(morningxs, <span class="at">model =</span> <span class="fu">list</span>(D <span class="sc">~</span> session, lambda0<span class="sc">~</span>session, sigma<span class="sc">~</span>session), </span>
<span id="cb160-5"><a href="#cb160-5" tabindex="-1"></a>             <span class="at">CL =</span> <span class="cn">FALSE</span>, <span class="at">buffer =</span> <span class="dv">25</span>, <span class="at">detectfn =</span> <span class="st">&#39;HEX&#39;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb160-6"><a href="#cb160-6" tabindex="-1"></a>groupx   <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(morningx, <span class="at">model =</span> <span class="fu">list</span>(D <span class="sc">~</span> g, lambda0<span class="sc">~</span>g, sigma<span class="sc">~</span>g), <span class="at">groups =</span> <span class="st">&#39;sex&#39;</span>, </span>
<span id="cb160-7"><a href="#cb160-7" tabindex="-1"></a>             <span class="at">CL =</span> <span class="cn">FALSE</span>, <span class="at">buffer =</span> <span class="dv">25</span>, <span class="at">detectfn =</span> <span class="st">&#39;HEX&#39;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<div class="sourceCode" id="cb161"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb161-1"><a href="#cb161-1" tabindex="-1"></a>fits <span class="ot">&lt;-</span> <span class="fu">secrlist</span>(hybridx,sessionx, groupx)</span>
<span id="cb161-2"><a href="#cb161-2" tabindex="-1"></a><span class="fu">predict</span>(fits, <span class="at">all.levels =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## $hybridx
## $hybridx$`session = coulombe, h2 = f`
##          link   estimate SE.estimate        lcl        ucl
## D         log 1296.94076  112.480090 1094.55108 1536.75363
## lambda0   log    0.28819    0.041538    0.21758    0.38171
## sigma     log    2.17887    0.153221    1.89866    2.50043
## pmix    logit    0.46619    0.043007    0.38363    0.55064
## 
## $hybridx$`session = coulombe, h2 = m`
##          link   estimate SE.estimate        lcl        ucl
## D         log 1296.94076  112.480090 1094.55108 1536.75363
## lambda0   log    0.20098    0.036023    0.14183    0.28478
## sigma     log    2.05123    0.173553    1.73830    2.42051
## pmix    logit    0.53381    0.043007    0.44936    0.61637
## 
## 
## $sessionx
## $sessionx$`session = f`
##         link  estimate SE.estimate       lcl       ucl
## D        log 604.61521   72.458457 478.44563 764.05661
## lambda0  log   0.28819    0.041538   0.21758   0.38171
## sigma    log   2.17887    0.153220   1.89866   2.50043
## 
## $sessionx$`session = m`
##         link  estimate SE.estimate       lcl       ucl
## D        log 692.32657   86.800479 542.01013 884.33047
## lambda0  log   0.20098    0.036023   0.14184   0.28478
## sigma    log   2.05123    0.173552   1.73830   2.42050
## 
## 
## $groupx
## $groupx$`session = coulombe, g = f`
##         link  estimate SE.estimate       lcl       ucl
## D        log 604.61717   72.458601 478.44733 764.05888
## lambda0  log   0.28819    0.041538   0.21758   0.38171
## sigma    log   2.17887    0.153220   1.89866   2.50043
## 
## $groupx$`session = coulombe, g = m`
##         link  estimate SE.estimate       lcl       ucl
## D        log 692.32723   86.800609 542.01058 884.33143
## lambda0  log   0.20098    0.036023   0.14183   0.28478
## sigma    log   2.05123    0.173552   1.73830   2.42050</code></pre>
<p>Execution time varies considerably:</p>
<pre><code>## Timing, conditional likelihood</code></pre>
<pre><code>##  hybridxCL.elapsed        xCL.elapsed sessionxCL.elapsed 
##               7.50               4.30              24.03</code></pre>
<pre><code>## Timing, full likelihood</code></pre>
<pre><code>##  hybridx.elapsed sessionx.elapsed   groupx.elapsed 
##            12.70            50.97            10.13</code></pre>
</div>
<div id="decisionchart" class="section level2" number="12.3">
<h2><span class="header-section-number">12.3</span> Choosing a model</h2>
<div id="sex-specific-detection" class="section level3" number="12.3.1">
<h3><span class="header-section-number">12.3.1</span> Sex-specific detection</h3>
<p>We suggest the decision chart in Fig. @ref(fig:chart). This omits ‘session’ approaches that we previously included for <a href="#demonstration">comparison</a>, because they are rather slow and clunky and group models are equivalent.</p>
<div class="figure">
<img src="figures/chart.png" alt="Decision chart for including sex in detection model. 'sexcov' is a character value naming a 2-level character or factor individual covariate" width="95%" />
<p class="caption">
(#fig:chart)Decision chart for including sex in detection model. ‘sexcov’ is a character value naming a 2-level character or factor individual covariate
</p>
</div>
</div>
<div id="sex-specific-density" class="section level3" number="12.3.2">
<h3><span class="header-section-number">12.3.2</span> Sex-specific density</h3>
<p>Fig. @ref(fig:chart) is concerned solely with the detection model. Code for estimating sex-specific densities is available for each option as shown in Table @ref(tab:sexdensity). Sex ratio (pmix) is estimated directly only from hybrid mixture models. Post-hoc specification of ‘groups’ in <code>derived</code> works for both conditional and full likelihood models when density is constant. It is a common mistake to omit <code>D~g</code> or <code>D~session</code> from full-likelihood sex models – this forces a 1:1 sex ratio.</p>
<table>
<caption>(#tab:sexdensity) Sex-specific estimates of density from various models. Any detection parameter may precede ‘~’.</caption>
<colgroup>
<col width="24%" />
<col width="32%" />
<col width="44%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Fitting method</th>
<th align="left">Model</th>
<th align="left">Sex-specific density</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Conditional likelihood</td>
<td align="left"><code>~sex</code><sup>1</sup></td>
<td align="left"><code>derived(fit, groups = sexcov)</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><code>~h2, hcov = sexcov</code></td>
<td align="left"><code>derived(fit, groups = sexcov)</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><code>~session</code></td>
<td align="left"><code>derived(fit)</code></td>
</tr>
<tr class="even">
<td align="left">Full likelihood</td>
<td align="left"><code>D~g, ~g, groups = sexcov</code></td>
<td align="left"><code>predict(fit)</code>)</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><code>~h2, hcov = sexcov</code></td>
<td align="left"><code>derived(fit, groups = sexcov)</code><sup>2</sup></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><code>D~session, ~session</code></td>
<td align="left"><code>predict(fit)</code></td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="final-comments" class="section level2" number="12.4">
<h2><span class="header-section-number">12.4</span> Final comments</h2>
<p>We note</p>
<ul>
<li>Only hybrid mixtures can cope with missing values.</li>
<li>The implementation of groups is less comprehensive and may not be available for extensions in the Appendices.</li>
<li>Options should not be mixed for comparing AIC.</li>
</ul>
<p>Sex differences in home-range size (and hence <span class="math inline">\(\sigma\)</span>) may be mitigated by compensatory variation in <span class="math inline">\(g_0\)</span> or <span class="math inline">\(\lambda_0\)</span> <span class="citation">(<a href="#ref-em14">Efford and Mowat 2014</a>)</span> (see also <a href="#mitigation">Mitigating factors</a> in Chapter @ref(individual-heterogeneity)).</p>
<!-- cf Greg Distiller post -->
<!--chapter:end:08-sex.Rmd-->
</div>
</div>
<div id="fitting-models" class="section level1" number="13">
<h1><span class="header-section-number">13</span> Fitting models</h1>
<p>This chapter covers issues that arise regardless of the particular model to be fitted.</p>
<div id="multi-threading" class="section level2" number="13.1">
<h2><span class="header-section-number">13.1</span> Multi-threading</h2>
<p>
</p>
<p>On processors with multiple cores it is possible to speed up computation by using cores in parallel. In <strong>secr</strong> this happens automatically in <code>secr.fit</code> and a few other functions using the multi-threading paradigm of <strong>RcppParallel</strong> <span class="citation">(<a href="#ref-R-RcppParallel">Allaire et al. 2023</a>)</span>. The number of threads may be set directly with the function <code>setNumThreads</code>, or via the ‘ncores’ argument of several functions. The number is stored in the environment variable</p>
</div>
<div id="bias-check" class="section level2" number="13.2">
<h2><span class="header-section-number">13.2</span> Bias check</h2>
<p></p>
<p>If no mask is specified and the ‘buffer’ argument of <code>secr.fit</code> is too narrow then the estimate of density may suffer from truncation bias (see Chapter @ref(Habitat)). In many cases <code>secr.fit</code> will automatically perform a post-hoc check on the fitted model and raise a warning if the predicted bias exceeds the value in the argument ‘biasLimit’ (default 0.01). To suppress the check set ‘biasLimit = NA’, or provide a pre-defined mask.</p>
<p>The check is performed by a cunning custom algorithm in function <code>bias.D</code>. This uses one-dimensional numerical integration of a polar approximation to site-specific detection probability, coupled to a 3-part linear approximation for the length of contours of distance-to-nearest-detector.</p>
</div>
<div id="model-selection" class="section level2" number="13.3">
<h2><span class="header-section-number">13.3</span> Model selection</h2>
<div id="criterion" class="section level3" number="13.3.1">
<h3><span class="header-section-number">13.3.1</span> Criterion</h3>
<p>AIC, AICc, BIC</p>
</div>
<div id="small-sample-adjustment-aicc" class="section level3" number="13.3.2">
<h3><span class="header-section-number">13.3.2</span> Small sample adjustment AICc</h3>
<p>What is the sample size?</p>
<p>We prefer AIC because [doesn’t raise question of sample size; Fletcher results]</p>
<p>Need for strictly identical data</p>
<p>What to report?</p>
</div>
<div id="strategy-detection-then-density" class="section level3" number="13.3.3">
<h3><span class="header-section-number">13.3.3</span> Strategy: detection then density?</h3>
<p>It is almost impossible to fit and compare all plausible models.</p>
</div>
<div id="likelihood-ratio" class="section level3" number="13.3.4">
<h3><span class="header-section-number">13.3.4</span> Likelihood ratio</h3>
<p><code>LR.test</code></p>
</div>
<div id="aic-aicwt-etc." class="section level3" number="13.3.5">
<h3><span class="header-section-number">13.3.5</span> AIC, AICwt etc.</h3>
</div>
<div id="score-tests" class="section level3" number="13.3.6">
<h3><span class="header-section-number">13.3.6</span> Score tests</h3>
</div>
</div>
<div id="using-the-fitted-models" class="section level2" number="13.4">
<h2><span class="header-section-number">13.4</span> Using the fitted model(s)</h2>
<div id="predict" class="section level3" number="13.4.1">
<h3><span class="header-section-number">13.4.1</span> predict</h3>
<div id="newdata-argument" class="section level4" number="13.4.1.1">
<h4><span class="header-section-number">13.4.1.1</span> newdata argument</h4>
</div>
</div>
<div id="collate" class="section level3" number="13.4.2">
<h3><span class="header-section-number">13.4.2</span> collate</h3>
</div>
<div id="model-averaging" class="section level3" number="13.4.3">
<h3><span class="header-section-number">13.4.3</span> Model averaging</h3>
</div>
<div id="predictdsurface" class="section level3" number="13.4.4">
<h3><span class="header-section-number">13.4.4</span> predictDsurface</h3>
<p>See Chapter @ref(Density)</p>
</div>
</div>
<div id="goodness-of-fit" class="section level2" number="13.5">
<h2><span class="header-section-number">13.5</span> Goodness of fit</h2>
<p>To be added; <code>secr.test</code></p>
</div>
<div id="common-problems" class="section level2" number="13.6">
<h2><span class="header-section-number">13.6</span> Common problems</h2>
<div id="use-only-one-of-buffer-or-mask" class="section level3" number="13.6.1">
<h3><span class="header-section-number">13.6.1</span> Use only one of ‘buffer’ or ‘mask’</h3>
</div>
<div id="do-not-obsess-about-buffer-width" class="section level3" number="13.6.2">
<h3><span class="header-section-number">13.6.2</span> Do not obsess about buffer width</h3>
</div>
</div>
<div id="recognizing-failure-to-fit" class="section level2" number="13.7">
<h2><span class="header-section-number">13.7</span> Recognizing failure-to-fit</h2>
</div>
<div id="speed" class="section level2" number="13.8">
<h2><span class="header-section-number">13.8</span> Speed</h2>
<p><code>setNumThreads</code></p>
<p>mask points; trapbuffer</p>
<p>separate sessions where possible</p>
<p>discretize polygons</p>
<!--chapter:end:10-secrfit.Rmd-->
</div>
</div>
<div id="parameterizations-1" class="section level1" number="14">
<h1><span class="header-section-number">14</span> Parameterizations</h1>
<p></p>
<p>At the heart of SECR there is usually a set of three primary model parameters: one for population density (<span class="math inline">\(D\)</span>) and two for the detection function. The detection function is commonly parameterized in terms of its intercept (the probability <span class="math inline">\(g_0\)</span> or cumulative hazard <span class="math inline">\(\lambda_0\)</span> of detection for a detector at the centre of the home range) and a spatial scale parameter <span class="math inline">\(\sigma\)</span>. Although this parameterization is simple and uncontroversial, it is not inevitable. Sometimes the
biology leads us to expect a structural relationship between primary parameters. The relationship may be ‘hard-wired’ into the model by replacing a primary parameter with a function of other parameter(s). This often makes for a more parsimonious model, and model comparisons may be used to evaluate the hypothesized relationship. Here we outline some
parameterization options in <strong>secr</strong>.</p>
<div id="theory" class="section level2" number="14.1">
<h2><span class="header-section-number">14.1</span> Theory</h2>
<p>The idea is to replace a primary detection parameter with a function of other parameter(s) in the SECR model. This may allow constraints to be applied more meaningfully. Specifically, it may make sense to consider a function of the parameters to be constant, even when one of the primary parameters varies. The new parameter also may be modelled as a function of covariates etc.</p>
<div id="lambda_0-and-sigma" class="section level3" number="14.1.1">
<h3><span class="header-section-number">14.1.1</span> <span class="math inline">\(\lambda_0\)</span> and <span class="math inline">\(\sigma\)</span></h3>
<p></p>
<p>One published example concerns compensatory heterogeneity of detection parameters (Efford and Mowat 2014). Combinations of <span class="math inline">\(\lambda_0\)</span> and <span class="math inline">\(\sigma\)</span> yield the same effective sampling area <span class="math inline">\(a\)</span> when the cumulative hazard of detection (<span class="math inline">\(\lambda(d)\)</span>)<a href="#fn39" class="footnote-ref" id="fnref39"><sup>39</sup></a> is a linear function of home-range utilisation. Variation in home-range size then has no effect on estimates of density. It would be useful to allow <span class="math inline">\(\sigma\)</span> to vary while holding <span class="math inline">\(a\)</span> constant, but this has some fishhooks because computation of <span class="math inline">\(\lambda_0\)</span> from <span class="math inline">\(a\)</span> and <span class="math inline">\(\sigma\)</span> is not straightforward. A simple alternative is to substitute <span class="math inline">\(a_0 = 2 \pi \lambda_0 \sigma^2\)</span>; <span class="citation">Efford and Mowat (<a href="#ref-em14">2014</a>)</span> called <span class="math inline">\(a_0\)</span> the ‘single-detector sampling area’. If the sampling regime is constant, holding <span class="math inline">\(a_0\)</span> constant is almost equivalent to holding <span class="math inline">\(a\)</span> constant (but see <a href="#paramlimitations">Limitations</a>). Fig. @ref(fig:paramfig1) illustrates the relationship for 3 levels of <span class="math inline">\(a_0\)</span>.</p>
<p>(ref:fig1cap) Structural relationship between parameters <span class="math inline">\(\lambda_0\)</span> and <span class="math inline">\(\sigma\)</span> expressed by holding <span class="math inline">\(a_0\)</span> constant in <span class="math inline">\(\lambda_0 = a_0 / (2 \pi \sigma^2)\)</span>.</p>
<div class="figure">
<img src="SECRbook_files/figure-html/paramfig1-1.png" alt="(ref:fig1cap)" width="432" />
<p class="caption">
(#fig:paramfig1)(ref:fig1cap)
</p>
</div>
</div>
<div id="sigma-and-d" class="section level3" number="14.1.2">
<h3><span class="header-section-number">14.1.2</span> <span class="math inline">\(\sigma\)</span> and <span class="math inline">\(D\)</span></h3>
<p>
Another biologically interesting structural relationship is that between population density and home-range size <span class="citation">(<a href="#ref-edjq16">Efford et al. 2016</a>)</span>. If home ranges have a definite edge and partition all available space then an inverse-square relationship is expected <span class="math inline">\(D = (k / r)^2\)</span> or <span class="math inline">\(r = k / \sqrt D\)</span>, where <span class="math inline">\(r\)</span> is a linear measure of home-range size (e.g., grid cell width) and <span class="math inline">\(k\)</span> is a constant of proportionality. In reality, the home-range model that underlies SECR detection functions does not require a hard edge, so the language of ‘partitioning’ and <span class="citation">Huxley (<a href="#ref-Huxley1934">1934</a>)</span>[’s] ‘elastic discs’ does not quite fit. However, the inverse-square relationship is empirically useful, and we conjecture that it may also arise from simple models for constant overlap of home ranges when density varies – a topic for future research. For use in SECR we equate <span class="math inline">\(r\)</span> with the spatial scale of detection <span class="math inline">\(\sigma\)</span>, and predict concave-up relationships as in (Fig. @ref(fig:paramfig2).</p>
<p>The relationship may be modified by adding a constant <span class="math inline">\(c\)</span> to represent the lower asymptote of sigma as density increases ( <span class="math inline">\(\sigma = k / \sqrt D + c\)</span>; by default <span class="math inline">\(c = 0\)</span> in <strong>secr</strong>).</p>
<p>It is possible, intuitively, that once a population becomes very sparse there is no further effect of density on home-range size. Alternatively, very low density may reflect sparseness of resources, requiring the few individuals present to exploit very large home ranges even if they seldom meet. If density is no longer related to <span class="math inline">\(\sigma\)</span> at low density, even indirectly, then the steep increase in <span class="math inline">\(\sigma\)</span> modelled on the left of Fig. @ref(fig:paramfig3) will ‘level off’ at some value of <span class="math inline">\(\sigma\)</span>. We don’t know of any empirical example of this hypothetical phenomenon, and do not provide a model.</p>
<p>(ref:fig2cap) Structural relationship between parameters <span class="math inline">\(D\)</span> and <span class="math inline">\(\sigma\)</span> expressed by holding <span class="math inline">\(k\)</span> constant in <span class="math inline">\(\sigma = 100 k / \sqrt D\)</span>. The factor of 100 adjusts for the inconsistent default units of <span class="math inline">\(\sigma\)</span> and <span class="math inline">\(D\)</span> in <strong>secr</strong> (metres and hectares).</p>
<div class="figure">
<img src="SECRbook_files/figure-html/paramfig2-1.png" alt="(ref:fig2cap)" width="432" />
<p class="caption">
(#fig:paramfig2)(ref:fig2cap)
</p>
</div>
<p>We use ‘primary parameter’ to mean one of (<span class="math inline">\(D, \lambda_0, \sigma\)</span>)<a href="#fn40" class="footnote-ref" id="fnref40"><sup>40</sup></a> For each relationship there is a primary parameter considered the ‘driver’ that varies for external reasons (e.g., between times, sexes etc.), and a dependent parameter that varies in response to the driver, moderated by a ‘surrogate’ parameter that may be constant or under external control. The surrogate parameter appears in the model in place of the dependent parameter. Using the surrogate parameterization is exactly equivalent to the default parameterization if the driver parameter(s) (<span class="math inline">\(\sigma\)</span> and <span class="math inline">\(\lambda_0\)</span> for <span class="math inline">\(a_0\)</span><a href="#fn41" class="footnote-ref" id="fnref41"><sup>41</sup></a>, <span class="math inline">\(D\)</span> for <span class="math inline">\(k\)</span><a href="#fn42" class="footnote-ref" id="fnref42"><sup>42</sup></a>) are constant.</p>
</div>
</div>
<div id="implementation" class="section level2" number="14.2">
<h2><span class="header-section-number">14.2</span> Implementation</h2>
<p>Parameterizations in <strong>secr</strong> are indicated by an integer code (Table @ref(tab:paramcodes)). The internal implementation of the parameterizations (3)–(5) is straightforward. At each evaluation of the likelihood function:</p>
<ol style="list-style-type: decimal">
<li>The values of the driver and surrogate parameters are determined</li>
<li>Each dependent parameter is computed from the relevant driver and surrogate parameters</li>
<li>Values of the now-complete set of primary parameters are passed to the standard
code for evaluating the likelihood.</li>
</ol>
<table>
<caption>(#tab:paramcodes) Parameterization codes</caption>
<colgroup>
<col width="5%" />
<col width="34%" />
<col width="9%" />
<col width="13%" />
<col width="38%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Code</th>
<th align="left">Description</th>
<th align="left">Driver</th>
<th align="left">Surrogate(s)</th>
<th align="left">Dependent</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">Default</td>
<td align="left">–</td>
<td align="left">–</td>
<td align="left">–</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">Single-detector sampling area</td>
<td align="left"><span class="math inline">\(\sigma\)</span></td>
<td align="left"><span class="math inline">\(a_0\)</span></td>
<td align="left"><span class="math inline">\(\lambda_0 = a_0/(2\pi\sigma^2)\)</span></td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">Density-dependent home range</td>
<td align="left"><span class="math inline">\(D\)</span></td>
<td align="left"><span class="math inline">\(k\)</span>, <span class="math inline">\(c\)</span></td>
<td align="left"><span class="math inline">\(\sigma = 100 k / \sqrt D + c\)</span></td>
</tr>
<tr class="even">
<td align="left">5</td>
<td align="left">3 &amp; 4 combined</td>
<td align="left"><span class="math inline">\(D\)</span>, <span class="math inline">\(\sigma\)</span></td>
<td align="left"><span class="math inline">\(k\)</span>, <span class="math inline">\(c\)</span>, <span class="math inline">\(a_0\)</span></td>
<td align="left"><span class="math inline">\(\sigma = 100 k / \sqrt D + c\)</span>, <span class="math inline">\(\lambda_0 = a_0/(2\pi\sigma^2)\)</span></td>
</tr>
</tbody>
</table>
<p>The transformation is performed independently for each level of the surrogate parameters that appears in the model. For example, if the model includes a learned response <code>a0 ~ b</code>, there are two levels of a0 (for naive and experienced animals) that translate to two levels of lambda0. For parameterization (4), <span class="math inline">\(\sigma = 100 k / \sqrt D\)</span>. The factor of 100 is an adjustment for differing units (areas are expressed in hectares in <strong>secr</strong>, and 1 hectare = 10 000 <span class="math inline">\(\mbox{m}^2\)</span>). For parameterization (5), <span class="math inline">\(\sigma\)</span> is first computed from <span class="math inline">\(D\)</span>, and then <span class="math inline">\(\lambda_0\)</span> is computed from <span class="math inline">\(\sigma\)</span>.</p>
<div id="interface" class="section level3" number="14.2.1">
<h3><span class="header-section-number">14.2.1</span> Interface</h3>
<p>Users choose between parameterizations either</p>
<ul>
<li>explicitly, by setting the ‘param’ component of the <code>secr.fit</code> argument ‘details’, or</li>
<li>implicitly, by including a parameterization-specific parameter name in the <code>secr.fit</code> model.</li>
</ul>
<p>Implicit selection causes the value of details$param to be set automatically (with a warning).</p>
<p>The main parameterization options are listed in Table 1 (other specialised options are listed in the Appendix).</p>
<p>The constant <span class="math inline">\(c\)</span> in the relationship <span class="math inline">\(\sigma = k / \sqrt{D} + c\)</span> is set to zero and not estimated unless ‘c’ appears explicitly in the model. For example, <code>model = list(sigmak ~ 1)</code> fixes c = 0, whereas <code>model = list(sigmak ~ 1, c ~ 1)</code> causes c to be estimated. The usefulness of this model has yet to be proven! By default an identity link is used for ‘c’, which permits negative values; negative ‘c’ implies that for some densities (most likely densities outside the range of the data) a negative sigma is predicted. If you’re uncomfortable with this and require ‘c’ to be positive then set <code>link = list(c = 'log')</code> in <code>secr.fit</code> <em>and</em> specify a positive starting value for it in <code>start</code> (using the vector form for that argument of <code>secr.fit</code>).</p>
<p>Initial values may be a problem as the scales for a0 and sigmak are not intuitive. Assuming automatic initial values can be computed for a half-normal detection function with parameters <span class="math inline">\(g_0\)</span> and <span class="math inline">\(\sigma\)</span>, the default initial value for <span class="math inline">\(a_0\)</span> is <span class="math inline">\(2 \pi g_0 \sigma^2 /10000\)</span>, and for <span class="math inline">\(k\)</span>, <span class="math inline">\(\sigma \sqrt{D}\)</span>. If the usual automatic procedure (see <code>?autoini</code>) fails then <em>ad hoc</em> and less reliable starting values are used. In case of trouble, it is suggested that you first fit a very simple (or null) model using the desired parameterization, and then use this to provide starting values for a more complex model. Here is an example (actually a trivial one for which the default starting values would have been OK; some warnings are suppressed):</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb167-1"><a href="#cb167-1" tabindex="-1"></a>fit0  <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(captdata, <span class="at">model =</span> a0<span class="sc">~</span><span class="dv">1</span>, <span class="at">detectfn =</span> <span class="st">&#39;HHN&#39;</span>,</span>
<span id="cb167-2"><a href="#cb167-2" tabindex="-1"></a>                  <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb167-3"><a href="#cb167-3" tabindex="-1"></a>fitbk <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(captdata, <span class="at">model =</span> a0<span class="sc">~</span>bk, <span class="at">detectfn =</span> <span class="st">&#39;HHN&#39;</span>, </span>
<span id="cb167-4"><a href="#cb167-4" tabindex="-1"></a>                  <span class="at">trace =</span> <span class="cn">FALSE</span>, <span class="at">start =</span> fit0)</span></code></pre></div>
</div>
<div id="models-for-surrogate-parameters-a0-and-sigmak" class="section level3" number="14.2.2">
<h3><span class="header-section-number">14.2.2</span> Models for surrogate parameters a0 and sigmak</h3>
<p>The surrogate parameters a0 and sigmak are treated as if they are full ‘real’ parameters, so they appear in the output from <code>predict.secr</code>, and may be modelled like any other ‘real’ parameter. For example, <code>model = sigmak ~ h2</code> is valid.</p>
<p>Do not confuse this with the modelling of primary ‘real’ parameters as
functions of covariates, or built-in effects such as a learned response.</p>
</div>
</div>
<div id="example" class="section level2" number="14.3">
<h2><span class="header-section-number">14.3</span> Example</h2>
<p>Among the datasets included with <strong>secr</strong>, only <code>ovenCH</code> provides a useful temporal sequence - 5 years of data from mistnetting of ovenbirds (<em>Seiurus aurocapilla</em>) at Patuxent Research Refuge, Maryland. A full model for annually varying density and detection parameters may be fitted with</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb168-1"><a href="#cb168-1" tabindex="-1"></a>msk <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(<span class="fu">traps</span>(ovenCH[[<span class="dv">1</span>]]), <span class="at">buffer =</span> <span class="dv">300</span>, <span class="at">nx =</span> <span class="dv">25</span>)</span>
<span id="cb168-2"><a href="#cb168-2" tabindex="-1"></a>oven0509b <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ovenCH, <span class="at">model =</span> <span class="fu">list</span>(D <span class="sc">~</span> session, </span>
<span id="cb168-3"><a href="#cb168-3" tabindex="-1"></a>    sigma <span class="sc">~</span> session, lambda0 <span class="sc">~</span> session <span class="sc">+</span> bk), <span class="at">mask =</span> msk, </span>
<span id="cb168-4"><a href="#cb168-4" tabindex="-1"></a>    <span class="at">detectfn =</span> <span class="st">&#39;HHN&#39;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>This has 16 parameters and takes some time to fit.</p>
<p>We hypothesize that home-range (territory) size varied inversely with density, and model this by fixing the parameter <span class="math inline">\(k\)</span>. <span class="citation">Efford and Mowat (<a href="#ref-em14">2014</a>)</span> reported for this dataset that <span class="math inline">\(\lambda_0\)</span> did not compensate for within-year, between-individual variation in <span class="math inline">\(\sigma\)</span>, but it is nevertheless possible that variation between years was compensatory, and we model this by fixing <span class="math inline">\(a_0\)</span>. For good measure, we also allow for site-specific net shyness by modelling <span class="math inline">\(a_0\)</span> with the builtin effect ‘bk’:</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb169-1"><a href="#cb169-1" tabindex="-1"></a>oven0509bs <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ovenCH, <span class="at">model =</span> <span class="fu">list</span>(D <span class="sc">~</span> session, sigmak <span class="sc">~</span> <span class="dv">1</span>,</span>
<span id="cb169-2"><a href="#cb169-2" tabindex="-1"></a>    a0 <span class="sc">~</span> bk), <span class="at">mask =</span> msk, <span class="at">detectfn =</span> <span class="st">&#39;HHN&#39;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## Warning: Using parameterization details$param = 5</code></pre>
<p>The effect of including both sigmak and a0 in the model is to force parameterization (5). The model estimates a different density in each year, as in the previous model. Annual variation in <span class="math inline">\(D\)</span> drives annual variation in <span class="math inline">\(\sigma\)</span> through the relation <span class="math inline">\(\sigma_y = k / \sqrt{D_y}\)</span> where <span class="math inline">\(k\)</span> (= sigmak/100) is a parameter to be estimated and the subscript <span class="math inline">\(y\)</span> indicates year. The detection function ‘HHN’ is the hazard-half-normal which has parameters <span class="math inline">\(\sigma\)</span> and <span class="math inline">\(\lambda_0\)</span>. We already have year-specific <span class="math inline">\(\sigma_y\)</span>, and this drives annual variation in <span class="math inline">\(\lambda_0\)</span>: <span class="math inline">\(\lambda_{0y} = a_{0X} / (2 \pi \sigma_y^2)\)</span> where <span class="math inline">\(a_{0X}\)</span> takes one of two different values depending on whether the bird in question has been caught previously in this net.</p>
<p>This is a behaviourally plausible and fairly complex model, but it uses just 8 parameters compared to 16 in a full annual model with net shyness. It may be compared by AIC with the full model (the model structure differs but the data are the same). Although the new model has somewhat higher deviance (1858.5 vs 1851.6), the reduced number of parameters results in a substantially lower AIC (<span class="math inline">\(\Delta\)</span>AIC =
9.1).</p>
<p>In Fig. @ref(fig:paramfig3) we illustrate the results by overplotting the fitted curve for <span class="math inline">\(\sigma_y\)</span> on a scatter plot of the separate annual estimates from the full model. A longer run of years was analysed by <span class="citation">Efford et al. (<a href="#ref-edjq16">2016</a>)</span>.</p>
<p>(ref:fig3cap) Fitted structural relationship between parameters <span class="math inline">\(D\)</span> and <span class="math inline">\(\sigma\)</span> (curve; <span class="math inline">\(\hat k =\)</span> 0.747) and separate annual estimates (ovenbirds mistnetted on Patuxent Research Refuge 2005–2009).</p>
<div class="figure">
<img src="SECRbook_files/figure-html/paramfig3-1.png" alt="(ref:fig3cap)" width="432" />
<p class="caption">
(#fig:paramfig3)(ref:fig3cap)
</p>
</div>
</div>
<div id="paramlimitations" class="section level2" number="14.4">
<h2><span class="header-section-number">14.4</span> Limitations</h2>
<p>Using <span class="math inline">\(a_0\)</span> as a surrogate for <span class="math inline">\(a\)</span> is unreliable if the distribution or intensity of sampling varies. This is because <span class="math inline">\(a_0\)</span> depends only on the parameter values, whereas <span class="math inline">\(a\)</span> depends also on the detector layout and duration of sampling. For example, if a different size of trapping grid is used in each session, <span class="math inline">\(a\)</span> will vary even if the detection parameters, and hence <span class="math inline">\(a_0\)</span>, stay the same. This is also true (<span class="math inline">\(a\)</span> varies, <span class="math inline">\(a_0\)</span> constant) if the same trapping grid is operated for differing number of occasions in each session. It is <span class="math inline">\(a\)</span> that really matters, and constant <span class="math inline">\(a_0\)</span> is not a sensible null model in these scenarios.</p>
<p>parameterizations (4) and (5) make sense only if density D is in the model; an attempt to use these when maximizing only the conditional likelihood (<code>CL = TRUE</code>) will cause an error.</p>
</div>
<div id="other-notes" class="section level2" number="14.5">
<h2><span class="header-section-number">14.5</span> Other notes</h2>
<p>Detection functions 0–3 and 5–8 (‘HN’,‘HR’,‘EX’, ‘CHN’, ‘WEX’, ‘ANN’, ‘CLN’, ‘CG’) describe the probability of detection <span class="math inline">\(g(d)\)</span> and use <span class="math inline">\(g_0\)</span> as the intercept instead of <span class="math inline">\(\lambda_0\)</span>. Can parameterizations (3) and (5) also be used with these detection functions? Yes, but the user must take responsibility for the interpretation, which is less
clear than for detection functions based on the cumulative hazard (14–19, or ‘HHN’, ‘HHR’, ‘HEX’, ‘HAN’, ‘HCG’, ‘HVP’). The primary parameter is computed as <span class="math inline">\(g_0 = 1 - \exp(-a_0 / (2\pi \sigma^2))\)</span>.</p>
<p>In a sense, the choice between detection functions ‘HN’ and ‘HHN’, ‘EX’ and ‘HEX’ etc. is between two parameterizations, one with half-normal hazard <span class="math inline">\(\lambda(d)\)</span> and one with half-normal probability <span class="math inline">\(g(d)\)</span>, always with the relationship <span class="math inline">\(g(d) = 1 - \exp(-\lambda(d))\)</span> (using <span class="math inline">\(d\)</span> for the distance between home-range centre and detector). It may have been clearer if this had been programmed originally as a switch between ‘hazard’ and ‘probability’ parameterizations, but this would now require significant changes to the code and is not a priority.</p>
<p>If a detection function is specified that requires a third parameter (e.g., z in the case of the hazard-rate function ‘HR’) then this is carried along untouched.</p>
<p>It is possible that home range size, and hence <span class="math inline">\(\sigma\)</span>, varies in a spatially continuous way with density. The sigmak parameterization does not work when density varies spatially within one population because of the way models of state variables (<span class="math inline">\(D\)</span>) and detection variables (<span class="math inline">\(g_0\)</span>, <span class="math inline">\(\lambda_0\)</span>, <span class="math inline">\(\sigma\)</span>) are separated within <strong>secr</strong>. Non-Euclidean distance methods allow a workaround as described in Appendix @ref(Noneuclidean) and <span class="citation">Efford et al. (<a href="#ref-edjq16">2016</a>)</span>.</p>
<p>Some parameterization options (Table @ref(tab:extraparamcodes)) were not included in Table @ref(tab:paramcodes) because they are not intended for general use and their implementation may be incomplete (e.g., not allowing covariates). Although parameterizations (2) and (6) promise a ‘pure’ implementation in terms of the effective sampling area <span class="math inline">\(a\)</span> rather than the surrogate <span class="math inline">\(a_0\)</span>, this option has not been implemented and tested as extensively as that for <span class="math inline">\(a_0\)</span> (parameterization 3). The transformation to determine <span class="math inline">\(\lambda_0\)</span> or <span class="math inline">\(g_0\)</span> requires numerical root finding, which is slow. Also, assuming constant <span class="math inline">\(a\)</span> does not make sense when either the detector array or the number of sampling occasions varies, as both of these must affect <span class="math inline">\(a\)</span>. Use at your own risk!</p>
<table>
<caption>(#tab:extraparamcodes) Additional parameterizations.</caption>
<colgroup>
<col width="8%" />
<col width="30%" />
<col width="10%" />
<col width="13%" />
<col width="37%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Code</th>
<th align="left">Description</th>
<th align="left">Driver</th>
<th align="left">Surrogate(s)</th>
<th align="left">Dependent</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">2</td>
<td align="left">Effective sampling area</td>
<td align="left"><span class="math inline">\(\sigma\)</span></td>
<td align="left"><span class="math inline">\(a\)</span></td>
<td align="left"><span class="math inline">\(\lambda_0\)</span> such that <span class="math inline">\(a = \int p_\cdot(\mathbf{x}|\sigma, \lambda_0) d\mathbf{x}\)</span></td>
</tr>
<tr class="even">
<td align="left">6</td>
<td align="left">2 &amp; 4 combined</td>
<td align="left"><span class="math inline">\(D\)</span></td>
<td align="left"><span class="math inline">\(k\)</span>, <span class="math inline">\(c\)</span>, <span class="math inline">\(a\)</span></td>
<td align="left"><span class="math inline">\(\sigma = 100 k / \sqrt D + c\)</span>, <span class="math inline">\(\lambda_0\)</span> as above</td>
</tr>
</tbody>
</table>
</div>
<div id="abundance" class="section level2" number="14.6">
<h2><span class="header-section-number">14.6</span> Abundance</h2>
<p>We use density <span class="math inline">\(D\)</span> as the primary parameter for abundance; the number of activity centres <span class="math inline">\(N(A)\)</span> is secondary as it is contingent on delineation of an area <span class="math inline">\(A\)</span>.</p>
<p>Appendix @ref(Trend) considers an alternative parameterization of multi-session density in terms of the initial density <span class="math inline">\(D_1\)</span> and session-to-session trend <span class="math inline">\(\lambda_t\)</span>.</p>
<!--chapter:end:11-parameterizations.Rmd-->
</div>
</div>
<div id="part-study-design" class="section level1 unnumbered">
<h1 class="unnumbered">(PART*) Study design</h1>
</div>
<div id="studydesign" class="section level1" number="15">
<h1><span class="header-section-number">15</span> Study design</h1>
<div id="criteria" class="section level2" number="15.1">
<h2><span class="header-section-number">15.1</span> Criteria</h2>
<div id="bias" class="section level3" number="15.1.1">
<h3><span class="header-section-number">15.1.1</span> Bias</h3>
</div>
<div id="precision" class="section level3" number="15.1.2">
<h3><span class="header-section-number">15.1.2</span> Precision</h3>
</div>
<div id="robustness" class="section level3" number="15.1.3">
<h3><span class="header-section-number">15.1.3</span> Robustness</h3>
</div>
</div>
<div id="pilot-values-of-detection-parameters" class="section level2" number="15.2">
<h2><span class="header-section-number">15.2</span> Pilot values of detection parameters</h2>
<div id="literature" class="section level3" number="15.2.1">
<h3><span class="header-section-number">15.2.1</span> literature</h3>
</div>
<div id="ad-hoc" class="section level3" number="15.2.2">
<h3><span class="header-section-number">15.2.2</span> ad hoc</h3>
<div id="sigma-from-home-range-area" class="section level4" number="15.2.2.1">
<h4><span class="header-section-number">15.2.2.1</span> sigma from home range area</h4>
</div>
<div id="lambda0-from-n" class="section level4" number="15.2.2.2">
<h4><span class="header-section-number">15.2.2.2</span> lambda0 from n</h4>
</div>
</div>
</div>
<div id="region-of-interest" class="section level2" number="15.3">
<h2><span class="header-section-number">15.3</span> Region of interest</h2>
<!-- ## Detector clusters -->
<!-- For surveying large areas it is efficient to use groups of detectors: within a group the detectors are close enough that animals may be re-detected at multiple points, while groups of detectors may be distributed across a region according to a probability design to sample possible spatial variation in density. **secr** allows for detector groups with the 'cluster' data structure. This is an attribute of a traps object that records which detectors belong to which cluster[^3]. -->
<!-- [^3]:Clusters are assumed to share the same geometry (number of detectors, -->
<!-- within-cluster spacing etc.). -->
<!-- Functions are provided to generate detector arrays with a clustered -->
<!-- structure (`trap.builder`, `make.systematic`), to extract or replace -->
<!-- the cluster attribute (`clusterID`), to compute the geometric centres -->
<!-- and numbers of detections per cluster (`cluster.centres`, -->
<!-- `cluster.counts`), etc. -->
<!-- A lacework design (Efford in prep.) is an alternative to a clustered design that is suitable when the region is intermediate size. Lacework designs may be constructed with `make.lacework`. -->
<!-- Data from a large, clustered design may often be analysed more quickly -->
<!-- if the 'capthist' object is first collapsed into one using the -->
<!-- geometry of a single cluster (the object retains a memory of the -->
<!-- number of individuals from each original cluster in the attribute -->
<!-- 'n.mash'). Use the function `mash` for this. Functions `derived`, -->
<!-- `derivedMash` and the method `predict.secr` use 'n.mash' to adjust -->
<!-- their output density, SE, and confidence limits. -->
<!--chapter:end:12-studydesign.Rmd-->
</div>
</div>
<div id="Simulation" class="section level1" number="16">
<h1><span class="header-section-number">16</span> Simulation</h1>
<div id="population" class="section level2" number="16.1">
<h2><span class="header-section-number">16.1</span> Population</h2>
<p></p>
<p><code>sim.popn(D, core, buffer = 100, model2D = c("poisson", "cluster",      "IHP", "coastal", "hills", "linear", "even", "rLGCP", "rThomas"),      buffertype = c("rect", "concave", "convex"), poly = NULL,      covariates = list(sex = c(M = 0.5, F = 0.5)), number.from = 1,      Ndist = c("poisson", "fixed", "specified"), nsessions = 1,      details = NULL, seed = NULL, keep.mask = model2D %in% c("IHP",          "linear"), Nbuffer = NULL, age = FALSE, ...)</code></p>
<div id="inhomogeneous-poisson-populations" class="section level3" number="16.1.1">
<h3><span class="header-section-number">16.1.1</span> Inhomogeneous Poisson populations</h3>
<p>A specialised use of <a href="#Habitat">masks</a> arises in <code>sim.popn</code> when simulating populations with an arbitrary non-uniform distribution of individuals (<code>model2D = "IHP"</code>). Then the argument ‘core’ should be a habitat mask; cell-specific density (expected number of individuals per hectare) may be given either in a covariate of the mask as named in argument ‘D’ or as a vector of values in argument ‘D’. The covariate option allows you to simulate from a fitted Dsurface (output from <code>predictDsurface</code>).</p>
</div>
</div>
<div id="detection" class="section level2" number="16.2">
<h2><span class="header-section-number">16.2</span> Detection</h2>
<p></p>
<p><code>sim.capthist</code></p>
</div>
<div id="secrdesign" class="section level2" number="16.3">
<h2><span class="header-section-number">16.3</span> <strong>secrdesign</strong></h2>
<p></p>
<p>[invalid replicates]</p>
<!--chapter:end:13-simulation.Rmd-->
</div>
</div>
<div id="part-appendices" class="section level1 unnumbered">
<h1 class="unnumbered">(PART*) Appendices</h1>
</div>
<div id="appendix-appendices" class="section level1 unnumbered">
<h1 class="unnumbered">(APPENDIX) Appendices</h1>
</div>
<div id="Spatialdata" class="section level1" number="17">
<h1><span class="header-section-number">17</span> Spatial data</h1>
<p>These notes explain how <strong>secr</strong> uses spatial data. Spatial data are used to</p>
<ol style="list-style-type: decimal">
<li>locate detectors (<code>read.traps</code>, <code>read.capthist</code>)</li>
<li>map the extent of habitat near detectors (<code>make.mask</code>)</li>
<li>attach covariates to traps or mask objects (<code>addCovariates</code>)</li>
<li>delimit regions of interest (<code>region.N</code> and other functions)</li>
</ol>
<p>Some spatial results may be exported, particularly the raster density surfaces
generated by <code>predictDsurface</code> from a fitted model.</p>
<p>Internally, <strong>secr</strong> uses a very simple concept of space. The locations of detectors (traps), the potential locations of activity centres (habitat mask) and the simulated locations of individuals (popn) are described by Cartesian (x-y) coordinates assumed to be in metres. Distances are Euclidean unless specifically modelled as non-Euclidean (Appendix @ref(Noneuclidean)). Only relative positions matter for the calculations, so the origin of the coordinates is arbitrary. The map projection (‘coordinate reference system’ or CRS) is not recorded.</p>
<p>Most spatial computations in <strong>secr</strong> (distances, areas, overlay etc.) use internal R and C++ code. Polygon and transect detectors are represented as dataframes in which each row gives the x- and y-coordinates of a vertex and topology is ignored (holes are not allowed).</p>
<p>The simple approach works fine within limits (discussed later), but issues arise when <strong>secr</strong></p>
<ul>
<li>exchanges spatial data (regions, covariates or predicted density) with other software, or</li>
<li>uses functions from R spatial packages, especially <strong>sf</strong> and <strong>spsurvey</strong>.</li>
</ul>
<div id="spatial-data-in-r" class="section level2" number="17.1">
<h2><span class="header-section-number">17.1</span> Spatial data in R</h2>
<p>To use spatial data or functions from external sources in <strong>secr</strong> it helps to know a little about the expanding spatial ecosystem in R.</p>
<div id="r-packages-for-spatial-data" class="section level3" number="17.1.1">
<h3><span class="header-section-number">17.1.1</span> R packages for spatial data</h3>
<p>Several widely used packages define classes and methods for spatial data (‘Used by’ in the following table is the number of CRAN packages from <code>crandep::get_dep</code> on 2024-02-24).</p>
<table>
<colgroup>
<col width="11%" />
<col width="7%" />
<col width="7%" />
<col width="9%" />
<col width="30%" />
<col width="33%" />
</colgroup>
<thead>
<tr class="header">
<th>Package</th>
<th>Scope</th>
<th>Year</th>
<th>Used by</th>
<th>Citation</th>
<th>Relevant S4 classes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>sp</strong></td>
<td>vector</td>
<td>2005–</td>
<td>456</td>
<td><span class="citation">Pebesma and Bivand (<a href="#ref-R-sp">2005</a>)</span></td>
<td>SpatialPolygons, SpatialPolygonsDataFrame, SpatialGridDataFrame, SpatialLinesDataFrame</td>
</tr>
<tr class="even">
<td><strong>raster</strong></td>
<td>raster</td>
<td>2010–</td>
<td>345</td>
<td><span class="citation">Hijmans (<a href="#ref-R-raster">2023a</a>)</span></td>
<td>RasterLayer</td>
</tr>
<tr class="odd">
<td><strong>sf</strong></td>
<td>vector</td>
<td>2016–</td>
<td>788</td>
<td><span class="citation">Pebesma (<a href="#ref-R-sf">2018</a>)</span></td>
<td>sfg, sfc, sf</td>
</tr>
<tr class="even">
<td><strong>stars</strong></td>
<td>both</td>
<td>2018–</td>
<td>63</td>
<td><span class="citation">Edzer and Bivand (<a href="#ref-R-stars">2023</a>)</span></td>
<td>stars</td>
</tr>
<tr class="odd">
<td><strong>terra</strong></td>
<td>both</td>
<td>2020–</td>
<td>322</td>
<td><span class="citation">Hijmans (<a href="#ref-R-terra">2023b</a>)</span></td>
<td>SpatVector, SpatRaster</td>
</tr>
</tbody>
</table>
<p>The reader should already understand the distinction between vector and raster spatial data. There are many resources for learning about spatial analysis in R that may be found by web search on, for example ‘R spatial data’. The introduction by <a href="https://cengel.github.io/R-spatial/">Claudia Engels</a> covers both <strong>sp</strong> and <strong>sf</strong>.</p>
<p>The capability of <strong>sp</strong> is being replaced by <a href="https://r-spatial.github.io/sf/articles/"><strong>sf</strong></a> and <strong>raster</strong> is being replaced by <a href="https://rspatial.org/terra/pkg/1-introduction.html"><strong>terra</strong></a>. The more recent packages tend to be faster. <strong>sf</strong> implements the ‘simple features’ standard.</p>
</div>
<div id="geographic-vs-projected-coordinates" class="section level3" number="17.1.2">
<h3><span class="header-section-number">17.1.2</span> Geographic vs projected coordinates</h3>
<p>QGIS has an excellent <a href="https://docs.qgis.org/3.16/en/docs/gentle_gis_introduction/coordinate_reference_systems.html">introduction</a> to coordinate reference systems (CRS) for GIS. Coordinate reference systems may be specified in many ways; the most simple is the 4- or 5-digit EPSG code (search for EPSG on the web).</p>
<p>Geographic coordinates (EPSG 4326, ignoring some details) specify a location on the earth’s surface by its latitude and longitude. This is the standard in Google Earth and Geographic Positioning Systems (GPS).</p>
</div>
</div>
<div id="spatial-data-in-secr" class="section level2" number="17.2">
<h2><span class="header-section-number">17.2</span> Spatial data in <strong>secr</strong></h2>
<div id="input-of-detector-locations" class="section level3" number="17.2.1">
<h3><span class="header-section-number">17.2.1</span> Input of detector locations</h3>
<p><strong>secr</strong> uses relative Cartesian coordinates. Detector coordinates from GPS should therefore be projected from geographic coordinates before input to <strong>secr</strong><a href="#fn43" class="footnote-ref" id="fnref43"><sup>43</sup></a>. Most of the R spatial packages include projection functions. Here is a simple example using <code>st_transform</code> from the <strong>sf</strong> package:</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb171-1"><a href="#cb171-1" tabindex="-1"></a><span class="fu">library</span>(sf)</span>
<span id="cb171-2"><a href="#cb171-2" tabindex="-1"></a><span class="co"># unprojected (geographic) coordinates (decimal degrees) </span></span>
<span id="cb171-3"><a href="#cb171-3" tabindex="-1"></a><span class="co"># longitude before latitude</span></span>
<span id="cb171-4"><a href="#cb171-4" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">x =</span> <span class="fu">c</span>(<span class="fl">174.9713</span>, <span class="fl">174.9724</span>, <span class="fl">174.9738</span>), </span>
<span id="cb171-5"><a href="#cb171-5" tabindex="-1"></a>                 <span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">41.3469</span>, <span class="sc">-</span><span class="fl">41.3475</span>, <span class="sc">-</span><span class="fl">41.3466</span>))</span>
<span id="cb171-6"><a href="#cb171-6" tabindex="-1"></a><span class="co"># construct sf object</span></span>
<span id="cb171-7"><a href="#cb171-7" tabindex="-1"></a>latlon <span class="ot">&lt;-</span> <span class="fu">st_as_sf</span>(df, <span class="at">coords =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>)</span>
<span id="cb171-8"><a href="#cb171-8" tabindex="-1"></a><span class="co"># specify initial CRS: WGS84 lat-lon</span></span>
<span id="cb171-9"><a href="#cb171-9" tabindex="-1"></a><span class="fu">st_crs</span>(latlon) <span class="ot">&lt;-</span> <span class="dv">4326</span>  </span>
<span id="cb171-10"><a href="#cb171-10" tabindex="-1"></a><span class="co"># project to Cartesian coordinate system, units metres</span></span>
<span id="cb171-11"><a href="#cb171-11" tabindex="-1"></a><span class="co"># EPSG:27200 is the old (pre-2001) NZMG</span></span>
<span id="cb171-12"><a href="#cb171-12" tabindex="-1"></a>trps <span class="ot">&lt;-</span> <span class="fu">st_transform</span>(latlon, <span class="at">crs =</span> <span class="dv">27200</span>) </span>
<span id="cb171-13"><a href="#cb171-13" tabindex="-1"></a><span class="co"># print</span></span>
<span id="cb171-14"><a href="#cb171-14" tabindex="-1"></a><span class="fu">st_coordinates</span>(latlon)  </span></code></pre></div>
<pre><code>##           X       Y
## [1,] 174.97 -41.347
## [2,] 174.97 -41.347
## [3,] 174.97 -41.347</code></pre>
<div class="sourceCode" id="cb173"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb173-1"><a href="#cb173-1" tabindex="-1"></a><span class="fu">st_coordinates</span>(trps)</span></code></pre></div>
<pre><code>##            X       Y
## [1,] 2674948 5982573
## [2,] 2675038 5982504
## [3,] 2675157 5982602</code></pre>
</div>
<div id="adding-spatial-covariates-to-a-traps-or-mask-object" class="section level3" number="17.2.2">
<h3><span class="header-section-number">17.2.2</span> Adding spatial covariates to a traps or mask object</h3>
<p>SECR models may include covariates for each detector (e.g., trap or searched polygon) in the detection model (parameters <span class="math inline">\(g_0\)</span>, <span class="math inline">\(\lambda_0\)</span>, <span class="math inline">\(\sigma\)</span> etc.) and for each point on the discretized habitat mask in the density model (parameter <span class="math inline">\(D\)</span>).</p>
<p>Covariates measured at detector locations may be included in the text files read by <code>read.traps</code> or <code>read.capthist</code>.</p>
<p>Covariates measured at each point on a habitat mask may be included in a file or data.frame input to <code>read.mask</code>, but this is an uncommon way to establish mask covariates. More commonly, a habitat mask is built using <code>make.mask</code> and initially has no covariates,</p>
<p>The function <code>addCovariates</code> is a convenient way to attach covariates to a traps or mask object <em>post hoc</em>. The function extracts covariate values from the ‘spatialdata’ argument by a spatial query for each point on a mask. Options are</p>
<table>
<thead>
<tr class="header">
<th>spatialdata</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>character</td>
<td>name of ESRI shapefile, excluding ‘.shp’</td>
</tr>
<tr class="even">
<td>sp::SpatialPolygonsDataFrame</td>
<td></td>
</tr>
<tr class="odd">
<td>sp::SpatialGridDataFrame</td>
<td></td>
</tr>
<tr class="even">
<td>raster::RasterLayer</td>
<td></td>
</tr>
<tr class="odd">
<td>secr::mask</td>
<td>covariates of nearest point</td>
</tr>
<tr class="even">
<td>secr::traps</td>
<td>covariates of nearest point</td>
</tr>
<tr class="odd">
<td>terra::SpatRaster</td>
<td>new in 4.5.3</td>
</tr>
<tr class="even">
<td>sf::sf</td>
<td>new in 4.5.3</td>
</tr>
</tbody>
</table>
<p>Data sources should use the coordinate reference system of the target detectors and mask (see previous section).</p>
</div>
<div id="functions-with-poly-or-region-spatial-argument" class="section level3" number="17.2.3">
<h3><span class="header-section-number">17.2.3</span> Functions with ‘poly’ or ‘region’ spatial argument</h3>
<p>Several <strong>secr</strong> functions use spatial data to define a region of interest (i.e. one or more polygons). All such polygons may be defined as</p>
<ul>
<li>2-column matrix or data.frame of x- and y-coordinates</li>
<li>SpatialPolygons or SpatialPolygonsDataFrame S4 classes from package <strong>sp</strong></li>
<li>SpatRaster S4 class from package <strong>terra</strong></li>
<li>sf or sfc S4 classes from package <strong>sf</strong> (POLYGON or MULTIPOLYGON geometries)</li>
</ul>
<p>Data in these formats are converted to an object of class sfc by the documented internal function <code>boundarytoSF</code>. The S4 classes allow complex regions with multiple polygons (islands), possibly containing ‘holes’ (lakes).</p>
<p>This applies to the following functions and arguments:</p>
<table>
<thead>
<tr class="header">
<th><strong>secr</strong> function</th>
<th>Argument</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>buffer.contour</td>
<td>poly</td>
</tr>
<tr class="even">
<td>deleteMaskPoints</td>
<td>poly</td>
</tr>
<tr class="odd">
<td>esa.plot</td>
<td>poly</td>
</tr>
<tr class="even">
<td>make.mask</td>
<td>poly</td>
</tr>
<tr class="odd">
<td>make.systematic</td>
<td>region</td>
</tr>
<tr class="even">
<td>mask.check</td>
<td>poly</td>
</tr>
<tr class="odd">
<td>pdot.contour</td>
<td>poly</td>
</tr>
<tr class="even">
<td>PG</td>
<td>poly</td>
</tr>
<tr class="odd">
<td>pointsInPolygon</td>
<td>poly*</td>
</tr>
<tr class="even">
<td>region.N</td>
<td>region*</td>
</tr>
<tr class="odd">
<td>sim.popn</td>
<td>poly</td>
</tr>
<tr class="even">
<td>subset.popn</td>
<td>poly</td>
</tr>
<tr class="odd">
<td>trap.builder</td>
<td>region</td>
</tr>
<tr class="even">
<td>trap.builder</td>
<td>exclude</td>
</tr>
</tbody>
</table>
<p>* <code>pointsInPolygon</code> and <code>region.N</code> also accept a habitat mask.</p>
</div>
<div id="gis-functionality-imported-from-other-r-packages" class="section level3" number="17.2.4">
<h3><span class="header-section-number">17.2.4</span> GIS functionality imported from other R packages</h3>
<p>Some specialised spatial operations are out-sourced by <strong>secr</strong>:</p>
<table>
<colgroup>
<col width="15%" />
<col width="37%" />
<col width="25%" />
<col width="21%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>secr</strong> function</th>
<th>Operation</th>
<th>Other-package function</th>
<th>Reference</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>randomHabitat</td>
<td>simulated habitat</td>
<td>raster::adjacent</td>
<td><span class="citation">Hijmans (<a href="#ref-R-raster">2023a</a>)</span></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>raster::clump</td>
<td></td>
</tr>
<tr class="odd">
<td>nedist</td>
<td>non-euclidean distances</td>
<td>gdistance::transition</td>
<td><span class="citation">van Etten (<a href="#ref-R-gdistance">2023</a>)</span></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>gdistance::geoCorrection</td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>gdistance::costDistance</td>
<td></td>
</tr>
<tr class="even">
<td>discretize</td>
<td>cell overlap with polygon(s)</td>
<td>sf::st_intersection</td>
<td><span class="citation">Pebesma (<a href="#ref-R-sf">2018</a>)</span></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>sf::st_area</td>
<td></td>
</tr>
<tr class="even">
<td>polyarea</td>
<td>area of polygon(s)</td>
<td>sf::st_area</td>
<td></td>
</tr>
<tr class="odd">
<td>make.mask</td>
<td>polybuffer mask type</td>
<td>sf::st_buffer</td>
<td></td>
</tr>
<tr class="even">
<td>rbind.capthist</td>
<td>merge polygon detectors</td>
<td>sf::st_union</td>
<td></td>
</tr>
<tr class="odd">
<td>trap.builder</td>
<td>SRS sample</td>
<td>sf::st_sample</td>
<td></td>
</tr>
<tr class="even">
<td>trap.builder</td>
<td>GRTS sample (spsurvey &gt;= 5.3.0)</td>
<td>spsurvey::grts</td>
<td><span class="citation">Dumelle et al. (<a href="#ref-R-spsurvey">2024</a>)</span></td>
</tr>
</tbody>
</table>
</div>
<div id="exporting-raster-data-for-use-in-other-packages" class="section level3" number="17.2.5">
<h3><span class="header-section-number">17.2.5</span> Exporting raster data for use in other packages</h3>
<p>A mask or predicted density surface (Dsurface) generated in <strong>secr</strong> may be used or plotted as a raster layer in another R package. <strong>secr</strong> provides <code>rast</code> and <code>raster</code> methods for <strong>secr</strong> mask and Dsurface objects, based on the respective generic functions exported by <strong>terra</strong> and <strong>raster</strong>. These return SpatRaster and RasterLayer objects respectively. For example,</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb175-1"><a href="#cb175-1" tabindex="-1"></a><span class="fu">library</span>(secr)</span>
<span id="cb175-2"><a href="#cb175-2" tabindex="-1"></a><span class="fu">summary</span>(possummask)</span></code></pre></div>
<pre><code>## Object class      mask 
## Mask type         trapbuffer 
## Number of points  5120 
## Spacing m         20 
## Cell area ha      0.04 
## Total area ha     204.8 
## x-range m         2697463 2699583 
## y-range m         6077080 6078580 
## Bounding box      
##         x       y
## 1 2697453 6077070
## 2 2699593 6077070
## 4 2699593 6078590
## 3 2697453 6078590
## 
## Summary of covariates 
##    d.to.shore    
##  Min.   :  2.24  
##  1st Qu.:200.11  
##  Median :370.80  
##  Mean   :389.24  
##  3rd Qu.:560.82  
##  Max.   :916.69</code></pre>
<div class="sourceCode" id="cb177"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb177-1"><a href="#cb177-1" tabindex="-1"></a><span class="co"># make SpatRaster object from mask covariate</span></span>
<span id="cb177-2"><a href="#cb177-2" tabindex="-1"></a>r <span class="ot">&lt;-</span> <span class="fu">rast</span>(possummask, <span class="at">covariate =</span> <span class="st">&#39;d.to.shore&#39;</span>)</span>
<span id="cb177-3"><a href="#cb177-3" tabindex="-1"></a><span class="fu">print</span>(r)</span></code></pre></div>
<pre><code>## class       : SpatRaster 
## dimensions  : 76, 107, 1  (nrow, ncol, nlyr)
## resolution  : 20, 20  (x, y)
## extent      : 2697453, 2699593, 6077070, 6078590  (xmin, xmax, ymin, ymax)
## coord. ref. :  
## source(s)   : memory
## name        :      tmp 
## min value   :   2.2361 
## max value   : 916.6924</code></pre>
<div class="sourceCode" id="cb179"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb179-1"><a href="#cb179-1" tabindex="-1"></a>terra<span class="sc">::</span><span class="fu">plot</span>(r)</span></code></pre></div>
<p><img src="SECRbook_files/figure-html/rast-1.png" width="672" /></p>
</div>
</div>
<div id="limits-of-the-cartesian-model-in-secr" class="section level2" number="17.3">
<h2><span class="header-section-number">17.3</span> Limits of the Cartesian model in <strong>secr</strong></h2>
<div id="distances-computed-in-large-studies" class="section level3" number="17.3.1">
<h3><span class="header-section-number">17.3.1</span> Distances computed in large studies</h3>
<p>Distances on the curved surface of the earth are not well represented by Euclidean distances when the study area is very large, as happens with large carnivores such as grizzly bears and wolverines. This has led some authors to use more rigorous distance algorithms (reference?). This is not possible in <strong>secr</strong> because there is no record of the projected coordinate reference system used for the detectors and habitat mask.</p>
<!--chapter:end:16-spatial-data.Rmd-->
</div>
</div>
</div>
<div id="Areaandtransectsearches" class="section level1" number="18">
<h1><span class="header-section-number">18</span> Area and transect search</h1>
<p>The ‘polygon’ detector type is used for count data from searches of one or more areas (polygons). Transect detectors are the linear equivalent of polygons; as the theory and implementation are very similar we mostly refer to polygon detectors and only briefly mention transects. The relevant theory is in Chapter @ref(areasearches). The method may be used with individually identifiable cues (e.g., faeces) as well as for direct observations of individuals.</p>
<p>Cells of a polygon capthist contain the number of detections per animal per polygon per occasion, supplemented by the x-y coordinates of each detection).</p>
<p>Polygons may be independent (detector type ‘polygon’) or exclusive (detector type ‘polygonX’). Exclusivity is a particular type of dependence in which an animal may be detected at no more than one polygon on each occasion, resulting in binary data (i.e. polygons function more like multi-catch traps than ‘count’ detectors). Transect detectors also may be independent (‘transect’) or exclusive (‘transectX’).</p>
<div id="parameterisation" class="section level2" number="18.1">
<h2><span class="header-section-number">18.1</span> Parameterisation</h2>
<p>The detection model is fundamentally different for polygon detectors and detectors at a point (“single”, “multi”, “proximity”, “count”):</p>
<ul>
<li>For point detectors, the detection function directly models the probability of detection or the expected number of detections. All that matters is the distance between the animal’s centre and the detector.</li>
<li>For polygon detectors, these quantities (probability or expected number) depend also on the geometrical relationships and the integration in equation @ref(eq:hsk). The detection function serves only to define the <em>potential</em> detections if the search area was unbounded (blue contours in Fig. @ref(fig:overlapplot)).</li>
</ul>
<p>We use a parameterisation that separates two aspects of detection – the expected number of cues from an individual (<span class="math inline">\(\lambda_c\)</span>) and their spatial distribution given the animal’s location (<span class="math inline">\(h(\mathbf{u}| \mathbf{x})\)</span> normalised by dividing by <span class="math inline">\(H(\mathbf{x})\)</span> (@ref(eq:hsk)). The parameters of <span class="math inline">\(h()\)</span> are those of a typical detection function in <strong>secr</strong> (e.g., <span class="math inline">\(\lambda_0, \sigma\)</span>), except that the factor <span class="math inline">\(\lambda_0\)</span> cancels out of the normalised expression. The expected number of cues, given an unbounded search area, is determined by a different parameter here labelled <span class="math inline">\(\lambda_c\)</span>.</p>
<p>There are complications:</p>
<ol style="list-style-type: decimal">
<li><p>Rather than designate a new ‘real’ parameter lambdac, <strong>secr</strong> grabs the redundant intercept of the detection function (lambda0) and uses that for <span class="math inline">\(\lambda_c\)</span>. Bear this in mind when reading output from polygon or transect models.</p></li>
<li><p>If each animal can be detected at most once per detector per occasion (as with exclusive detector types ‘polygonX’ and ‘transectX’) then instead of <span class="math inline">\(\lambda(\mathbf{x})\)</span> we require a probability of detection between 0 and 1, say <span class="math inline">\(g(\mathbf{x})\)</span>. In <strong>secr</strong> the probability of detection is derived from the cumulative hazard using <span class="math inline">\(g(\mathbf{x}) = 1-\exp(-\lambda(\mathbf{x}))\)</span>. The horned lizard dataset of <span class="citation">Royle and Young (<a href="#ref-ry08">2008</a>)</span> has detector type ‘polygonX’ and their parameter ‘<span class="math inline">\(p\)</span>’ was equivalent to <span class="math inline">\(1 - \exp(-\lambda_c)\)</span> (<span class="math inline">\(0 &lt; p \le 1\)</span>). For the same scenario and parameter <span class="citation">Efford (<a href="#ref-e11">2011</a>)</span> used <span class="math inline">\(p_\infty\)</span>.</p></li>
<li><p>Unrelated to (2), detection functions in <strong>secr</strong> may model either the probability of detection (HN, HR, EX etc.) or the cumulative hazard of detection (HHN, HHR, HEX etc.) (see <code>?detectfn</code> for a list). Although probability and cumulative hazard are mostly interchangeable for point detectors, it’s not so simple for polygon and transect detectors. The integration always uses the hazard form for <span class="math inline">\(h(\mathbf{u} | \mathbf{x})\)</span> (<strong>secr</strong> <span class="math inline">\(\ge 3.0.0\)</span>)<a href="#fn44" class="footnote-ref" id="fnref44"><sup>44</sup></a>, and only hazard-based detection functions are allowed (HHN, HHR, HEX, HAN, HCG, HVP). The default function is HHN.</p></li>
</ol>
</div>
<div id="example-data-flat-tailed-horned-lizards" class="section level2" number="18.2">
<h2><span class="header-section-number">18.2</span> Example data: flat-tailed horned lizards</h2>
<p><span class="citation">Royle and Young (<a href="#ref-ry08">2008</a>)</span> reported a Bayesian analysis of data from repeated searches for flat-tailed horned lizards (<em>Phrynosoma mcallii</em>) on a 9-ha square plot in Arizona, USA. Their dataset is included in <strong>secr</strong> as <code>hornedlizardCH</code> and will be used for demonstration. See ‘?hornedlizard’ for more details.</p>
<p>The lizards were free to move across the boundary of the plot and often buried themselves when approached. Half of the 134 different lizards were seen only once in 14 searches over 17 days. Fig. 2 shows the distribution of detections within the quadrat; lines connect successive detections of the individuals that were recaptured.</p>
<p>(ref:FTHLplotcap) Locations of horned lizards on a 9-ha plot in Arizona <span class="citation">(<a href="#ref-ry08">Royle and Young 2008</a>)</span>. Grid lines are 100 m apart.</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb180-1"><a href="#cb180-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>))</span>
<span id="cb180-2"><a href="#cb180-2" tabindex="-1"></a><span class="fu">plot</span>(hornedlizardCH, <span class="at">tracks =</span> <span class="cn">TRUE</span>, <span class="at">varycol =</span> <span class="cn">FALSE</span>, <span class="at">lab1cap =</span> </span>
<span id="cb180-3"><a href="#cb180-3" tabindex="-1"></a>    <span class="cn">TRUE</span>, <span class="at">laboffset =</span> <span class="dv">8</span>, <span class="at">border =</span> <span class="dv">10</span>, <span class="at">title =</span><span class="st">&#39;&#39;</span>)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/FTHLplot-1.png" alt="(ref:FTHLplotcap)" width="384" />
<p class="caption">
(#fig:FTHLplot)(ref:FTHLplotcap)
</p>
</div>
</div>
<div id="data-input" class="section level2" number="18.3">
<h2><span class="header-section-number">18.3</span> Data input</h2>
<p>Input of data for polygon and transect detectors is described in <a href="https://www.otago.ac.nz/density/pdfs/secr-datainput.pdf">secr-datainput.pdf</a>. It is little different to input of other data for secr. The key function is <code>read.capthist</code>, which reads text files containing the polygon or transect coordinates<a href="#fn45" class="footnote-ref" id="fnref45"><sup>45</sup></a> and the capture records. Capture data should be in the ‘XY’ format of
Density (one row per record with fields in the order Session, AnimalID, Occasion, X, Y). Capture records are automatically associated with polygons on the basis of X and Y (coordinates outside any polygon give an error). Transect data are also entered as X and Y coordinates and automatically associated with transect lines.</p>
</div>
<div id="fitting-1" class="section level2" number="18.4">
<h2><span class="header-section-number">18.4</span> Fitting</h2>
<p>The function <code>secr.fit</code> is used to fit polygon or transect models by maximum likelihood, exactly as for other detectors. Any model fitting requires a habitat mask – a representation of the region around the detectors possibly occupied by the detected animals (aka the ‘area of integration’ or ‘state space’). It’s simplest to use a simple buffer around the detectors, specified via the ‘buffer’ argument of <code>secr.fit</code><a href="#fn46" class="footnote-ref" id="fnref46"><sup>46</sup></a>. For the horned lizard dataset it is safe to use the default buffer width (100 m) and the default detection function (circular bivariate normal). We use <code>trace = FALSE</code> to suppress intermediate output that would be untidy here.</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb181-1"><a href="#cb181-1" tabindex="-1"></a>FTHL.fit <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(hornedlizardCH, <span class="at">buffer =</span> <span class="dv">80</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb181-2"><a href="#cb181-2" tabindex="-1"></a><span class="fu">predict</span>(FTHL.fit)</span></code></pre></div>
<pre><code>##         link estimate SE.estimate      lcl      ucl
## D        log  8.01307    1.061701  6.18740 10.37742
## lambda0  log  0.13171    0.015128  0.10524  0.16485
## sigma    log 18.50490    1.199388 16.29950 21.00871</code></pre>
<p>The estimated density is 8.01 / ha, somewhat less than the value given by <span class="citation">Royle and Young (<a href="#ref-ry08">2008</a>)</span>; see <span class="citation">Efford (<a href="#ref-e11">2011</a>)</span> for an explanation, also <span class="citation">Marques, Thomas, and Royle (<a href="#ref-mtr11">2011</a>)</span> and <span class="citation">Dorazio (<a href="#ref-d13">2013</a>)</span>. The parameter labelled ‘lambda0’ (i.e. <span class="math inline">\(\lambda_c\)</span>) is equivalent to <span class="math inline">\(p\)</span> in <span class="citation">Royle and Young (<a href="#ref-ry08">2008</a>)</span> (using <span class="math inline">\(\hat p \approx 1 - \exp(-\hat \lambda_c)\)</span>).</p>
<p><code>FTHL.fit</code> is an object of class secr. We would use the ‘plot’ method to graph the fitted detection function :</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb183-1"><a href="#cb183-1" tabindex="-1"></a><span class="fu">plot</span>(FTHL.fit, <span class="at">xv =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">70</span>, <span class="at">ylab =</span> <span class="st">&#39;p&#39;</span>)</span></code></pre></div>
</div>
<div id="cue-data" class="section level2" number="18.5">
<h2><span class="header-section-number">18.5</span> Cue data</h2>
<p>By ‘cue’ in this context we mean a discrete sign identifiable to an individual animal by means such as microsatellite DNA. Faeces and passive hair samples may be cues. Animals may produce more than one cue per occasion. The number of cues in a specific polygon then has a discrete distribution such as Poisson, binomial or negative binomial.</p>
<p>A cue dataset is not readily available, so we simulate some cue data to demonstrate the analysis. The text file ‘polygonexample1.txt’ contains the boundary coordinates.</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb184-1"><a href="#cb184-1" tabindex="-1"></a>datadir <span class="ot">&lt;-</span> <span class="fu">system.file</span>(<span class="st">&quot;extdata&quot;</span>, <span class="at">package =</span> <span class="st">&quot;secr&quot;</span>)</span>
<span id="cb184-2"><a href="#cb184-2" tabindex="-1"></a>file1 <span class="ot">&lt;-</span> <span class="fu">paste0</span>(datadir, <span class="st">&#39;/polygonexample1.txt&#39;</span>)</span>
<span id="cb184-3"><a href="#cb184-3" tabindex="-1"></a>example1 <span class="ot">&lt;-</span> <span class="fu">read.traps</span>(<span class="at">file =</span> file1, <span class="at">detector =</span> <span class="st">&#39;polygon&#39;</span>)</span>
<span id="cb184-4"><a href="#cb184-4" tabindex="-1"></a>polygonCH <span class="ot">&lt;-</span> <span class="fu">sim.capthist</span>(example1, <span class="at">popn =</span> <span class="fu">list</span>(<span class="at">D =</span> <span class="dv">1</span>, </span>
<span id="cb184-5"><a href="#cb184-5" tabindex="-1"></a>    <span class="at">buffer =</span> <span class="dv">200</span>), <span class="at">detectfn =</span> <span class="st">&#39;HHN&#39;</span>, <span class="at">detectpar =</span> <span class="fu">list</span>(</span>
<span id="cb184-6"><a href="#cb184-6" tabindex="-1"></a>    <span class="at">lambda0 =</span> <span class="dv">5</span>, <span class="at">sigma =</span> <span class="dv">50</span>), <span class="at">noccasions =</span> <span class="dv">1</span>, <span class="at">seed =</span> <span class="dv">123</span>)</span></code></pre></div>
<p>(ref:cueplot2cap) Simulated cue data from a single search of two irregular polygons.</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb185-1"><a href="#cb185-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">2</span>))</span>
<span id="cb185-2"><a href="#cb185-2" tabindex="-1"></a><span class="fu">plot</span>(polygonCH, <span class="at">tracks =</span> <span class="cn">TRUE</span>, <span class="at">varycol =</span> <span class="cn">FALSE</span>, <span class="at">lab1cap =</span> <span class="cn">TRUE</span>,</span>
<span id="cb185-3"><a href="#cb185-3" tabindex="-1"></a>    <span class="at">laboffset =</span> <span class="dv">15</span>, <span class="at">title =</span> <span class="fu">paste</span>(<span class="st">&quot;Simulated &#39;polygon&#39; data&quot;</span>, </span>
<span id="cb185-4"><a href="#cb185-4" tabindex="-1"></a>    <span class="st">&quot;D = 1, lambda0 = 5, sigma = 50&quot;</span>))</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/cueplot2-1.png" alt="(ref:cueplot2cap)" width="480" />
<p class="caption">
(#fig:cueplot2)(ref:cueplot2cap)
</p>
</div>
<p>Our simulated sampling was a single search (noccasions = 1), and the intercept of the detection function (lambda0 = 5) is the expected number of cues that would be found per animal if the search was unbounded. The plot (Fig. @ref(fig:cueplot2)) is slightly misleading because, although ‘tracks = TRUE’ serves to link cues from the same animal, the cues are not ordered in time.</p>
<p>To fit the model by maximum likelihood we use <code>secr.fit</code> as before:</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb186-1"><a href="#cb186-1" tabindex="-1"></a>cuesim.fit <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(polygonCH, <span class="at">buffer =</span> <span class="dv">200</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb186-2"><a href="#cb186-2" tabindex="-1"></a><span class="fu">predict</span>(cuesim.fit)</span></code></pre></div>
<pre><code>##         link estimate SE.estimate      lcl     ucl
## D        log   1.1035     0.15366  0.84099  1.4478
## lambda0  log   4.3764     0.41885  3.62938  5.2771
## sigma    log  49.4464     2.43133 44.90613 54.4457</code></pre>
</div>
<div id="discretize" class="section level2" number="18.6">
<h2><span class="header-section-number">18.6</span> Discretizing polygon data</h2>
<p>An alternative way to handle polygon capthist data is to convert it to a raster representation i.e. to replace each polygon with a set of point detectors, each located at the centre of a square pixel. Point detectors (‘multi’, ‘proximity’, ‘count’ etc.) tend to be more robust and models often fit faster. They also allow habitat attributes to be associated with detectors at the scale of a pixel rather than the whole polygon. The <strong>secr</strong> function <code>discretize</code> performs the necessary conversion in a single step. Selection of an appropriate pixel size (<code>spacing</code>) is up to the user. There is a tradeoff between faster execution (larger pixels are better) and controlling artefacts from the discretization, which can be checked by comparing estimates with different levels of <code>spacing</code>.</p>
<p>Taking our example from before,</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb188-1"><a href="#cb188-1" tabindex="-1"></a>discreteCH <span class="ot">&lt;-</span> <span class="fu">discretize</span> (polygonCH, <span class="at">spacing =</span> <span class="dv">20</span>)</span>
<span id="cb188-2"><a href="#cb188-2" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">2</span>))</span>
<span id="cb188-3"><a href="#cb188-3" tabindex="-1"></a><span class="fu">plot</span>(discreteCH, <span class="at">varycol =</span> <span class="cn">FALSE</span>, <span class="at">tracks =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/discretize-1.png" alt="Discretized area search data" width="672" />
<p class="caption">
(#fig:discretize)Discretized area search data
</p>
</div>
<div class="sourceCode" id="cb189"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb189-1"><a href="#cb189-1" tabindex="-1"></a>discrete.fit <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(discreteCH, <span class="at">buffer =</span> <span class="dv">200</span>, <span class="at">detectfn =</span> </span>
<span id="cb189-2"><a href="#cb189-2" tabindex="-1"></a>    <span class="st">&#39;HHN&#39;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb189-3"><a href="#cb189-3" tabindex="-1"></a><span class="fu">predict</span>(discrete.fit)</span></code></pre></div>
<pre><code>##         link estimate SE.estimate       lcl      ucl
## D        log  1.09535    0.152767  0.834461  1.43779
## lambda0  log  0.11205    0.014492  0.087048  0.14422
## sigma    log 49.83843    2.673999 44.867030 55.36067</code></pre>
</div>
<div id="transectsearch" class="section level2" number="18.7">
<h2><span class="header-section-number">18.7</span> Transect search</h2>
<p>Transect data, as understood here, include the positions from which individuals are detected
along a linear route through 2-dimensional habitat. They <em>do not</em> include distances from the route to the location of the individual, at least, not yet. A route may be searched multiple times, and a dataset may include multiple routes, but neither of these is necessary. Searches of linear habitat such as river banks require a different approach - see the package <a href="https://cran.r-project.org/package=secrlinear/vignettes/secrlinear-vignette.pdf">secrlinear</a>.</p>
<p>We simulate some data for an imaginary wiggly transect.</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb191-1"><a href="#cb191-1" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">4</span><span class="sc">*</span>pi, <span class="at">length =</span> <span class="dv">20</span>)</span>
<span id="cb191-2"><a href="#cb191-2" tabindex="-1"></a>transect <span class="ot">&lt;-</span> <span class="fu">make.transect</span>(<span class="at">x =</span> x<span class="sc">*</span><span class="dv">100</span>, <span class="at">y =</span> <span class="fu">sin</span>(x)<span class="sc">*</span><span class="dv">300</span>, </span>
<span id="cb191-3"><a href="#cb191-3" tabindex="-1"></a>    <span class="at">exclusive =</span> <span class="cn">FALSE</span>)</span>
<span id="cb191-4"><a href="#cb191-4" tabindex="-1"></a><span class="fu">summary</span>(transect)</span></code></pre></div>
<pre><code>## Object class       traps 
## Detector type      transect 
## Number vertices    20 
## Number transects   1 
## Total length       2756.1 m 
## x-range            0 1256.6 m 
## y-range            -298.98 298.98 m</code></pre>
<div class="sourceCode" id="cb193"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb193-1"><a href="#cb193-1" tabindex="-1"></a>transectCH <span class="ot">&lt;-</span> <span class="fu">sim.capthist</span>(transect, <span class="at">popn =</span> <span class="fu">list</span>(<span class="at">D =</span> <span class="dv">2</span>, </span>
<span id="cb193-2"><a href="#cb193-2" tabindex="-1"></a>    <span class="at">buffer =</span> <span class="dv">300</span>), <span class="at">detectfn =</span> <span class="st">&#39;HHN&#39;</span>, <span class="at">detectpar =</span> <span class="fu">list</span>(</span>
<span id="cb193-3"><a href="#cb193-3" tabindex="-1"></a>    <span class="at">lambda0 =</span> <span class="fl">1.0</span>, <span class="at">sigma =</span> <span class="dv">50</span>), <span class="at">binomN =</span> <span class="dv">0</span>, <span class="at">seed =</span> <span class="dv">123</span>)</span></code></pre></div>
<p>By setting exclusive = FALSE we signal that there may be more than one detection per animal per occasion on this single transect (i.e. this is a ‘transect’ detector rather than ‘transectX’).</p>
<p>Constructing a habitat mask explicitly with <code>make.mask</code> (rather than relying on ‘buffer’ in <code>secr.fit</code>) allows us to
specify the point spacing and discard outlying points (Fig. @ref(fig:transectmask)).</p>
<p>(ref:transectmaskcap) Habitat mask (grey dots) and simulated transect data from five searches of a 2.8-km transect. Colours differ between individuals, but are not unique.</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb194-1"><a href="#cb194-1" tabindex="-1"></a>transectmask <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(transect, <span class="at">type =</span> <span class="st">&#39;trapbuffer&#39;</span>, <span class="at">buffer =</span> <span class="dv">300</span>, <span class="at">spacing =</span> <span class="dv">20</span>)</span>
<span id="cb194-2"><a href="#cb194-2" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">1</span>))</span>
<span id="cb194-3"><a href="#cb194-3" tabindex="-1"></a><span class="fu">plot</span>(transectmask, <span class="at">border =</span> <span class="dv">0</span>)</span>
<span id="cb194-4"><a href="#cb194-4" tabindex="-1"></a><span class="fu">plot</span>(transect, <span class="at">add =</span> <span class="cn">TRUE</span>, <span class="at">detpar =</span> <span class="fu">list</span>(<span class="at">lwd =</span> <span class="dv">2</span>))</span>
<span id="cb194-5"><a href="#cb194-5" tabindex="-1"></a><span class="fu">plot</span>(transectCH, <span class="at">tracks =</span> <span class="cn">TRUE</span>, <span class="at">add =</span> <span class="cn">TRUE</span>, <span class="at">title =</span> <span class="st">&#39;&#39;</span>)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/transectmask-1.png" alt="(ref:transectmaskcap)" width="672" />
<p class="caption">
(#fig:transectmask)(ref:transectmaskcap)
</p>
</div>
<p>Model fitting uses <code>secr.fit</code> as before. We specify the distribution of the number of detections per individual per occasion as Poisson (binomN = 0), although this also happens to be the default. Setting method = ‘Nelder-Mead’ is slightly more likely to yield valid estimates of standard errors than using the default method (see <a href="#technotes">Technical notes</a>).</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb195-1"><a href="#cb195-1" tabindex="-1"></a>transect.fit <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(transectCH, <span class="at">mask =</span> transectmask, </span>
<span id="cb195-2"><a href="#cb195-2" tabindex="-1"></a>    <span class="at">binomN =</span> <span class="dv">0</span>, <span class="at">method =</span> <span class="st">&#39;Nelder-Mead&#39;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>Occasional ‘ier’ error codes may be ignored (see <a href="#technotes">Technical notes</a>). The estimates are close to the true values except for sigma, which may be positively biased.</p>
<div class="sourceCode" id="cb196"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb196-1"><a href="#cb196-1" tabindex="-1"></a><span class="fu">predict</span> (transect.fit)</span></code></pre></div>
<pre><code>##         link estimate SE.estimate      lcl     ucl
## D        log   1.8527    0.196674  1.50552  2.2798
## lambda0  log   1.0415    0.080433  0.89539  1.2114
## sigma    log  53.6290    2.313387 49.28317 58.3581</code></pre>
<p>Another way to analyse transect data is to discretize it. We divide the transect into 25-m segments and then change the detector type. In the resulting capthist object the transect has been replaced by a series of proximity detectors, each at the midpoint of a segment.</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb198-1"><a href="#cb198-1" tabindex="-1"></a>snippedCH <span class="ot">&lt;-</span> <span class="fu">snip</span>(transectCH, <span class="at">by =</span> <span class="dv">25</span>)</span>
<span id="cb198-2"><a href="#cb198-2" tabindex="-1"></a>snippedCH <span class="ot">&lt;-</span> <span class="fu">reduce</span>(snippedCH, <span class="at">outputdetector =</span> <span class="st">&#39;proximity&#39;</span>)</span></code></pre></div>
<p>The same may be achieved with <code>newCH &lt;- discretize(transectCH, spacing = 25)</code>. We can fit a model using the same mask as before. The result differs in the scaling of the lambda0 parameter, but in other respects is similar to that from the transect model.</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb199-1"><a href="#cb199-1" tabindex="-1"></a>snipped.fit <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(snippedCH, <span class="at">mask =</span> transectmask, </span>
<span id="cb199-2"><a href="#cb199-2" tabindex="-1"></a>    <span class="at">detectfn =</span> <span class="st">&#39;HHN&#39;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb199-3"><a href="#cb199-3" tabindex="-1"></a><span class="fu">predict</span>(snipped.fit)</span></code></pre></div>
<pre><code>##         link estimate SE.estimate      lcl      ucl
## D        log  1.84217    0.195625  1.49689  2.26708
## lambda0  log  0.19312    0.018034  0.16089  0.23182
## sigma    log 53.67901    2.321128 49.31908 58.42437</code></pre>
</div>
<div id="polygonshape" class="section level2" number="18.8">
<h2><span class="header-section-number">18.8</span> More on polygons</h2>
<p>The implementation in <strong>secr</strong> allows any number of disjunct polygons or non-intersecting transects.</p>
<p>Polygons may be irregularly shaped, but there are some limitations in the default implementation. Polygons may not be concave in an east-west direction, in the sense that there are more than two intersections with a vertical
line. Sometimes east-west concavity may be fixed by rotating the polygon and its associated data points (see function
<code>rotate</code>). Polygons should not contain holes, and the polygons used on any one occasion should not overlap.</p>
<p>(ref:irregularcap) The polygon on the left is not allowed because its boundary is intersected by a vertical line at more than two points.</p>
<div class="figure">
<img src="figures/irregular.png" alt="(ref:irregularcap)" width="90%" />
<p class="caption">
(#fig:irregular)(ref:irregularcap)
</p>
</div>
<div id="solutions-for-non-conforming-polygons" class="section level3" number="18.8.1">
<h3><span class="header-section-number">18.8.1</span> Solutions for non-conforming polygons</h3>
<ol style="list-style-type: decimal">
<li>Break into parts</li>
</ol>
<p>One solution to ‘east-west concavity’ is to break the offending polygon into two or more parts. For this you need to know which vertices belong in which part, but that is (usually) easily determined from a plot. In this real example we recognise vertices 11 and 23 as critical, and split the polygon there. Note the need to include the clip vertices in both polygons, and to maintain the order of vertices. Both <code>example2</code> and <code>newpoly</code> are traps objects.</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb201-1"><a href="#cb201-1" tabindex="-1"></a>file2 <span class="ot">&lt;-</span> <span class="fu">paste0</span>(datadir, <span class="st">&#39;/polygonexample2.txt&#39;</span>)</span>
<span id="cb201-2"><a href="#cb201-2" tabindex="-1"></a>example2 <span class="ot">&lt;-</span> <span class="fu">read.traps</span>(<span class="at">file =</span> file2, <span class="at">detector =</span> <span class="st">&#39;polygon&#39;</span>)</span>
<span id="cb201-3"><a href="#cb201-3" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>), <span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>))</span>
<span id="cb201-4"><a href="#cb201-4" tabindex="-1"></a><span class="fu">plot</span>(example2)</span>
<span id="cb201-5"><a href="#cb201-5" tabindex="-1"></a><span class="fu">text</span>(example2<span class="sc">$</span>x, example2<span class="sc">$</span>y, <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(example2), <span class="at">cex =</span> <span class="fl">0.7</span>)</span>
<span id="cb201-6"><a href="#cb201-6" tabindex="-1"></a>newpoly <span class="ot">&lt;-</span> <span class="fu">make.poly</span> (<span class="fu">list</span>(<span class="at">p1 =</span> example2[<span class="dv">11</span><span class="sc">:</span><span class="dv">23</span>,], </span>
<span id="cb201-7"><a href="#cb201-7" tabindex="-1"></a>  <span class="at">p2 =</span> example2[<span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">11</span>, <span class="dv">23</span><span class="sc">:</span><span class="dv">27</span>),]))</span></code></pre></div>
<pre><code>## No errors found :-)</code></pre>
<div class="sourceCode" id="cb203"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb203-1"><a href="#cb203-1" tabindex="-1"></a><span class="fu">plot</span>(newpoly, <span class="at">label =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/polylimit-1.png" alt="Splitting a non-conforming polygon" width="95%" />
<p class="caption">
(#fig:polylimit)Splitting a non-conforming polygon
</p>
</div>
<p>Attributes such as covariates and usage must be rebuilt by hand.</p>
<ol start="2" style="list-style-type: decimal">
<li>Pointwise testing</li>
</ol>
<p>Another solution is to evaluate whether each point chosen dynamically by the integration code lies inside the polygon of interest. This is inevitably slower than the default algorithm that assumes all points between the lower and upper intersections lie within the polygon. Select the slower, more general option by setting <code>details = list(convexpolygon = FALSE)</code>.</p>
</div>
</div>
<div id="technotes" class="section level2" number="18.9">
<h2><span class="header-section-number">18.9</span> Technical notes</h2>
<p>Fitting models for polygon detectors with <code>secr.fit</code> requires the hazard function to be integrated in two-dimensions many
times. In <strong>secr</strong> &gt;= 4.4 this is done with repeated one-dimensional Gaussian quadrature using the C++ function ‘integrate’ in RcppNumerical [R-RcppNumerical].</p>
<p>Polygon and transect SECR models seem to be prone to numerical problems in estimating the information matrix (negative Hessian), which flow on into poor variance estimates and missing values for the standard errors of ‘real’ parameters. At the time of writing these seem to be overcome by overriding the default maximization method (Newton-Raphson in ‘nlm’) and using, for example, “method = ‘BFGS’”. Another solution, perhaps more reliable, is to compute the information matrix independently by setting ‘details = list(hessian = ’fdhess’)’ in the call to <code>secr.fit</code>. Yet another approach is to apply <code>secr.fit</code> with “method = ‘none’” to a previously fitted model to compute the variances.</p>
<p>The algorithm for finding a starting point in parameter space for the numerical maximization is not entirely reliable; it may be necessary to specify the ‘start’ argument of <code>secr.fit</code> manually, remembering that the values should be on the link scale (default log for D, lambda0 and sigma).</p>
<p>Data for polygons and transects are unlike those from detectors such as traps in several respects:</p>
<ul>
<li><p>The association between vertices in a ‘traps’ object and polygons or transects resides in an attribute ‘polyID’ that is out of sight, but may be retrieved with the <code>polyID</code> or <code>transectID</code> functions. If the attribute is NULL, all vertices are assumed to belong to one polygon or transect.</p></li>
<li><p>The x-y coordinates for each detection are stored in the attribute ‘detectedXY’ of a capthist object. To retrieve these
coordinates use the function <code>xy</code>. Detections are ordered by occasion, animal, and detector (i.e., polyID).</p></li>
<li><p><code>subset</code> or <code>split</code> applied to a polygon or transect ‘traps’ object operate at the level of whole polygons or transects, not vertices (rows).</p></li>
<li><p><code>usage</code> also applies to whole polygons or transects. The option of specifying varying usage by occasion is not fully tested for these detector types.</p></li>
<li><p>The interpretation of detection functions and their parameters is subtly different; the detection function must be integrated over 1-D or 2-D rather than yielding a probability directly (see <span class="citation">Efford (<a href="#ref-e11">2011</a>)</span>).</p></li>
</ul>
<!--chapter:end:16-polygondetectors.Rmd-->
</div>
</div>
<div id="mark-resight" class="section level1" number="19">
<h1><span class="header-section-number">19</span> Mark-resight models</h1>
<!-- ## Mark--resight -->
<!-- Mark--resight data include sampling occasions on which previously marked animals were recorded, but new animals were not distinguished from each other. **secr** 4.6 provides a suite of spatial models for these data, as documented in [secr-markresight.pdf]. Two general classes of spatial mark--resight model are included: those in which the marking process is modelled (we call these spatial capture--mark--resight models), and those in which the process is not modelled and pre-marked animals are assumed to follow some distribution (e.g., uniform across a known area) (sighting-only or mark--resight models). Mark--resight models in **secr** 4.6 discard some spatial information in the unmarked sightings -- information that is used in the models of Chandler and Royle (2013) and Sollmann et al. (2013). This results in some (probably small) loss of precision, and requires an adjustment for overdispersion to ensure confidence intervals have good coverage properties. The vignette [secr-markresight.pdf] should be consulted. -->
<p>In capture–recapture, all newly detected unmarked animals become marked and are distinguishable in future. Some field protocols also involve ‘resighting’ occasions on which previously marked animals are identified but newly detected animals are not marked. We call these ‘mark–resight’ data. <span class="citation">McClintock and White (<a href="#ref-mw12">2012</a>)</span> provide an excellent summary of non-spatial mark–resight methods. The extension of spatially explicit capture–recapture models for mark–resight data was begun by <span class="citation">R. Sollmann et al. (<a href="#ref-sgpsmspo13">2013</a>)</span>, and spatial mark–resight models were applied by <span class="citation">Rich et al. (<a href="#ref-rksnmapdbed14">2014</a>)</span> and <span class="citation">Rutledge et al. (<a href="#ref-rswmd15">2015</a>)</span>. <span class="citation">Whittington, Hebblewhite, and Chandler (<a href="#ref-whc18">2018</a>)</span> describe a major Bayesian application.</p>
<p>Here we follow the implementation of spatially explicit mark–resight models for closed populations by <span class="citation">Efford and Hunter (<a href="#ref-eh18">2018</a>)</span>. They discards some spatial information in the unmarked sightings – information that is used in the models of <span class="citation">Chandler and Royle (<a href="#ref-cr13">2013</a>)</span> and <span class="citation">R. Sollmann et al. (<a href="#ref-sgpsmspo13">2013</a>)</span>. This results in some (probably small) loss of precision, and requires an adjustment for overdispersion to ensure confidence intervals have good coverage properties.</p>
<!-- Include eh18 in Theory? -->
<p>The historical development of mark–resight models has stressed the resighting component of mark–resight data; the sampling process leading to marking is not modelled. Modelling of the sighting data then requires some assumption about the distribution of the marked animals. Most commonly, marked animals are assumed to be a random sample from a defined population, and that may be achievable in some situations<a href="#fn47" class="footnote-ref" id="fnref47"><sup>47</sup></a>. However, when a spatially distributed population is sampled with localized detectors such as traps, animals living near the traps have a higher chance of becoming marked, and the marked animals are not representative of a well-defined population. The difficulty may be overcome by spatially modelling both the marking and resighting processes. This requires that data on detection locations were collected during the marking phase, and that the spatial distribution of marking effort was recorded. <span class="citation">Matechou et al. (<a href="#ref-mmpcl13">2013</a>)</span> analysed non-spatial capture–recapture–resighting data jointly with counts of unmarked individuals, and the core capture–mark–resight models in <strong>secr</strong> are their spatial equivalent (see also <span class="citation">Whittington, Hebblewhite, and Chandler (<a href="#ref-whc18">2018</a>)</span>).</p>
<p>Rather than modelling the marking process we may take the traditional path, i.e. assume a certain spatial distribution for the marked individuals. Typically, the distribution is assumed to be uniform over a known area (e.g., <span class="citation">R. Sollmann et al. (<a href="#ref-sgpsmspo13">2013</a>)</span>, <span class="citation">Rich et al. (<a href="#ref-rksnmapdbed14">2014</a>)</span>). The number of marked individuals remaining at the time of resighting may be known or <a href="#unknownmarked">unknown</a>. We use ‘capture–mark–resight’ for models that include the marking process and ‘sighting-only’ for models in which the spatial distribution of marks is assumed.</p>
<p>Not all detector types and options in <strong>secr</strong> will work with mark–resight data. See <a href="#MRlimitations">Limitations</a> for a list of known constraints (some will be mentioned along the way). See the <a href="#appendix1">step-by-step guide</a> for a quick introduction.</p>
<div id="overview" class="section level2" number="19.1">
<h2><span class="header-section-number">19.1</span> Overview</h2>
<p>Following <span class="citation">Efford and Hunter (<a href="#ref-eh18">2018</a>)</span>,</p>
<ul>
<li>the population is assumed to follow a (possibly inhomogeneous) Poisson distribution in space</li>
<li>detection histories of marked animals are modelled as usual in SECR</li>
<li>counts of unmarked sightings are modelled with a Poisson distribution</li>
<li>overdispersion in the counts (relative to a Poisson distribution) is estimated by simulation and used in a pseudo-likelihood addressed; this has minimal effect on the estimates themselves, but improves coverage of confidence intervals</li>
</ul>
<p>Unidentified sightings of marked animals are treated as independent of identified sightings. This is an approximation, but its effect on estimates is believed to be negligible.</p>
<p>The core models are listed in Table @ref(tab:MRclassification). These may be customized in various ways, particularly by specifying the assumed distribution of marked animals for sighting-only models. Each model may be fitted with or without a parameter for incomplete identification of marked animals when they are resighted (<a href="#pID"><code>pID</code></a>).</p>
<table>
<caption>(#tab:MRclassification) Classification of mark–resight models available in <strong>secr</strong>. ‘Capture–mark–resight’ models include the marking process; ‘sighting-only’ models rest on prior knowledge or assumptions regarding where animals have been marked. For sighting-only data some detection histories may be all-zero.</caption>
<colgroup>
<col width="29%" />
<col width="22%" />
<col width="47%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Data</th>
<th align="left">Pre-marking<sup>1</sup></th>
<th align="left">Code</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Capture–mark–resight</td>
<td align="left">none</td>
<td align="left">NA</td>
</tr>
<tr class="even">
<td align="left">Sighting-only</td>
<td align="left">Known <span class="math inline">\(n_0\)</span></td>
<td align="left"><code>details = list(knownmarks = TRUE)</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Unknown <span class="math inline">\(n_0\)</span></td>
<td align="left"><code>details = list(knownmarks = FALSE)</code></td>
</tr>
</tbody>
</table>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(n_0\)</span> is the number of marked individuals in the study area at the time of the sighting surveys.</li>
</ol>
<p>Mark–resight data are represented in <strong>secr</strong> by a capthist data object, with minor extensions (Table @ref(tab:MRattributes)). We describe the structure for a single-session capthist object, which records detections of each marked animal over <span class="math inline">\(S\)</span> occasions at any of <span class="math inline">\(K\)</span> detectors. Detectors on sighting occasions may be of the usual binary proximity (‘proximity’) or count proximity (‘count’) types<a href="#fn48" class="footnote-ref" id="fnref48"><sup>48</sup></a>. Detectors on marking occasions may be any combination of these types and multi-catch traps. Area search (‘polygon’) and transect search (‘transect’) types are not yet supported for either phase when there are sighting occasions: <a href="#areasearches">discretization</a> is recommended.</p>
<table>
<caption>(#tab:MRattributes) Special attributes of data objects for mark–resight analysis in <strong>secr</strong>.</caption>
<colgroup>
<col width="7%" />
<col width="14%" />
<col width="77%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Object</th>
<th align="left">Attribute</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">traps</td>
<td align="left"><code>markocc</code></td>
<td align="left">Occasions may be marking (1), sighting (0) or unresolved (-1)</td>
</tr>
<tr class="even">
<td align="left">capthist</td>
<td align="left"><code>Tu</code></td>
<td align="left">Counts of unmarked animals</td>
</tr>
<tr class="odd">
<td align="left">capthist</td>
<td align="left"><code>Tm</code></td>
<td align="left">Counts of marked animals not identified</td>
</tr>
<tr class="even">
<td align="left">capthist</td>
<td align="left"><code>Tn</code></td>
<td align="left">Counts of sightings with unknown mark status (not modelled)</td>
</tr>
<tr class="odd">
<td align="left">mask</td>
<td align="left"><code>marking</code><sup>1</sup></td>
<td align="left">Distribution of pre-marked animals (<a href="#areaspecification">sighting-only data</a>; optional)</td>
</tr>
</tbody>
</table>
<ol style="list-style-type: decimal">
<li><code>marking</code> is the name of a special mask covariate, accessed like other covariates.</li>
</ol>
<div id="marking-and-sighting-occasions" class="section level3" number="19.1.1">
<h3><span class="header-section-number">19.1.1</span> Marking and sighting occasions</h3>
<p>Sampling occasions (intervals) are either marking occasions or sighting occasions. On marking occasions any recaptured animals are also recorded<a href="#fn49" class="footnote-ref" id="fnref49"><sup>49</sup></a>. On sighting occasions newly caught animals are released unmarked. The body of the capthist object has one row for each individual detected on at least one marking occasion, and one column for each occasion, whether marking or sighting.</p>
<p>The ‘traps’ object, a required attribute of any capthist object, has its own optional attribute <code>markocc</code> to distinguish marking occasions (1) from sighting occasions (0) (e.g., c(1,0,0,0,0) for marking on one occasion followed by four resighting occasions). A capthist object is recognised as a mark–resight dataset if its <code>traps</code> has a <code>markocc</code> attribute with at least one sighting occasion (i.e. <code>!all(markocc)</code>). Marking occasions and sighting occasions may be interspersed.</p>
</div>
<div id="sighting-only-data" class="section level3" number="19.1.2">
<h3><span class="header-section-number">19.1.2</span> Sighting-only data</h3>
<p>A sighting-only dataset has a <code>markocc</code> attribute with no marking occasions. Two scenarios are possible: either the capthist object includes a sighting history for each marked animal (including all-zero histories for any not re-sighted), or it includes sighting histories only for the re-sighted animals. In the latter case the number of marked animals at the time of sampling is unknown, and the fitted model must take account of this (see <a href="#unknownmarked">Number of marks unknown</a>).</p>
</div>
<div id="sightings-of-unmarked-animals" class="section level3" number="19.1.3">
<h3><span class="header-section-number">19.1.3</span> Sightings of unmarked animals</h3>
<p>In addition to the marking and sighting events of known individuals recorded in the body of the capthist object, there will usually be sightings of unmarked animals. These data take the form of a matrix with the number of detections of unmarked animals at each detector (row) on each sampling occasion (column). A single searched polygon or transect is one detector and hence contributes a single row. Columns corresponding to marking occasions are all-zero. This matrix is stored as attribute <code>Tu</code> of the capthist object.</p>
<p>Instead of providing <code>Tu</code> as a matrix, the counts may be summed over occasions (<code>Tu</code> is a vector of detector-specific counts), or provided as the grand total (<code>Tu</code> is a single integer). These alternatives have definite limitations:</p>
<ul>
<li>occasion-specific or detector-specific models cannot be fitted</li>
<li>plot, summary and verify are less informative</li>
<li>cannot subset by occasion or detector</li>
<li>AIC should not be used compare models differing in summarisation</li>
<li>cannot mix markocc -1 and 0</li>
</ul>
</div>
<div id="unidentified-sightings-of-marked-animals" class="section level3" number="19.1.4">
<h3><span class="header-section-number">19.1.4</span> Unidentified sightings of marked animals</h3>
<p>An observer may be able to to determine that an animal is marked, but be unable to positively identify it as a particular individual. The number of sightings of marked but unidentified individuals is stored as capthist attribute <code>Tm</code>, which uses the same formats as <code>Tu</code>.</p>
</div>
<div id="sightings-of-unknown-status" class="section level3" number="19.1.5">
<h3><span class="header-section-number">19.1.5</span> Sightings of unknown status</h3>
<p>Sightings for which the mark status could not be determined are a further category of sighting on sighting occasions. For example, the identifying mark may not be visible in a photograph because of the orientation the animal. The number of sightings with unknown mark status is generally not used in the models (but see <a href="#unresolvedsightings">unresolved sightings</a>). However, it is good practice to account for these observations. They may be stored as capthist attribute <code>Tn</code> and will appear in summaries.</p>
</div>
<div id="unresolvedsightings" class="section level3" number="19.1.6">
<h3><span class="header-section-number">19.1.6</span> Unresolved sightings</h3>
<p>Sometimes the sighting method does not allow marked animals to be distinguished from unmarked animals. Sighting occasions of this type are coded with ‘-1’ in the markocc vector. On these occasions the counts of all sightings (‘unresolved sightings’) stored in the appropriate column of <code>Tn</code>, the corresponding columns of <code>Tu</code> and <code>Tm</code> are all-zero, and no sightings of marked animals appear in the capthist object. Models comprising one or more marking occasions and only unresolved sightings (e.g., <code>markocc &lt;- c(1, -1, -1, -1, -1)</code>) may be fitted in <strong>secr</strong>, but there are constraints (see <a href="#appendix2">Sighting without attention to marking</a>).</p>
</div>
</div>
<div id="data-preparation" class="section level2" number="19.2">
<h2><span class="header-section-number">19.2</span> Data preparation</h2>
<p>Data on marked animals may be formatted and read as usual with <code>read.capthist</code> (<a href="https://www.otago.ac.nz/density/pdfs/secr-datainput.pdf">secr-datainput.pdf</a>). Each identified sighting of a marked individuals appears as a row in the ‘capture’ file, like any other detection. The <code>markocc</code> attribute may be set as an argument of <code>read.capthist</code> or assigned later.</p>
<p>Sighting data for unmarked animals (Tu) are provided separately as a <span class="math inline">\(K \times S\)</span> matrix, where <span class="math inline">\(K\)</span> is the number of detectors and <span class="math inline">\(S\)</span> is the total number of occasions (including marking occasions). Elements in the matrix are either binary (0/1) for proximity detectors, or whole numbers (0, 1, 2,…) for count, polygon and transect detectors. Sightings of marked animals that are not identified to individual (Tm) are optionally provided in a separate <span class="math inline">\(K \times S\)</span> matrix. Usually you will read these data from separate text files or spreadsheets. Sightings with unknown mark status (Tn) may also be provided, but will be ignored in analyses except for occasions with code -1 in <code>markocc</code>.</p>
<p>The function <code>addSightings</code> may be used to merge these matrices of sighting data with an existing mark–resight capthist object, i.e. to set its attributes <code>Tu</code> and <code>Tm</code>. There are also custom extraction and replacement functions for sighting-related attributes (<code>markocc</code>, <code>Tu</code> and <code>Tm</code>). <code>addSightings</code> also allows input from text files in which the first column is a session identifier (see <a href="#appendix1">Step-by-step guide</a> for an example).</p>
<p>Let’s assume you have prepared the files <code>MRCHcapt.txt</code>, <code>MRCHcapt.txt</code>, <code>Tu.txt</code> and <code>Tm.txt</code>. <a href="#appendix5">Simulated examples</a> can be found in the extdata folder of the <strong>secr</strong> distribution (version 4.4.3 and above). This code can be used to build a mark–resight capthist object:</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb204-1"><a href="#cb204-1" tabindex="-1"></a><span class="fu">library</span>(secr)</span>
<span id="cb204-2"><a href="#cb204-2" tabindex="-1"></a>olddir <span class="ot">&lt;-</span> <span class="fu">setwd</span>(<span class="fu">system.file</span>(<span class="st">&quot;extdata&quot;</span>, <span class="at">package =</span> <span class="st">&quot;secr&quot;</span>))</span>
<span id="cb204-3"><a href="#cb204-3" tabindex="-1"></a>MRCH <span class="ot">&lt;-</span> <span class="fu">read.capthist</span>(<span class="st">&quot;MRCHcapt.txt&quot;</span>, <span class="st">&quot;MRCHtrap.txt&quot;</span>, <span class="at">detector =</span> <span class="fu">c</span>(<span class="st">&quot;multi&quot;</span>, </span>
<span id="cb204-4"><a href="#cb204-4" tabindex="-1"></a>                      <span class="fu">rep</span>(<span class="st">&quot;proximity&quot;</span>,<span class="dv">4</span>)), <span class="at">markocc =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>))</span>
<span id="cb204-5"><a href="#cb204-5" tabindex="-1"></a>MRCH <span class="ot">&lt;-</span> <span class="fu">addSightings</span>(MRCH, <span class="st">&quot;Tu.txt&quot;</span>, <span class="st">&quot;Tm.txt&quot;</span>)</span>
<span id="cb204-6"><a href="#cb204-6" tabindex="-1"></a><span class="fu">session</span>(MRCH) <span class="ot">&lt;-</span> <span class="st">&quot;Simulated mark-resight data&quot;</span></span>
<span id="cb204-7"><a href="#cb204-7" tabindex="-1"></a><span class="fu">setwd</span>(olddir)</span></code></pre></div>
<div id="data-summary" class="section level3" number="19.2.1">
<h3><span class="header-section-number">19.2.1</span> Data summary</h3>
<p>The <code>summary</code> method for capthist objects recognises mark–resight data and provides a summary of the <code>markocc</code>, <code>Tu</code>, and <code>Tm</code> attributes.</p>
<div class="sourceCode" id="cb205"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb205-1"><a href="#cb205-1" tabindex="-1"></a><span class="fu">summary</span>(MRCH)</span></code></pre></div>
<pre><code>## Object class       capthist 
## Detector type      multi, proximity (4) 
## Detector number    36 
## Average spacing    20 m 
## x-range            0 100 m 
## y-range            0 100 m 
## 
## Marking occasions
##  1 2 3 4 5
##  1 0 0 0 0
## 
## Counts by occasion 
##                    1  2  3  4  5 Total
## n                 70 15 16 19 17   137
## u                 70  0  0  0  0    70
## f                 28 24 13  3  2    70
## M(t+1)            70 70 70 70 70    70
## losses             0  0  0  0  0     0
## detections        70 17 18 28 23   156
## detectors visited 31 14 15 18 13    91
## detectors used    36 36 36 36 36   180
## 
## Sightings by occasion 
##           1  2  3  4  5 Total
## ID        0 17 18 28 23    86
## Not ID    0  8  5 11  7    31
## Unmarked  0  7  9  6  9    31
## Uncertain 0  0  0  0  0     0
## Total     0 32 32 45 39   148</code></pre>
<p>The main table of counts is calculated differently for sighting-only and capture–mark–resight data. When <code>markocc</code> includes marking occasions the counts refer to marking, recaptures and sightings of marked animals. This means that u (number of new individuals) is always zero on sighting occasions, and M(t+1) increases only on marking occasions. When <code>markocc</code> records that the data are sighting-only, the main table of counts summarises identified sightings of previously marked animals, accumulating u and M(t+1) as if all occasions were marking occasions.</p>
<p>On sighting occasions the row ‘detections’ in Counts by occasion corresponds to the number of sightings of marked and identified individuals (‘ID’) in Sightings by occasion. Other detections in the sightings table are additional to the main table.</p>
<p>The default plot of a mark–resight capthist object shows only marked and identified individuals. To make a separate plot of the sightings of unmarked individuals, either use the same function with <code>type = "sightings"</code> or use <code>sightingPlot</code>:</p>
<div class="sourceCode" id="cb207"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb207-1"><a href="#cb207-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>), <span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>), <span class="at">pty =</span> <span class="st">&#39;s&#39;</span>)</span>
<span id="cb207-2"><a href="#cb207-2" tabindex="-1"></a><span class="co"># petal plot with key</span></span>
<span id="cb207-3"><a href="#cb207-3" tabindex="-1"></a><span class="fu">plot</span>(MRCH, <span class="at">type =</span> <span class="st">&quot;sightings&quot;</span>, <span class="at">border =</span> <span class="dv">20</span>)</span>
<span id="cb207-4"><a href="#cb207-4" tabindex="-1"></a><span class="fu">occasionKey</span>(MRCH, <span class="at">cex =</span> <span class="fl">0.7</span>, <span class="at">rad =</span> <span class="dv">5</span>, <span class="at">px =</span> <span class="fl">0.96</span>, <span class="at">py =</span> <span class="fl">0.88</span>, <span class="at">xpd =</span> <span class="cn">TRUE</span>)</span>
<span id="cb207-5"><a href="#cb207-5" tabindex="-1"></a><span class="co"># bubble plot</span></span>
<span id="cb207-6"><a href="#cb207-6" tabindex="-1"></a><span class="fu">sightingPlot</span>(MRCH, <span class="st">&quot;Tu&quot;</span>, <span class="at">mean =</span> <span class="cn">FALSE</span>, <span class="at">border =</span> <span class="dv">20</span>, <span class="at">fill =</span> <span class="cn">TRUE</span>, <span class="at">col =</span> <span class="st">&quot;blue&quot;</span>, </span>
<span id="cb207-7"><a href="#cb207-7" tabindex="-1"></a>             <span class="at">legend =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>), <span class="at">px =</span> <span class="fl">1.0</span>, <span class="at">py =</span> <span class="fu">c</span>(<span class="fl">0.85</span>,<span class="fl">0.72</span>), <span class="at">xpd =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/plotMRCH-1.png" alt="Two ways to plot sightings of unmarked animals. Petals in the lefthand plot indicate the number of sightings, except that marking occcasions are shown as a solid dot. `mean = FALSE` causes `sightingPlot` to use the total over all occasions rather than the mean. Other settings are used here only to customise the layout and colour of the plots." width="576" />
<p class="caption">
(#fig:plotMRCH)Two ways to plot sightings of unmarked animals. Petals in the lefthand plot indicate the number of sightings, except that marking occcasions are shown as a solid dot. <code>mean = FALSE</code> causes <code>sightingPlot</code> to use the total over all occasions rather than the mean. Other settings are used here only to customise the layout and colour of the plots.
</p>
</div>
</div>
<div id="data-checks" class="section level3" number="19.2.2">
<h3><span class="header-section-number">19.2.2</span> Data checks</h3>
<p>The <code>verify</code> method for capthist objects checks that mark–resight data satisfy</p>
<ul>
<li>the length of <code>markocc</code> matches the number of sampling occasions <span class="math inline">\(S\)</span></li>
<li>animals are not marked on sighting occasions, or sighted on marking occasions</li>
<li>the dimensions of matrices with counts of sighted animals (<code>Tu</code>, <code>Tm</code>) match the rest of the capthist object</li>
<li>sightings are made only when detector usage is &gt; 0</li>
<li>counts are whole numbers.</li>
</ul>
<p>Checks are performed by default when a model is fitted with <code>secr.fit</code>, or when <code>verify</code> is called independently.</p>
</div>
<div id="different-layouts-for-marking-and-sighting" class="section level3" number="19.2.3">
<h3><span class="header-section-number">19.2.3</span> Different layouts for marking and sighting</h3>
<p>Detector layouts are likely to differ between marking and sighting occasions. This can be accommodated within a single, merged detector layout using detector- and occasion-specific usage codes. See <a href="#appendix3">here</a> for a function to create a single-session mark–resight traps object from two components.</p>
</div>
<div id="simulating-markresight-data" class="section level3" number="19.2.4">
<h3><span class="header-section-number">19.2.4</span> Simulating mark–resight data</h3>
<p>Mark–resight data may be generated with function <code>sim.resight</code>. In this example, one grid of detectors is used for both marking and for resighting, but the detection rate is higher on the initial (marking) occasion.</p>
<div class="sourceCode" id="cb208"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb208-1"><a href="#cb208-1" tabindex="-1"></a>grid <span class="ot">&lt;-</span> <span class="fu">make.grid</span>(<span class="at">detector =</span> <span class="fu">c</span>(<span class="st">&quot;multi&quot;</span>, <span class="fu">rep</span>(<span class="st">&quot;proximity&quot;</span>,<span class="dv">4</span>)))</span>
<span id="cb208-2"><a href="#cb208-2" tabindex="-1"></a><span class="fu">markocc</span>(grid) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb208-3"><a href="#cb208-3" tabindex="-1"></a>g0mr <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.3</span>, <span class="fl">0.1</span>, <span class="fl">0.1</span>, <span class="fl">0.1</span>, <span class="fl">0.1</span>)</span>
<span id="cb208-4"><a href="#cb208-4" tabindex="-1"></a>simMRCH <span class="ot">&lt;-</span> <span class="fu">sim.resight</span>(grid, <span class="at">detectpar=</span><span class="fu">list</span>(<span class="at">g0 =</span> g0mr, <span class="at">sigma =</span> <span class="dv">25</span>),  </span>
<span id="cb208-5"><a href="#cb208-5" tabindex="-1"></a>    <span class="at">popn =</span> <span class="fu">list</span>(<span class="at">D =</span> <span class="dv">30</span>), <span class="at">pID =</span> <span class="fl">0.7</span>)</span></code></pre></div>
<p>If all elements of <code>markocc</code> are zero then a separate mechanism is used to pre-mark a fraction <code>pmark</code> of individuals selected at random from the population. The resulting sighting-only data may include all-zero sighting histories for marked animals. Use the argument <code>markingmask</code> to simulate marking of animals with centres in a certain subregion.</p>
</div>
<div id="input-of-sighting-only-data" class="section level3" number="19.2.5">
<h3><span class="header-section-number">19.2.5</span> Input of sighting-only data</h3>
<p>For sighting-only data we postulate that the marked animals are a random sample of individuals from a known spatial distribution, possibly a specified region. The body of the capthist object then comprises sightings of known individuals, with other sightings in attributes <code>Tu</code> and <code>Tm</code>. Marked animals that were known to be present but not resighted are included as ‘all-zero’ detection histories in the body of the capthist object. These detection histories are input by including a record in the detection file for each marked-but-unsighted individual, distinguished by 0 (zero) in the ‘occasion’ field, and with an arbitrary (but not missing) detector ID or coordinates in the next field(s).</p>
</div>
</div>
<div id="model-fitting-1" class="section level2" number="19.3">
<h2><span class="header-section-number">19.3</span> Model fitting</h2>
<p>Properly prepared, a capthist object includes all the data for fitting a mark–resight model<a href="#fn50" class="footnote-ref" id="fnref50"><sup>50</sup></a>. It is only necessary to call <code>secr.fit</code>. Here is an example in which we use a coarse mask (<code>nx = 32</code> instead of the default <code>nx = 64</code>) to speed things up. The predictor ‘ts’ and the new ‘real’ parameter <a href="#pID"><code>pID</code></a> are explained in following sections.</p>
<div class="sourceCode" id="cb209"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb209-1"><a href="#cb209-1" tabindex="-1"></a>mask <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(<span class="fu">traps</span>(MRCH), <span class="at">nx =</span> <span class="dv">32</span>, <span class="at">buffer =</span> <span class="dv">100</span>)</span>
<span id="cb209-2"><a href="#cb209-2" tabindex="-1"></a>fit0 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(MRCH, <span class="at">model =</span> <span class="fu">list</span>(g0 <span class="sc">~</span> ts), <span class="at">mask =</span> mask, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb209-3"><a href="#cb209-3" tabindex="-1"></a><span class="fu">predict</span>(fit0, <span class="at">newdata =</span> <span class="fu">data.frame</span>(<span class="at">ts =</span> <span class="fu">factor</span>(<span class="fu">c</span>(<span class="st">&quot;M&quot;</span>,<span class="st">&quot;S&quot;</span>))))</span></code></pre></div>
<pre><code>## $`ts = M`
##        link  estimate SE.estimate       lcl       ucl
## D       log 25.878634   3.4102062 20.010368 33.467835
## g0    logit  0.376348   0.0530742  0.279231  0.484535
## sigma   log 25.309207   1.9729034 21.728320 29.480235
## pID   logit  0.674240   0.0548421  0.559231  0.771501
## 
## $`ts = S`
##        link   estimate SE.estimate        lcl       ucl
## D       log 25.8786341   3.4102062 20.0103680 33.467835
## g0    logit  0.0930034   0.0125262  0.0711902  0.120632
## sigma   log 25.3092072   1.9729034 21.7283198 29.480235
## pID   logit  0.6742398   0.0548421  0.5592307  0.771501</code></pre>
<p>This example relies on the built-in <code>autoini</code> function to provide starting parameter values for the numerical maximization. However, the automatic values may not work with complex mark–resight models. It is not worth continuing if the first likelihood evaluation fails, as indicated by LogLik NaN when <code>trace = TRUE</code>. Then you should experiment with the <code>start</code> argument until you find values that work.</p>
<div id="adjustoverdispersion" class="section level3" number="19.3.1">
<h3><span class="header-section-number">19.3.1</span> Adjustment for overdispersion</h3>
<p>The default confidence intervals have poor coverage when the data include counts in Tu or Tm. This is due to overdispersion of the summed counts, caused by a quirk of the model specification: covariation is ignored in the multivariate Poisson model used to describe the counts. A simple protocol fixes the problem:</p>
<ol style="list-style-type: decimal">
<li>Fit a model assuming no overdispersion,</li>
<li>Estimate the overdispersion by simulating at the initial estimates, and</li>
<li>Re-fit the model (or at least re-estimate the variance-covariance matrix) using an overdispersion-adjusted pseudo-likelihood.</li>
</ol>
<p>Steps (2) and (3) may be performed together in one call to <code>secr.fit</code>. In the example below, the first line repeats the model specification, while the second line provides the previously fitted model as a starting point and calls for <code>nsim</code> simulations to estimate overdispersion (c-hat in MARK parlance).</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb211-1"><a href="#cb211-1" tabindex="-1"></a>fit1 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(MRCH, <span class="at">model =</span> <span class="fu">list</span>(g0<span class="sc">~</span>ts), <span class="at">mask =</span> mask, <span class="at">trace =</span> <span class="cn">FALSE</span>, </span>
<span id="cb211-2"><a href="#cb211-2" tabindex="-1"></a>                <span class="at">start =</span> fit0, <span class="at">details =</span> <span class="fu">list</span>(<span class="at">nsim =</span> <span class="dv">10000</span>))</span></code></pre></div>
<pre><code>## sims completed</code></pre>
<div class="sourceCode" id="cb213"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb213-1"><a href="#cb213-1" tabindex="-1"></a><span class="fu">predict</span>(fit1, <span class="at">newdata =</span> <span class="fu">data.frame</span>(<span class="at">ts =</span> <span class="fu">factor</span>(<span class="fu">c</span>(<span class="st">&quot;M&quot;</span>,<span class="st">&quot;S&quot;</span>))))</span></code></pre></div>
<pre><code>## $`ts = M`
##        link  estimate SE.estimate       lcl       ucl
## D       log 24.301701   3.3948265 18.505556 31.913264
## g0    logit  0.437851   0.0741753  0.301422  0.584375
## sigma   log 25.529632   2.0306230 21.849768 29.829245
## pID   logit  0.665783   0.0644173  0.530406  0.778436
## 
## $`ts = S`
##        link   estimate SE.estimate        lcl       ucl
## D       log 24.3017013   3.3948265 18.5055557 31.913264
## g0    logit  0.0944934   0.0134665  0.0711979  0.124390
## sigma   log 25.5296316   2.0306230 21.8497679 29.829245
## pID   logit  0.6657829   0.0644173  0.5304055  0.778436</code></pre>
<p>For this dataset the adjustment had a small effect on the confidence intervals (0% increase in interval length). The estimates of overdispersion are saved in the <code>details$chat</code> component of the fitted model, and we can see that they are close to 1.0. Note that the adjustment is strictly for overdispersion in the unmarked sightings, and the effect of that overdispersion is ‘diluted’ by other components of the likelihood.</p>
<div class="sourceCode" id="cb215"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb215-1"><a href="#cb215-1" tabindex="-1"></a>fit1<span class="sc">$</span>details<span class="sc">$</span>chat[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>]</span></code></pre></div>
<pre><code>##     Tu     Tm 
## 1.8465 1.6979</code></pre>
<p>A shortcut is to specify <code>method = "none"</code> at Step 3 to block re-maximization of the pseudolikelihood: then only the variance-covariance matrix, likelihood and related parameters will be re-computed. Pre-determined values of <span class="math inline">\(\hat c\)</span> may be provided as input in the <code>chat</code> component of <code>details</code>; if <code>nsim = 0</code> the input <code>chat</code> will be used without further simulation (example in <a href="#appendix1">Step-by-step guide</a> Step 8).</p>
<p>Stochasticity in the estimate of overdispersion causes parameter estimates to vary. The problem is minimized by running many simulations (say, <code>nsim = 10000</code>), which has relatively little effect on total execution time.</p>
<p>CAVEAT: the multi-threaded simulation code does not allow for potential non-independence of random number streams across threads. If this is a concern then set ncores = 1 to block multi-threading. See also <code>?secrRNG</code>.</p>
</div>
<div id="ts" class="section level3" number="19.3.2">
<h3><span class="header-section-number">19.3.2</span> Different parameter values on marking and sighting occasions</h3>
<p>Marking and sighting occasions share parameters by default. This may make sense for the spatial scale parameter (sigma ~ 1), but it is unlikely to hold for the baseline rate (intercept) g0 or lambda0. <em>Density estimates can be very biased if the difference is ignored</em><a href="#fn51" class="footnote-ref" id="fnref51"><sup>51</sup></a>. A new canned predictor ‘ts’ is introduced to distinguish marking and sighting occasions. For example g0 ~ ts will fit two levels of g0, one for marking occasions and one for sighting occasions. The same can be achieved with <code>g0 ~ tcov, timecov = factor(2-markocc)</code>.</p>
<p>To see the values associated with each level of ‘ts’ (i.e., marking and sighting occasions) we specify the <code>newdata</code> argument of <code>predict.secr</code>, as in <a href="#adjustoverdispersion">Adjustment for overdispersion</a>.</p>
</div>
<div id="pID" class="section level3" number="19.3.3">
<h3><span class="header-section-number">19.3.3</span> Proportion identified</h3>
<p>If some sightings are of marked animals that cannot be identified to individual then a further ‘real’ parameter is required for the proportion identified. This is called <code>pID</code> in <strong>secr</strong>. <code>pID</code> is estimated by default, whether or not the capthist object has attribute <code>Tm</code>, because failure to identify marked animals affects the re-detection probability of marked individuals. For data with a single initial marking occasion, a model estimating <code>pID</code> is exactly equivalent to a learned response model (<code>g0 ~ b</code>) in the absence of <code>Tm</code> (same density estimate, same likelihood).</p>
<p><code>pID</code> may be fixed at an arbitrary value, just like other real parameters. For example, a call to secr.fit with <code>fixed = list(pID = 1.0)</code> implies that every sighted individual that was already marked could be identified.</p>
<p>Only a subset of the usual predictors is appropriate for <code>pID</code>. Use of predictors other than <code>session</code>, <code>Session</code>, or the names of any session or trap covariate will raise a warning.</p>
<!-- ##Conditional likelihood -->
<!-- If density is homogeneous then it is possible to estimate SECR detection parameters by maximizing the likelihood conditioning on $n$, the number of marked individuals (`secr.fit(..., CL = TRUE`). Density is then estimated as a derived parameter $D = n/a(\hat \theta)$ where $a(\hat \theta)$ is the effective sampling area (Borchers and Efford 2008). This expands the set of available models. For example, conditional likelihood models may include individual covariates such as sex: -->
<!-- ```{r CL, eval = FALSE, cache = TRUE} -->
<!-- ## generate random 'sex' covariate -->
<!-- covariates(MRCH) <- data.frame(sex = sample(c("f","m"), nrow(MRCH), TRUE)) -->
<!-- fitCL <- secr.fit(MRCH, model = g0~ts + sex, CL = TRUE, mask = mask, trace = FALSE) -->
<!-- derived(fitCL) -->
<!-- fit <- secr.fit(MRCH, model = g0~ts, mask = mask, trace = FALSE) -->
<!-- derived(fit) -->
<!-- ``` -->
<!-- Counts of unmarked sightings (Tu) cannot be used in CL models because the expected number of sightings depends on density, which is not a parameter in the model. An attempt to use `CL = TRUE` with a capthist object including Tu will raise a warning, and those data will be ignored. Unidentified marked sightings (Tm) will be modelled; this allows `pID` to be estimated, but generally does not improve estimates of density. -->
</div>
<div id="areaspecification" class="section level3" number="19.3.4">
<h3><span class="header-section-number">19.3.4</span> Specifying distribution of pre-marked animals (sighting-only models)</h3>
<p>By default, animals in a sighting-only dataset are assumed to have been marked throughout the habitat mask. However, uniform marking across a subregion of the habitat mask, or any other known distribution, may be specified by including a mask covariate named ‘marking’. For example,</p>
<div class="sourceCode" id="cb217"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb217-1"><a href="#cb217-1" tabindex="-1"></a>mask <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(grid)</span>
<span id="cb217-2"><a href="#cb217-2" tabindex="-1"></a>d <span class="ot">&lt;-</span> <span class="fu">distancetotrap</span>(mask, grid)</span>
<span id="cb217-3"><a href="#cb217-3" tabindex="-1"></a><span class="fu">covariates</span>(mask) <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">marking =</span> d <span class="sc">&lt;</span> <span class="dv">60</span>)</span></code></pre></div>
<p>If the mask is used in <code>secr.fit</code> with a sighting-only dataset, the fitted model will ‘understand’ that animals centred within 60 m of the grid had a uniform probability of marking, and no animals from beyond this limit were marked. Note that the area is supposed to contain the <em>centres</em> of all marked animals; this is not the same as a searched polygon. If the covariate is missing then all animals in the mask are assumed to have had an equal chance of becoming marked. The ‘marking’ covariate is actually more general, in that it can represent any known or assumed probability distribution for the locations of marked animals within the mask: values are automatically normalized by dividing by their sum. Be warned that assumptions about the extent of marking directly affect the estimated density.</p>
<p>It is possible in principle that the marked animals are distributed over an area larger than the habitat mask. The software does not directly allow for this. An easy solution is to increase the size of the habitat mask, but take care to control its coarseness (<code>spacing</code>), and be aware of the effect on estimates of <span class="math inline">\(N\)</span>, and on the sampling variance if <code>distribution = "binomial"</code>.</p>
</div>
<div id="unknownmarked" class="section level3" number="19.3.5">
<h3><span class="header-section-number">19.3.5</span> Number of marks unknown (sighting-only models)</h3>
<p>Sighting-only datasets may entail the further complication that the number of marked animals in the population at the time of resighting is unknown (Model 3). This can happen if enough time has passed for some marked animals to have died or emigrated. It also arises if individuation relies on unique natural marks, but these are missing from some individuals (Rich et al. 2014).</p>
<p>The resighting data do not include any all-zero detection histories, as the only way to know for certain that a marked animal is still present is to sight it at least once. The theory nevertheless allows a spatial model to be fitted<a href="#fn52" class="footnote-ref" id="fnref52"><sup>52</sup></a>.</p>
<p>Data preparation is exactly as for sighting-only models with known number of marks, except that there are no all-zero histories. The unknown-marks model is fitted by setting the <code>secr.fit</code> argument <code>details = list(knownmarks = FALSE)</code>, (possibly along with other <code>details</code> components).</p>
</div>
<div id="covariates-groups-and-finite-mixtures" class="section level3" number="19.3.6">
<h3><span class="header-section-number">19.3.6</span> Covariates, groups and finite mixtures</h3>
<p>Conditional-likelihood models are generally not useful for mark-resight analyses. Individual covariates therefore should not be used in mark-resight models in <strong>secr</strong>. Other covariates (at the level of session, occasion, or detector) should work in any of the models.</p>
<p>The mark–resight models in <strong>secr</strong> do not currently allow groups (g). Finite mixtures, including ‘hcov’ models, are only partly implemented.</p>
</div>
<div id="discarding-unmarked-sightings" class="section level3" number="19.3.7">
<h3><span class="header-section-number">19.3.7</span> Discarding unmarked sightings</h3>
<p>Sighting data can be highly problematic because of difficulty in reading marks and determining when consecutive sightings are independent. A conservative approach is to discard the counts of unmarked sightings (Tu) and unidentified marked animals (Tm), while retaining sighting data on marked animals. This works for capture–mark–resight data (marking occasions included), but not for all-sighting data (which rely on unmarked sightings to estimate detection parameters). The parameter pID is confounded with the sighting-phase g0 so we fix it at 1.0. The likelihood does not require adjustment for overdispersion of unmarked sightings.</p>
<div class="sourceCode" id="cb218"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb218-1"><a href="#cb218-1" tabindex="-1"></a><span class="fu">Tu</span>(MRCH) <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb218-2"><a href="#cb218-2" tabindex="-1"></a><span class="fu">Tm</span>(MRCH) <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb218-3"><a href="#cb218-3" tabindex="-1"></a>mask <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(<span class="fu">traps</span>(MRCH), <span class="at">nx =</span> <span class="dv">32</span>, <span class="at">buffer =</span> <span class="dv">100</span>)</span>
<span id="cb218-4"><a href="#cb218-4" tabindex="-1"></a>fit2 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(MRCH, <span class="at">model =</span> <span class="fu">list</span>(g0<span class="sc">~</span>ts), <span class="at">fixed =</span> <span class="fu">list</span>(<span class="at">pID =</span> <span class="fl">1.0</span>), <span class="at">mask =</span> mask, </span>
<span id="cb218-5"><a href="#cb218-5" tabindex="-1"></a>  <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb218-6"><a href="#cb218-6" tabindex="-1"></a><span class="fu">predict</span>(fit2, <span class="at">newdata =</span> <span class="fu">data.frame</span>(<span class="at">ts =</span> <span class="fu">factor</span>(<span class="fu">c</span>(<span class="st">&quot;M&quot;</span>,<span class="st">&quot;S&quot;</span>))))</span></code></pre></div>
<pre><code>## $`ts = M`
##        link estimate SE.estimate        lcl       ucl
## D       log  18.1896    2.966183 13.2412417 24.987330
## g0    logit   0.9446    0.150667  0.0569578  0.999792
## sigma   log  26.8962    2.328076 22.7065290 31.858989
## 
## $`ts = S`
##        link   estimate SE.estimate        lcl        ucl
## D       log 18.1896476  2.96618258 13.2412417 24.9873303
## g0    logit  0.0635488  0.00885126  0.0482547  0.0832662
## sigma   log 26.8962274  2.32807607 22.7065290 31.8589886</code></pre>
<p>Confidence interval length has increased by -12% over the full estimates (we did throw out a lot of data), but we expect the result to be more robust.</p>
</div>
<div id="comparing-models" class="section level3" number="19.3.8">
<h3><span class="header-section-number">19.3.8</span> Comparing models</h3>
<p>Fitted models may be compared by AIC or AICc. Models can be compared when they describe the same data. In practice this means</p>
<ol style="list-style-type: decimal">
<li><p>Do not compare models with and without either sighting attribute (Tu, Tm), and</p></li>
<li><p>Do not compare sighting-only models with different pre-marking assumptions (the <code>marking</code> covariate of the mask).</p></li>
</ol>
</div>
</div>
<div id="MRlimitations" class="section level2" number="19.4">
<h2><span class="header-section-number">19.4</span> Limitations</h2>
<p>These limitations apply when fitting mark–resight models in <strong>secr</strong>:</p>
<ul>
<li>only ‘multi’, ‘proximity’ and ‘count’ detector types are allowed</li>
<li>groups (g) are not allowed</li>
<li><a href="#hybrid-mixtures">hybrid mixtures</a> with known class membership (‘hcov’) have not been implemented for mark-resight data</li>
<li>some <strong>secr</strong> functions do not yet handle mark–resight data or models. These are mostly flagged with a Warning on their documentation page.</li>
</ul>
<p>If the sighting phase is an area or transect search then it may be possible to analyse the data by rasterizing the areas or transects (function <code>discretize</code>).</p>
<div id="warning" class="section level3" number="19.4.1">
<h3><span class="header-section-number">19.4.1</span> Warning</h3>
<p>The implementation of spatially explicit mark–resight models is still somewhat limited. It is intended that mark–resight models work across other capabilities of <strong>secr</strong>, particularly</p>
<ul>
<li>data may span multiple sessions (<a href="#Multisession">multi-session</a> capthist objects can contain mark–resight data)</li>
<li>mark–resight may be augmented with telemetry data (<code>addTelemetry</code>), but joint telemetry models have not been tested and should be used with care</li>
<li>fxi.contour() and related functions (probability density plots of centres of detected animals)</li>
<li>finite mixture (h2) models are allowed for detection parameters, including <code>pID</code></li>
<li>modelAverage() and collate()</li>
<li>linear habitat masks are allowed (as in the package <strong>secrlinear</strong>)</li>
</ul>
<p>However, these uses have not been tested much, where they have been tested at all..</p>
<p>It is unclear what sample size should be used for sample-size-adjusted AIC (AICc). This is one more reason to use <code>AIC(..., criterion = "AIC")</code>. Currently <strong>secr</strong> uses the number of detection histories of marked individuals, as for other models.</p>
</div>
<div id="pitfalls" class="section level3" number="19.4.2">
<h3><span class="header-section-number">19.4.2</span> Pitfalls</h3>
<p>The likelihood for the sighting-only model with unknown number of marks (Model 3) has a boundary corresponding to the density of detected marks in the marking mask (true density cannot be less than this). This is ordinarily not a problem (estimated density will usually be larger). However, for multi-session data with a common density parameter it is quite possible for the number of marks in a particular session to exceed the threshold. The log-likelihood function then returns ‘NA’; although maximization may proceed, variance estimation is likely to fail. A possible (but slow) workaround is to combine the multiple sessions in a single-session capthist (you’re on your own here - there is no function for this).</p>
</div>
</div>
<div id="appendix1" class="section level2" number="19.5">
<h2><span class="header-section-number">19.5</span> Step-by-step guide</h2>
<p>This guide should help you get started on a simple mark–resight analysis.</p>
<ol style="list-style-type: decimal">
<li><p>Decide where your study fits in Table 1 and determine the <code>markocc</code> vector. Do you have data for the marking process (capture–mark–resight data), or will this be assumed (sighting-only data)? For capture–mark–resight data, <code>markocc</code> will have ‘1’ for modelled marking occasions and ‘0’ for sighting occasions (e.g., <code>markocc(traps) &lt;- c(1,0,0,0,0)</code> for one marking occasion and four sighting occasions). For sighting-only data, <code>markocc</code> is ‘0’ for every occasion (omit the quotation marks). If you have sighting-only data, is the number of marked animals known or unknown?</p></li>
<li><p>Prepare a capture file and detector layout file as usual (<a href="https://www.otago.ac.nz/density/pdfs/secr-datainput.pdf">secr-datainput.pdf</a>). Sightings of marked animals are included as if they were recaptures. If your data are sighting-only and the number of marked animals is known then include a capture record with occasion = 0 for any marked animal that was never resighted. If your detector type is ‘count’ (sampling with replacement; repeat observations possible at each detector) then repeat data rows in the capture file as necessary.</p></li>
<li><p>Prepare separate text files for sightings of unmarked animals (Tu) and unidentified sightings of marked animals (Tm). Each row has a session identifier followed by the number of sightings for one detector on each occasion (always zero in columns corresponding to marking occasions). The session identifier is used to split the file when the data span multiple sessions; it should be constant for a single-session capthist. The files will be read with <code>read.table</code>, so if necessary consult the help for that function. The start of a file for 1 marking occasion and 4 sighting occasions might look like this:</p>
<pre><code>S1 0 0 0 0 0  
S1 0 1 0 2 0  
S1 0 0 1 1 1  
S1 0 0 0 1 0  
S1 0 1 0 0 1  
S1 0 0 2 0 0  
...  </code></pre></li>
<li><p>Input data</p></li>
</ol>
<div class="sourceCode" id="cb221"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb221-1"><a href="#cb221-1" tabindex="-1"></a><span class="fu">library</span>(secr)</span>
<span id="cb221-2"><a href="#cb221-2" tabindex="-1"></a>datadir <span class="ot">&lt;-</span> <span class="fu">system.file</span>(<span class="st">&quot;extdata&quot;</span>, <span class="at">package =</span> <span class="st">&quot;secr&quot;</span>)  <span class="co"># or choose your own</span></span>
<span id="cb221-3"><a href="#cb221-3" tabindex="-1"></a>olddir <span class="ot">&lt;-</span> <span class="fu">setwd</span>(datadir)</span>
<span id="cb221-4"><a href="#cb221-4" tabindex="-1"></a>CH <span class="ot">&lt;-</span> <span class="fu">read.capthist</span>(<span class="st">&quot;MRCHcapt.txt&quot;</span>, <span class="st">&quot;MRCHtrap.txt&quot;</span>, <span class="at">detector =</span> <span class="fu">c</span>(<span class="st">&quot;multi&quot;</span>, </span>
<span id="cb221-5"><a href="#cb221-5" tabindex="-1"></a>                    <span class="fu">rep</span>(<span class="st">&quot;proximity&quot;</span>,<span class="dv">4</span>)), <span class="at">markocc =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>), <span class="at">verify =</span> <span class="cn">FALSE</span>)</span>
<span id="cb221-6"><a href="#cb221-6" tabindex="-1"></a>CH <span class="ot">&lt;-</span> <span class="fu">addSightings</span>(CH, <span class="st">&quot;Tu.txt&quot;</span>, <span class="st">&quot;Tm.txt&quot;</span>)</span></code></pre></div>
<pre><code>## No errors found :-)</code></pre>
<div class="sourceCode" id="cb223"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb223-1"><a href="#cb223-1" tabindex="-1"></a><span class="fu">setwd</span>(olddir)   <span class="co"># return to original folder</span></span></code></pre></div>
<ol start="5" style="list-style-type: decimal">
<li>Review data</li>
</ol>
<div class="sourceCode" id="cb224"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb224-1"><a href="#cb224-1" tabindex="-1"></a><span class="fu">summary</span>(CH)</span></code></pre></div>
<pre><code>## Object class       capthist 
## Detector type      multi, proximity (4) 
## Detector number    36 
## Average spacing    20 m 
## x-range            0 100 m 
## y-range            0 100 m 
## 
## Marking occasions
##  1 2 3 4 5
##  1 0 0 0 0
## 
## Counts by occasion 
##                    1  2  3  4  5 Total
## n                 70 15 16 19 17   137
## u                 70  0  0  0  0    70
## f                 28 24 13  3  2    70
## M(t+1)            70 70 70 70 70    70
## losses             0  0  0  0  0     0
## detections        70 17 18 28 23   156
## detectors visited 31 14 15 18 13    91
## detectors used    36 36 36 36 36   180
## 
## Sightings by occasion 
##           1  2  3  4  5 Total
## ID        0 17 18 28 23    86
## Not ID    0  8  5 11  7    31
## Unmarked  0  7  9  6  9    31
## Uncertain 0  0  0  0  0     0
## Total     0 32 32 45 39   148</code></pre>
<p>RPSV with <code>CC = TRUE</code> gives a crude estimate of the spatial scale parameter <code>sigma</code>.</p>
<div class="sourceCode" id="cb226"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb226-1"><a href="#cb226-1" tabindex="-1"></a><span class="fu">RPSV</span>(CH, <span class="at">CC =</span> <span class="cn">TRUE</span>)   </span></code></pre></div>
<pre><code>## [1] 20.234</code></pre>
<ol start="6" style="list-style-type: decimal">
<li>Design an appropriate habitat mask, representing the region from which animals are potentially detected (sighted). Most simply this is got by buffering around the detectors, for example applying a 100-m buffer:</li>
</ol>
<div class="sourceCode" id="cb228"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb228-1"><a href="#cb228-1" tabindex="-1"></a>mask <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(<span class="fu">traps</span>(CH), <span class="at">nx =</span> <span class="dv">32</span>, <span class="at">buffer =</span> <span class="dv">100</span>)</span></code></pre></div>
<ol start="7" style="list-style-type: decimal">
<li>Fit a null model and adjust for overdispersion</li>
</ol>
<div class="sourceCode" id="cb229"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb229-1"><a href="#cb229-1" tabindex="-1"></a>fit0 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(CH, <span class="at">mask =</span> mask, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb229-2"><a href="#cb229-2" tabindex="-1"></a>fit0 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(CH, <span class="at">mask =</span> mask, <span class="at">trace =</span> <span class="cn">FALSE</span>, <span class="at">start =</span> fit0, </span>
<span id="cb229-3"><a href="#cb229-3" tabindex="-1"></a>                 <span class="at">details =</span> <span class="fu">list</span>(<span class="at">nsim =</span> <span class="dv">10000</span>))</span></code></pre></div>
<pre><code>## sims completed</code></pre>
<div class="sourceCode" id="cb231"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb231-1"><a href="#cb231-1" tabindex="-1"></a><span class="fu">predict</span>(fit0)</span></code></pre></div>
<pre><code>##        link  estimate SE.estimate       lcl       ucl
## D       log 17.119298   2.6268693 12.694996 23.085502
## g0    logit  0.220358   0.0343355  0.160394  0.294865
## sigma   log 24.509968   1.8108890 21.209886 28.323516
## pID   logit  0.283761   0.0437893  0.206170  0.376696</code></pre>
<ol start="8" style="list-style-type: decimal">
<li>Consider other detection models</li>
</ol>
<ul>
<li>model with different marking and sighting rates</li>
</ul>
<div class="sourceCode" id="cb233"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb233-1"><a href="#cb233-1" tabindex="-1"></a>fitts <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(CH, <span class="at">model =</span> g0 <span class="sc">~</span> ts, <span class="at">mask =</span> mask, <span class="at">trace =</span> <span class="cn">FALSE</span>,</span>
<span id="cb233-2"><a href="#cb233-2" tabindex="-1"></a>                  <span class="at">details =</span> <span class="fu">list</span>(<span class="at">chat =</span> fit0<span class="sc">$</span>details<span class="sc">$</span>chat))</span>
<span id="cb233-3"><a href="#cb233-3" tabindex="-1"></a><span class="fu">predict</span>(fitts, <span class="at">newdata =</span> <span class="fu">data.frame</span>(<span class="at">ts =</span> <span class="fu">c</span>(<span class="st">&quot;M&quot;</span>,<span class="st">&quot;S&quot;</span>)))</span></code></pre></div>
<pre><code>## $`ts = M`
##        link  estimate SE.estimate       lcl       ucl
## D       log 22.257106   3.3757109 16.561559 29.911361
## g0    logit  0.551749   0.1214372  0.319815  0.763163
## sigma   log 25.891575   2.1140910 22.068450 30.377015
## pID   logit  0.651042   0.0841039  0.474534  0.793998
## 
## $`ts = S`
##        link   estimate SE.estimate        lcl       ucl
## D       log 22.2571062   3.3757109 16.5615593 29.911361
## g0    logit  0.0975956   0.0159123  0.0705449  0.133529
## sigma   log 25.8915747   2.1140910 22.0684504 30.377015
## pID   logit  0.6510417   0.0841039  0.4745338  0.793998</code></pre>
<div class="sourceCode" id="cb235"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb235-1"><a href="#cb235-1" tabindex="-1"></a><span class="fu">AIC</span>(fit0, fitts, <span class="at">criterion =</span> <span class="st">&quot;AIC&quot;</span>)[,<span class="sc">-</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">6</span>)]</span></code></pre></div>
<pre><code>##                         model npar  logLik    AIC   dAIC AICwt
## fitts D~1 g0~ts sigma~1 pID~1    5 -521.35 1052.7  0.000     1
## fit0   D~1 g0~1 sigma~1 pID~1    4 -552.17 1112.3 59.631     0</code></pre>
<p>Better model fit was achieved by estimating different detection rates on marking and sighting occasions, and the estimates from the null model should be discarded. We now reveal that the data were simulated with D = 30 animals/ha, g0(marking) = 0.3, g0(sighting) = 0.1, sigma = 25 m and pID = 0.7: confidence intervals for the estimates from model ‘fitts’ comfortably cover these values.</p>
<p>We have used the initial null-model estimates of <span class="math inline">\(\hat c\)</span> to adjust the later model. It may be better to use the <span class="math inline">\(\hat c\)</span> of the larger (more general) model. The AIC values compared are strictly quasi-AIC values as they use the pseudolikelihood.</p>
<ol start="9" style="list-style-type: decimal">
<li>Analyses for other data types</li>
</ol>
<ul>
<li>marked animals all identified on resighting</li>
</ul>
<p>In this case we would want to block estimation of the parameter <code>pID</code> by fixing it at 1.0:</p>
<div class="sourceCode" id="cb237"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb237-1"><a href="#cb237-1" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(CH, <span class="at">mask =</span> mask, <span class="at">fixed =</span> <span class="fu">list</span>(<span class="at">pID =</span> <span class="dv">1</span>), <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb237-2"><a href="#cb237-2" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(CH, <span class="at">mask =</span> mask, <span class="at">fixed =</span> <span class="fu">list</span>(<span class="at">pID =</span> <span class="dv">1</span>), <span class="at">trace =</span> <span class="cn">FALSE</span>, </span>
<span id="cb237-3"><a href="#cb237-3" tabindex="-1"></a>                <span class="at">start =</span> fit, <span class="at">details =</span> <span class="fu">list</span>(<span class="at">nsim =</span> <span class="dv">10000</span>))</span>
<span id="cb237-4"><a href="#cb237-4" tabindex="-1"></a><span class="fu">predict</span>(fit)</span></code></pre></div>
<ul>
<li>sighting-only data with unknown number of marks (assume previous marking uniform throughout mask)</li>
</ul>
<div class="sourceCode" id="cb238"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb238-1"><a href="#cb238-1" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(CH, <span class="at">mask =</span> mask, <span class="at">trace =</span> <span class="cn">FALSE</span>, </span>
<span id="cb238-2"><a href="#cb238-2" tabindex="-1"></a>                <span class="at">details =</span> <span class="fu">list</span>(<span class="at">knownmarks =</span> <span class="cn">FALSE</span>))</span>
<span id="cb238-3"><a href="#cb238-3" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(CH, <span class="at">mask =</span> mask, <span class="at">trace =</span> <span class="cn">FALSE</span>, </span>
<span id="cb238-4"><a href="#cb238-4" tabindex="-1"></a>    <span class="at">details =</span> <span class="fu">list</span>(<span class="at">knownmarks =</span> <span class="cn">FALSE</span>, <span class="at">nsim =</span> <span class="dv">10000</span>))</span>
<span id="cb238-5"><a href="#cb238-5" tabindex="-1"></a><span class="fu">predict</span>(fit)</span></code></pre></div>
</div>
<div id="miscellaneous" class="section level2" number="19.6">
<h2><span class="header-section-number">19.6</span> Miscellaneous</h2>
<div id="appendix2" class="section level3" number="19.6.1">
<h3><span class="header-section-number">19.6.1</span> Sighting without attention to marking</h3>
<p>When sighting occasions never distinguish between marked and unmarked animals, the parameter <code>pID</code> is redundant and cannot be estimated. If no action is taken it will appear in the fitted model as the starting value (default 0.7) with zero variance. It is preferable to suppress this by fixing it to some arbitrary value (e.g., <code>fixed = list(pID = 1.0)</code>).</p>
<p>The contribution of unresolved sightings to the estimates is likely to be small.</p>
<ol style="list-style-type: decimal">
<li>Estimation of the spatial scale parameter (sigma) rests entirely on recaptures of marked animals within and between any marking occasions. The unresolved counts carry a little spatial information (Chandler and Royle 2013), but this is discarded in the <strong>secr</strong> implementation and cannot contribute to estimating sigma (see also <a href="#adjustoverdispersion">Adjustment for overdispersion</a>).</li>
<li>It will usually be necessary to fit a distinct level of the intercept parameter lambda0 on the sighting occasions (perhaps using the predictor <a href="#ts"><code>ts</code></a>).</li>
</ol>
<p>Nevertheless, it may be useful to model unresolved counts in a joint analysis of a larger dataset.</p>
</div>
<div id="appendix3" class="section level3" number="19.6.2">
<h3><span class="header-section-number">19.6.2</span> Combining marking and sighting detector layouts</h3>
<p>Here is a function to create a single-session mark–resight traps object from two components. ‘trapsM’ and ‘trapsR’ are <strong>secr</strong> traps objects for marking and resighting occasions respectively. ‘markocc’ is an integer vector distinguishing marking (1) and sighting (-1, 0) occasions. The value returned is a combined traps object with usage attribute based on <code>markocc</code>. Detectors shared between the marking and sighting layouts are duplicated in the result; this may slow down model fitting, but it is otherwise not a problem.</p>
<div class="sourceCode" id="cb239"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb239-1"><a href="#cb239-1" tabindex="-1"></a>trapmerge <span class="ot">&lt;-</span> <span class="cf">function</span> (trapsM, trapsR, markocc){</span>
<span id="cb239-2"><a href="#cb239-2" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(<span class="fu">usage</span>(trapsM)) <span class="sc">|</span> <span class="sc">!</span><span class="fu">is.null</span>(<span class="fu">usage</span>(trapsR)))</span>
<span id="cb239-3"><a href="#cb239-3" tabindex="-1"></a>        <span class="fu">warning</span>(<span class="st">&quot;discarding existing usage data&quot;</span>)</span>
<span id="cb239-4"><a href="#cb239-4" tabindex="-1"></a>    KM <span class="ot">&lt;-</span> <span class="fu">nrow</span>(trapsM)</span>
<span id="cb239-5"><a href="#cb239-5" tabindex="-1"></a>    KR <span class="ot">&lt;-</span> <span class="fu">nrow</span>(trapsR)</span>
<span id="cb239-6"><a href="#cb239-6" tabindex="-1"></a>    S <span class="ot">&lt;-</span> <span class="fu">length</span>(markocc)</span>
<span id="cb239-7"><a href="#cb239-7" tabindex="-1"></a>    notmarking <span class="ot">&lt;-</span> markocc<span class="sc">&lt;</span><span class="dv">1</span></span>
<span id="cb239-8"><a href="#cb239-8" tabindex="-1"></a>    newdetector <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">detector</span>(trapsM)[<span class="dv">1</span>], <span class="fu">detector</span>(trapsR)[<span class="dv">1</span>])[notmarking<span class="sc">+</span><span class="dv">1</span>]</span>
<span id="cb239-9"><a href="#cb239-9" tabindex="-1"></a>    <span class="fu">detector</span>(trapsM) <span class="ot">&lt;-</span> <span class="fu">detector</span>(trapsR)[<span class="dv">1</span>]</span>
<span id="cb239-10"><a href="#cb239-10" tabindex="-1"></a>    <span class="fu">usage</span>(trapsM) <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">as.integer</span>(<span class="sc">!</span>notmarking), <span class="at">byrow =</span> <span class="cn">TRUE</span>, </span>
<span id="cb239-11"><a href="#cb239-11" tabindex="-1"></a>                            <span class="at">nrow =</span> KM, <span class="at">ncol =</span> S)</span>
<span id="cb239-12"><a href="#cb239-12" tabindex="-1"></a>    <span class="fu">usage</span>(trapsR) <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">as.integer</span>(notmarking), <span class="at">byrow =</span> <span class="cn">TRUE</span>, </span>
<span id="cb239-13"><a href="#cb239-13" tabindex="-1"></a>                            <span class="at">nrow =</span> KR, <span class="at">ncol =</span> S)</span>
<span id="cb239-14"><a href="#cb239-14" tabindex="-1"></a>    trps <span class="ot">&lt;-</span> <span class="fu">rbind</span>(trapsM, trapsR)</span>
<span id="cb239-15"><a href="#cb239-15" tabindex="-1"></a>    <span class="co"># Note: nrow(trps) == KM + KR</span></span>
<span id="cb239-16"><a href="#cb239-16" tabindex="-1"></a>    <span class="fu">detector</span>(trps) <span class="ot">&lt;-</span> newdetector</span>
<span id="cb239-17"><a href="#cb239-17" tabindex="-1"></a>    <span class="fu">markocc</span>(trps) <span class="ot">&lt;-</span> markocc</span>
<span id="cb239-18"><a href="#cb239-18" tabindex="-1"></a>    trps</span>
<span id="cb239-19"><a href="#cb239-19" tabindex="-1"></a>}</span></code></pre></div>
<p>This demonstration uses only 9 marking points and 25 re-sighting points.</p>
<div class="sourceCode" id="cb240"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb240-1"><a href="#cb240-1" tabindex="-1"></a>gridM <span class="ot">&lt;-</span> <span class="fu">make.grid</span>(<span class="at">nx =</span> <span class="dv">3</span>, <span class="at">ny =</span> <span class="dv">3</span>, <span class="at">detector =</span> <span class="st">&quot;multi&quot;</span>)</span>
<span id="cb240-2"><a href="#cb240-2" tabindex="-1"></a>gridR <span class="ot">&lt;-</span> <span class="fu">make.grid</span>(<span class="at">nx =</span> <span class="dv">5</span>, <span class="at">ny =</span> <span class="dv">5</span>, <span class="at">detector =</span> <span class="st">&quot;proximity&quot;</span>)</span>
<span id="cb240-3"><a href="#cb240-3" tabindex="-1"></a>combined <span class="ot">&lt;-</span> <span class="fu">trapmerge</span>(gridM, gridR, <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>))</span>
<span id="cb240-4"><a href="#cb240-4" tabindex="-1"></a><span class="fu">detector</span>(combined)</span></code></pre></div>
<pre><code>## [1] &quot;multi&quot;     &quot;multi&quot;     &quot;proximity&quot; &quot;proximity&quot; &quot;proximity&quot;</code></pre>
<div class="sourceCode" id="cb242"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb242-1"><a href="#cb242-1" tabindex="-1"></a><span class="co"># show usage for first 16 detectors of 34 in the combined layout</span></span>
<span id="cb242-2"><a href="#cb242-2" tabindex="-1"></a><span class="fu">usage</span>(combined)[<span class="dv">1</span><span class="sc">:</span><span class="dv">16</span>,]</span></code></pre></div>
<pre><code>##    1 2 3 4 5
## 1  1 1 0 0 0
## 2  1 1 0 0 0
## 3  1 1 0 0 0
## 4  1 1 0 0 0
## 5  1 1 0 0 0
## 6  1 1 0 0 0
## 7  1 1 0 0 0
## 8  1 1 0 0 0
## 9  1 1 0 0 0
## 10 0 0 1 1 1
## 11 0 0 1 1 1
## 12 0 0 1 1 1
## 13 0 0 1 1 1
## 14 0 0 1 1 1
## 15 0 0 1 1 1
## 16 0 0 1 1 1</code></pre>
</div>
<div id="appendix5" class="section level3" number="19.6.3">
<h3><span class="header-section-number">19.6.3</span> Simulation code</h3>
<p>This code was used to simulate data for the initial demonstration.</p>
<div class="sourceCode" id="cb244"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb244-1"><a href="#cb244-1" tabindex="-1"></a><span class="fu">library</span>(secr)</span>
<span id="cb244-2"><a href="#cb244-2" tabindex="-1"></a>grid <span class="ot">&lt;-</span> <span class="fu">make.grid</span>(<span class="at">detector =</span> <span class="fu">c</span>(<span class="st">&quot;multi&quot;</span>, <span class="fu">rep</span>(<span class="st">&quot;proximity&quot;</span>,<span class="dv">4</span>)))</span>
<span id="cb244-3"><a href="#cb244-3" tabindex="-1"></a><span class="fu">markocc</span>(grid) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb244-4"><a href="#cb244-4" tabindex="-1"></a>g0mr <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.3</span>, <span class="fl">0.1</span>, <span class="fl">0.1</span>, <span class="fl">0.1</span>, <span class="fl">0.1</span>)</span>
<span id="cb244-5"><a href="#cb244-5" tabindex="-1"></a>MRCH <span class="ot">&lt;-</span> <span class="fu">sim.resight</span>(grid, <span class="at">detectpar=</span><span class="fu">list</span>(<span class="at">g0 =</span> g0mr, <span class="at">sigma =</span> <span class="dv">25</span>),  </span>
<span id="cb244-6"><a href="#cb244-6" tabindex="-1"></a>                    <span class="at">popn =</span> <span class="fu">list</span>(<span class="at">D =</span> <span class="dv">30</span>), <span class="at">pID =</span> <span class="fl">0.7</span>, <span class="at">seed =</span> <span class="dv">123</span>)</span>
<span id="cb244-7"><a href="#cb244-7" tabindex="-1"></a><span class="co"># write to files in working directory</span></span>
<span id="cb244-8"><a href="#cb244-8" tabindex="-1"></a>Tu.char <span class="ot">&lt;-</span> <span class="fu">paste</span> (<span class="st">&quot;S1&quot;</span>, <span class="fu">apply</span> (<span class="fu">Tu</span>(MRCH), <span class="dv">1</span>, paste, <span class="at">collapse =</span> <span class="st">&quot; &quot;</span>))</span>
<span id="cb244-9"><a href="#cb244-9" tabindex="-1"></a>Tm.char <span class="ot">&lt;-</span> <span class="fu">paste</span> (<span class="st">&quot;S1&quot;</span>, <span class="fu">apply</span> (<span class="fu">Tm</span>(MRCH), <span class="dv">1</span>, paste, <span class="at">collapse =</span> <span class="st">&quot; &quot;</span>))</span>
<span id="cb244-10"><a href="#cb244-10" tabindex="-1"></a><span class="fu">write.capthist</span>(MRCH, <span class="at">filestem =</span> <span class="st">&quot;MRCH&quot;</span>)</span>
<span id="cb244-11"><a href="#cb244-11" tabindex="-1"></a><span class="fu">write.table</span>(Tu.char, <span class="at">file =</span> <span class="st">&quot;Tu.txt&quot;</span>, <span class="at">col.names =</span> F, <span class="at">row.names =</span> F, <span class="at">quote =</span> <span class="cn">FALSE</span>)</span>
<span id="cb244-12"><a href="#cb244-12" tabindex="-1"></a><span class="fu">write.table</span>(Tm.char, <span class="at">file =</span> <span class="st">&quot;Tm.txt&quot;</span>, <span class="at">col.names =</span> F, <span class="at">row.names =</span> F, <span class="at">quote =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
</div>
<div id="appendix6" class="section level3" number="19.6.4">
<h3><span class="header-section-number">19.6.4</span> Sighting-only example</h3>
<div class="sourceCode" id="cb245"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb245-1"><a href="#cb245-1" tabindex="-1"></a><span class="fu">library</span>(secr)</span>
<span id="cb245-2"><a href="#cb245-2" tabindex="-1"></a>grid <span class="ot">&lt;-</span> <span class="fu">make.grid</span>(<span class="at">detector =</span> <span class="st">&#39;proximity&#39;</span>)</span>
<span id="cb245-3"><a href="#cb245-3" tabindex="-1"></a><span class="fu">markocc</span>(grid) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb245-4"><a href="#cb245-4" tabindex="-1"></a>MRCH5 <span class="ot">&lt;-</span> <span class="fu">sim.resight</span>(grid, <span class="at">detectpar=</span><span class="fu">list</span>(<span class="at">g0 =</span> <span class="fl">0.3</span>, <span class="at">sigma =</span> <span class="dv">25</span>), </span>
<span id="cb245-5"><a href="#cb245-5" tabindex="-1"></a>           <span class="at">unsighted =</span> <span class="cn">TRUE</span>, <span class="at">popn =</span> <span class="fu">list</span>(<span class="at">D =</span> <span class="dv">30</span>), <span class="at">pID =</span> <span class="fl">1.0</span>, <span class="at">seed =</span> <span class="dv">123</span>)</span>
<span id="cb245-6"><a href="#cb245-6" tabindex="-1"></a><span class="fu">Tm</span>(MRCH5) <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb245-7"><a href="#cb245-7" tabindex="-1"></a><span class="fu">summary</span>(MRCH5)</span></code></pre></div>
<pre><code>## Object class       capthist 
## Detector type      proximity 
## Detector number    36 
## Average spacing    20 m 
## x-range            0 100 m 
## y-range            0 100 m 
## 
## Marking occasions
##  1 2 3 4 5
##  0 0 0 0 0
## 
## Counts by occasion 
##                    1  2  3  4  5 Total
## n                 26 27 25 23 31   132
## u                 26  6  4  4  3    43
## f                  8 11  5  8 11    43
## M(t+1)            26 32 36 40 43    43
## losses             0  0  0  0  0     0
## detections        48 57 49 52 62   268
## detectors visited 25 28 27 25 34   139
## detectors used    36 36 36 36 36   180
## 
## Empty histories :  75 
## 
## Sightings by occasion 
##            1  2  3  4  5 Total
## ID        48 57 49 52 62   268
## Not ID     0  0  0  0  0     0
## Unmarked  30 30 28 29 34   151
## Uncertain  0  0  0  0  0     0
## Total     78 87 77 81 96   419</code></pre>
<div class="sourceCode" id="cb247"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb247-1"><a href="#cb247-1" tabindex="-1"></a>fit0 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(MRCH5, <span class="at">fixed =</span> <span class="fu">list</span>(<span class="at">pID =</span> <span class="fl">1.0</span>), <span class="at">trace =</span> <span class="cn">FALSE</span>,</span>
<span id="cb247-2"><a href="#cb247-2" tabindex="-1"></a>                 <span class="at">details =</span> <span class="fu">list</span>(<span class="at">knownmarks =</span> <span class="cn">TRUE</span>))</span>
<span id="cb247-3"><a href="#cb247-3" tabindex="-1"></a>fit1 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(MRCH5, <span class="at">fixed =</span> <span class="fu">list</span>(<span class="at">pID =</span> <span class="fl">1.0</span>), <span class="at">start =</span> fit0, </span>
<span id="cb247-4"><a href="#cb247-4" tabindex="-1"></a>                 <span class="at">details =</span> <span class="fu">list</span>(<span class="at">nsim =</span> <span class="dv">2000</span>, <span class="at">knownmarks =</span> <span class="cn">TRUE</span>),</span>
<span id="cb247-5"><a href="#cb247-5" tabindex="-1"></a>                 <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## sims completed</code></pre>
<div class="sourceCode" id="cb249"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb249-1"><a href="#cb249-1" tabindex="-1"></a>MRCH6 <span class="ot">&lt;-</span> <span class="fu">sim.resight</span>(grid, <span class="at">detectpar=</span><span class="fu">list</span>(<span class="at">g0 =</span> <span class="fl">0.3</span>, <span class="at">sigma =</span> <span class="dv">25</span>), </span>
<span id="cb249-2"><a href="#cb249-2" tabindex="-1"></a>           <span class="at">unsighted =</span> <span class="cn">FALSE</span>, <span class="at">popn =</span> <span class="fu">list</span>(<span class="at">D =</span> <span class="dv">30</span>), <span class="at">pID =</span> <span class="fl">1.0</span>, <span class="at">seed =</span> <span class="dv">123</span>)</span>
<span id="cb249-3"><a href="#cb249-3" tabindex="-1"></a><span class="fu">Tm</span>(MRCH6) <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb249-4"><a href="#cb249-4" tabindex="-1"></a><span class="fu">summary</span>(MRCH6)</span></code></pre></div>
<pre><code>## Object class       capthist 
## Detector type      proximity 
## Detector number    36 
## Average spacing    20 m 
## x-range            0 100 m 
## y-range            0 100 m 
## 
## Marking occasions
##  1 2 3 4 5
##  0 0 0 0 0
## 
## Counts by occasion 
##                    1  2  3  4  5 Total
## n                 26 27 25 23 31   132
## u                 26  6  4  4  3    43
## f                  8 11  5  8 11    43
## M(t+1)            26 32 36 40 43    43
## losses             0  0  0  0  0     0
## detections        48 57 49 52 62   268
## detectors visited 25 28 27 25 34   139
## detectors used    36 36 36 36 36   180
## 
## Sightings by occasion 
##            1  2  3  4  5 Total
## ID        48 57 49 52 62   268
## Not ID     0  0  0  0  0     0
## Unmarked  30 30 28 29 34   151
## Uncertain  0  0  0  0  0     0
## Total     78 87 77 81 96   419</code></pre>
<div class="sourceCode" id="cb251"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb251-1"><a href="#cb251-1" tabindex="-1"></a>fit2 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(MRCH6, <span class="at">fixed =</span> <span class="fu">list</span>(<span class="at">pID =</span> <span class="fl">1.0</span>), <span class="at">trace =</span> <span class="cn">FALSE</span>,</span>
<span id="cb251-2"><a href="#cb251-2" tabindex="-1"></a>                 <span class="at">details =</span> <span class="fu">list</span>(<span class="at">knownmarks =</span> <span class="cn">FALSE</span>))</span></code></pre></div>
<!--chapter:end:16-mark-resight.Rmd-->
</div>
</div>
</div>
<div id="Noneuclidean" class="section level1" number="20">
<h1><span class="header-section-number">20</span> Non-Euclidean distances</h1>
<p></p>
<!-- More content in secr-noneuclidean.rmd -->
<!-- ## Non-Euclidean distances -->
<p><!-- 'Distance' in SECR models usually, and by default, means the -->
<!-- Euclidean distance $d = \sqrt{(x_1-x_2)^2 + (y_1 - y_2)^2}$. The -->
<!-- observation model can be customised by replacing the Euclidean -->
<!-- distance with one that 'warps' space in some ecologically meaningful -->
<!-- way. There are innumerable ways to do this. Royle et al. (2013) -->
<!-- envisioned an 'ecological distance' that is a function of landscape covariates. Redefining distance is a way to model spatial variation in the size of home ranges, and hence the spatial scale of movement $\sigma$; @edjq16 use this to model inverse covariation between density and home range size. Distances measured along a linear habitat network such as a river system are also non-Euclidean (see package **secrlinear**). --></p>
<!-- **secr** provides general tools for specifying and modelling non-Euclidean distance, via the `secr.fit` details component 'userdist'. This may be a user-specified function or a pre-computed matrix. -->
<p>Spatially explicit capture–recapture (SECR) entails a distance-dependent observation model: the expected number of
detections (<span class="math inline">\(\lambda\)</span>) or the probability of detection (g) declines with increasing distance between a detector and the home-range centre of a focal animal. ‘Distance’ here usually, and by default, means the Euclidean distance <span class="math inline">\(d = \sqrt{(x_1-x_2)^2 + (y_1 - y_2)^2}\)</span>. The observation model can be customised by replacing the Euclidean distance with one that ‘warps’ space in some ecologically meaningful way. There are innumerable ways to do this. One is the a non-Euclidean
‘ecological distance’ envisioned by <span class="citation">Royle et al. (<a href="#ref-rcgg13">2013</a>)</span>.</p>
<p>This document shows how to define and use non-Euclidean distances in <strong>secr</strong>. An appendix gives example <strong>secr</strong> code for the non-Euclidean SECR analysis of <span class="citation">Sutherland, Fuller, and Royle (<a href="#ref-sfr15">2015</a>)</span>.</p>
<div id="basics" class="section level2" number="20.1">
<h2><span class="header-section-number">20.1</span> Basics</h2>
<p>Non-Euclidean distances are defined in <strong>secr</strong> by setting the ‘userdist’ component of the ‘details’ argument of <code>secr.fit</code>. The options are (i) to provide a static <span class="math inline">\(K \times M\)</span> matrix containing the distances between the <span class="math inline">\(K\)</span> detectors and each of the <span class="math inline">\(M\)</span> mask points, or (ii) to provide a function that computes the distances dynamically. A static distance matrix can allow for barriers to movement. Providing a function is more flexible and allows the estimation of a parameter
for the distance model, but evaluating the function for each likelihood slows down model fitting.</p>
</div>
<div id="static-userdist" class="section level2" number="20.2">
<h2><span class="header-section-number">20.2</span> Static userdist</h2>
<p></p>
<p>A pre-computed non-Euclidean distance matrix may incorporate constraints on movement, particularly mapped barriers to movement, and this is the most obvious reason to employ a static userdist. The function <code>nedist</code> builds a suitable matrix.</p>
<p>As an example, take the 1996 DNA survey of the grizzly bear population in the Central Selkirk mountains of British Columbia by <span class="citation">Mowat and Strobeck (<a href="#ref-ms00">2000</a>)</span>. Their study area was partly bounded by lakes and reservoirs that we assume are rarely crossed by bears. To treat the lakes as barriers in a SECR model we need a matrix of hair snag – mask point distances for the terrestrial (non-Euclidean) distance between each pair of points.</p>
<p>We start with the hair snag locations <code>CStraps</code> and a SpatialPolygonsDataFrame object <code>BLKS_BC</code> representing the large lakes (Fig. @ref(fig:nefig)a). Buffering 30 km around the detectors gives a naive mask (Fig. @ref(fig:nefig)b); we use a 2-km pixel size and reject points centred in a lake. The shortest dry path from many points on the naive mask to the nearest detector is much longer than the straight line distance.</p>
<div class="sourceCode" id="cb252"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb252-1"><a href="#cb252-1" tabindex="-1"></a>CSmask2000 <span class="ot">&lt;-</span> <span class="fu">make.mask</span> (CStraps, <span class="at">buffer =</span> <span class="dv">30000</span>, <span class="at">type =</span> <span class="st">&quot;trapbuffer&quot;</span>, </span>
<span id="cb252-2"><a href="#cb252-2" tabindex="-1"></a>      <span class="at">spacing =</span> <span class="dv">2000</span>, <span class="at">poly =</span> BLKS_BC, <span class="at">poly.habitat =</span> F, <span class="at">keep.poly =</span> F)</span></code></pre></div>
<div class="figure">
<img src="figures/nefig.png" alt="(a) Central Selkirk grizzly bear hair snag locations, (b) Mask using naive 30-km buffer around hair snags, (c) Example map of dry-path distances from an arbitrary point, and (d) Efficient mask rejecting dry-path distances &gt;30km." width="95%" />
<p class="caption">
(#fig:nefig)(a) Central Selkirk grizzly bear hair snag locations, (b) Mask using naive 30-km buffer around hair snags, (c) Example map of dry-path distances from an arbitrary point, and (d) Efficient mask rejecting dry-path distances &gt;30km.
</p>
</div>
<p>We next calculate the matrix of all dry detector–mask distances by calling <code>nedist</code> that in turn uses functions from the R package <strong>gdistance</strong> <span class="citation">(<a href="#ref-R-gdistance">van Etten 2023</a>)</span>. Missing pixels in the mask represent barriers to movement when their combined width exceeds a threshold determined by the adjacency rule in <strong>gdistance</strong>.</p>
<p>What do we mean by an adjacency rule? <strong>gdistance</strong> finds least-cost distances through a graph formed by joining ‘adjacent’ pixels. Adjacent pixels are defined by the argument ‘directions’, which may be 4 (rook’s case), 8 (queen’s case) or 16 (knight and one-cell queen moves) as in the <strong>raster</strong> function <code>adjacent</code>. The default in <code>nedist</code> is ‘directions = 16’ because that gives the best approximation to Euclidean distances when there are no barriers. The knight’s moves are <span class="math inline">\(\sqrt 5 \approx 2.24\)</span> <span class="math inline">\(\times\)</span> cell width (‘spacing’), so the width of a polygon intended to map a barrier should be at least 2.24 <span class="math inline">\(\times\)</span> cell width.</p>
<p>Some of the BC lakes are narrow and less than 4.48 km wide. To ensure these act as barriers we could simply reduce the spacing of our mask, but that would slow down model fitting. The alternative is to retain the 2-km mask for model fitting and to define a finer (0.5-km) mask purely for the purpose of computing distances<a href="#fn53" class="footnote-ref" id="fnref53"><sup>53</sup></a>:</p>
<div class="sourceCode" id="cb253"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb253-1"><a href="#cb253-1" tabindex="-1"></a>CSmask500 <span class="ot">&lt;-</span> <span class="fu">make.mask</span> (CStraps, <span class="at">buffer =</span> <span class="dv">30000</span>, <span class="at">type =</span> </span>
<span id="cb253-2"><a href="#cb253-2" tabindex="-1"></a>    <span class="st">&quot;trapbuffer&quot;</span>, <span class="at">spacing =</span> <span class="dv">500</span>, <span class="at">poly =</span> BLKS_BC, <span class="at">poly.habitat =</span></span>
<span id="cb253-3"><a href="#cb253-3" tabindex="-1"></a>     <span class="cn">FALSE</span>, <span class="at">keep.poly =</span> <span class="cn">FALSE</span>)</span>
<span id="cb253-4"><a href="#cb253-4" tabindex="-1"></a>userd <span class="ot">&lt;-</span> <span class="fu">nedist</span>(CStraps, CSmask2000, CSmask500)</span></code></pre></div>
<p>The first argument of <code>nedist</code> provides the rows of the distance matrix and the second argument the columns; the third (if present) defines an alternative mask on which to base the calculations. To verify the computation, map the distance from a chosen detector <span class="math inline">\(i\)</span> to every point in a mask. Here is a short function to do that; see Fig. @ref(fig:nefig)c for an example.</p>
<div class="sourceCode" id="cb254"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb254-1"><a href="#cb254-1" tabindex="-1"></a>dmap <span class="ot">&lt;-</span> <span class="cf">function</span> (traps, mask, userd, <span class="at">i =</span> <span class="dv">1</span>, ...) {</span>
<span id="cb254-2"><a href="#cb254-2" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">is.na</span>(i)) i <span class="ot">&lt;-</span> <span class="fu">nearesttrap</span>(<span class="fu">unlist</span>(<span class="fu">locator</span>(<span class="dv">1</span>)), traps)</span>
<span id="cb254-3"><a href="#cb254-3" tabindex="-1"></a>    <span class="fu">covariates</span>(mask) <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">d =</span> userd[i,])</span>
<span id="cb254-4"><a href="#cb254-4" tabindex="-1"></a>    <span class="fu">covariates</span>(mask)<span class="sc">$</span>d[<span class="sc">!</span><span class="fu">is.finite</span>(<span class="fu">covariates</span>(mask)<span class="sc">$</span>d)] <span class="ot">&lt;-</span> <span class="cn">NA</span>  </span>
<span id="cb254-5"><a href="#cb254-5" tabindex="-1"></a>    <span class="fu">plot</span>(mask, <span class="at">covariate =</span> <span class="st">&quot;d&quot;</span>, ...)  </span>
<span id="cb254-6"><a href="#cb254-6" tabindex="-1"></a>    <span class="fu">points</span>(traps[i,], <span class="at">pch =</span> <span class="dv">3</span>, <span class="at">col =</span> <span class="st">&quot;red&quot;</span>)</span>
<span id="cb254-7"><a href="#cb254-7" tabindex="-1"></a>}</span>
<span id="cb254-8"><a href="#cb254-8" tabindex="-1"></a><span class="fu">dmap</span>(CStraps, CSmask2000, userd, <span class="at">dots =</span> F, <span class="at">scale =</span> <span class="fl">0.001</span>, </span>
<span id="cb254-9"><a href="#cb254-9" tabindex="-1"></a>    <span class="at">title =</span> <span class="st">&quot;distance  km&quot;</span>)</span></code></pre></div>
<p>At this point we could simply use ‘userd’ as our userdist matrix. However, <code>CSmask2000</code> now includes a lot of points that are further than 30 km from any detector. It is better to drop these points and the associated columns of ‘userd’ (Fig. 1d):</p>
<div class="sourceCode" id="cb255"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb255-1"><a href="#cb255-1" tabindex="-1"></a>OK <span class="ot">&lt;-</span> <span class="fu">apply</span>(userd, <span class="dv">2</span>, min) <span class="sc">&lt;</span> <span class="dv">30000</span></span>
<span id="cb255-2"><a href="#cb255-2" tabindex="-1"></a>CSmask2000b <span class="ot">&lt;-</span> <span class="fu">subset</span>(CSmask2000, OK)</span>
<span id="cb255-3"><a href="#cb255-3" tabindex="-1"></a>userd <span class="ot">&lt;-</span> userd[,OK]</span></code></pre></div>
<p>Finally, we can fit a model using the non-Euclidean distance matrix:</p>
<div class="sourceCode" id="cb256"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb256-1"><a href="#cb256-1" tabindex="-1"></a>CSa <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(CS_sexcov_all, <span class="at">mask =</span> CSmask2000b, </span>
<span id="cb256-2"><a href="#cb256-2" tabindex="-1"></a>    <span class="at">details =</span> <span class="fu">list</span>(<span class="at">userdist =</span> userd))</span>
<span id="cb256-3"><a href="#cb256-3" tabindex="-1"></a><span class="fu">predict</span>(CSa)                </span></code></pre></div>
<p>For completeness, note that Euclidean distances may also be pre-calculated, using the function <code>edist</code>. By default, <code>secr.fit</code> uses that function internally, and there is usually little speed improvement when the calculation is done separately.</p>
</div>
<div id="dynamic-userdist" class="section level2" number="20.3">
<h2><span class="header-section-number">20.3</span> Dynamic userdist</h2>
<p></p>
<p>The userdist function takes three arguments. The first two are simply 2-column matrices with the coordinates of the detectors and animal locations (mask points) respectively. The third is a habitat mask (this may be the same as xy2). The function has this form:</p>
<div class="sourceCode" id="cb257"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb257-1"><a href="#cb257-1" tabindex="-1"></a>mydistfn <span class="ot">&lt;-</span> <span class="cf">function</span> (xy1, xy2, mask) {</span>
<span id="cb257-2"><a href="#cb257-2" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">missing</span>(xy1)) <span class="fu">return</span>(charactervector)  </span>
<span id="cb257-3"><a href="#cb257-3" tabindex="-1"></a>  ...</span>
<span id="cb257-4"><a href="#cb257-4" tabindex="-1"></a>  distmat  <span class="co"># return nrow(xy1) x nrow(xy2) matrix</span></span>
<span id="cb257-5"><a href="#cb257-5" tabindex="-1"></a>}</span></code></pre></div>
<p>Computation of the distances is entirely under the control of the user – here we indicate that by ‘…’. The calculations may use cell-specific values of two ‘real’ parameters ‘D’ and ‘noneuc’ that as needed are passed by <code>secr.fit</code> as covariates of the mask. ‘D’ is the usual cell-specific expected density in animals per hectare. ‘noneuc’
is a special cell-specific ‘real’ parameter used only here: it means whatever the user wants it to mean.</p>
<p>Whether ‘noneuc’, ‘D’ or other mask covariates are needed by mydistfn is indicated by the character vector returned by mydistfn when it is called with no arguments. Thus, charactervector may be either a zero-length character vector or a vector of one or more parameter names (“noneuc”, “D”, c(“noneuc”, “D”)).</p>
<p>‘noneuc’ has its own link scale (default ‘log’) on which it may be modelled as a linear function of any of the predictors available for density (x, y, x2, y2, xy, session, Session, g, or any mask covariate – see Chapter @ref(Density). It may also, in principle, be modelled using regression splines <span class="citation">(<a href="#ref-bk14">Borchers and Kidney 2014</a>)</span>, but this is untested. When the model is fitted by <code>secr.fit</code>, the beta parameters for the ‘noneuc’ submodel are estimated along with all the others. To make noneuc available to userdist, ensure that it appears in the ‘model’ argument. Use the formula noneuc ~ 1 if noneuc is constant.</p>
<p>The function may compute least-cost paths via intervening mask cells using the powerful <strong>igraph</strong> package <span class="citation">(<a href="#ref-cn06">Csardi and Nepusz 2006</a>)</span>. This
is most easily accessed with package <strong>gdistance</strong>, which in turn uses the RasterLayer S4 object class from the package <strong>raster</strong>. To facilitate this we include code in <strong>secr</strong> to treat the ‘mask’ S3 class as a virtual S4 class, and provide a method for the function ‘raster’ to convert a mask to a RasterLayer.</p>
<p>If the function generates any bad distances (negative, infinite or missing) these will be replaced by 1e10, with a warning.</p>
</div>
<div id="examples" class="section level2" number="20.4">
<h2><span class="header-section-number">20.4</span> Examples</h2>
<p>We use annotated examples to show how the userdist function may be used to define different models. For illustration we use the Orongorongo Valley brushtail possum dataset from February 1996 (<a href="https://www.otago.ac.nz/density/html/OVpossum.html">OVpossum</a>). The data are captures of possums over 5 nights in single-catch traps at 30-m spacing. We start by extracting the data, defining a habitat mask, and fitting a null model:</p>
<div class="sourceCode" id="cb258"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb258-1"><a href="#cb258-1" tabindex="-1"></a>datadir <span class="ot">&lt;-</span> <span class="fu">system.file</span>(<span class="st">&quot;extdata&quot;</span>, <span class="at">package =</span> <span class="st">&quot;secr&quot;</span>)</span>
<span id="cb258-2"><a href="#cb258-2" tabindex="-1"></a>ovforest <span class="ot">&lt;-</span> sf<span class="sc">::</span><span class="fu">st_read</span> (<span class="fu">paste0</span>(datadir, <span class="st">&quot;/OVforest.shp&quot;</span>), </span>
<span id="cb258-3"><a href="#cb258-3" tabindex="-1"></a>    <span class="at">quiet =</span> <span class="cn">TRUE</span>)</span>
<span id="cb258-4"><a href="#cb258-4" tabindex="-1"></a>ovposs <span class="ot">&lt;-</span> OVpossumCH[[<span class="dv">1</span>]]  <span class="co"># select February 1996</span></span>
<span id="cb258-5"><a href="#cb258-5" tabindex="-1"></a>ovmask <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(<span class="fu">traps</span>(ovposs), <span class="at">buffer =</span> <span class="dv">120</span>, <span class="at">type =</span> <span class="st">&quot;trapbuffer&quot;</span>, </span>
<span id="cb258-6"><a href="#cb258-6" tabindex="-1"></a>    <span class="at">poly =</span> ovforest[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,], <span class="at">spacing =</span> <span class="fl">7.5</span>, <span class="at">keep.poly =</span> <span class="cn">FALSE</span>)</span>
<span id="cb258-7"><a href="#cb258-7" tabindex="-1"></a><span class="co"># for plotting only</span></span>
<span id="cb258-8"><a href="#cb258-8" tabindex="-1"></a>leftbank <span class="ot">&lt;-</span> <span class="fu">read.table</span>(<span class="fu">paste0</span>(datadir,<span class="st">&quot;/leftbank.txt&quot;</span>))[<span class="dv">21</span><span class="sc">:</span><span class="dv">195</span>,]</span></code></pre></div>
<div class="sourceCode" id="cb259"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb259-1"><a href="#cb259-1" tabindex="-1"></a>fit0 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ovposs, <span class="at">mask =</span> ovmask, <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>, </span>
<span id="cb259-2"><a href="#cb259-2" tabindex="-1"></a>    <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## Warning: multi-catch likelihood used for single-catch traps</code></pre>
<p>The warning is routine: we will suppress it in later examples. The distance functions below are not specific to a particular study: each may be applied to other datasets.</p>
<div id="scale-of-movement-sigma-depends-on-location-of-home-range-centre" class="section level3" number="20.4.1">
<h3><span class="header-section-number">20.4.1</span> 1. Scale of movement <span class="math inline">\(\sigma\)</span> depends on location of home-range centre</h3>
<p>In this simple case we use the non-Euclidean distance function to model continuous spatial variation in <span class="math inline">\(\sigma\)</span>. This cannot be done directly in <strong>secr</strong> because sigma is treated as part of the detection model, which does not allow for continuous spatial variation in its parameters. Instead we model spatial variation in ‘noneuc’ as a stand-in for ‘sigma’</p>
<div class="sourceCode" id="cb261"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb261-1"><a href="#cb261-1" tabindex="-1"></a>fn1 <span class="ot">&lt;-</span> <span class="cf">function</span> (xy1, xy2, mask) {</span>
<span id="cb261-2"><a href="#cb261-2" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">missing</span>(xy1)) <span class="fu">return</span>(<span class="st">&quot;noneuc&quot;</span>)</span>
<span id="cb261-3"><a href="#cb261-3" tabindex="-1"></a>  sig <span class="ot">&lt;-</span> <span class="fu">covariates</span>(mask)<span class="sc">$</span>noneuc   <span class="co"># sigma(x,y) at mask points</span></span>
<span id="cb261-4"><a href="#cb261-4" tabindex="-1"></a>  sig <span class="ot">&lt;-</span> <span class="fu">matrix</span>(sig, <span class="at">byrow =</span> <span class="cn">TRUE</span>, <span class="at">nrow =</span> <span class="fu">nrow</span>(xy1), </span>
<span id="cb261-5"><a href="#cb261-5" tabindex="-1"></a>                <span class="at">ncol =</span> <span class="fu">nrow</span>(xy2))</span>
<span id="cb261-6"><a href="#cb261-6" tabindex="-1"></a>  euc <span class="ot">&lt;-</span> <span class="fu">edist</span>(xy1, xy2) </span>
<span id="cb261-7"><a href="#cb261-7" tabindex="-1"></a>  euc <span class="sc">/</span> sig</span>
<span id="cb261-8"><a href="#cb261-8" tabindex="-1"></a>}</span>
<span id="cb261-9"><a href="#cb261-9" tabindex="-1"></a>fit1 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ovposs, <span class="at">mask =</span> ovmask, <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>, </span>
<span id="cb261-10"><a href="#cb261-10" tabindex="-1"></a>    <span class="at">details =</span> <span class="fu">list</span>(<span class="at">userdist =</span> fn1), <span class="at">model =</span> noneuc <span class="sc">~</span> x <span class="sc">+</span> y <span class="sc">+</span> </span>
<span id="cb261-11"><a href="#cb261-11" tabindex="-1"></a>     x2 <span class="sc">+</span> y2 <span class="sc">+</span> xy, <span class="at">fixed =</span> <span class="fu">list</span>(<span class="at">sigma =</span> <span class="dv">1</span>), <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<div class="sourceCode" id="cb262"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb262-1"><a href="#cb262-1" tabindex="-1"></a><span class="fu">predict</span>(fit1)</span></code></pre></div>
<pre><code>##         link estimate SE.estimate       lcl      ucl
## D        log 14.68433   1.0914749 12.696149 16.98385
## lambda0  log  0.10852   0.0096263  0.091235  0.12908
## noneuc   log 25.92426   1.3019340 23.495537 28.60404</code></pre>
<p>We can take the values of noneuc directly from the mask covariates because we know xy2 and mask are the same points. We may sometimes want to use fn1 in context where this does not hold, e.g., when simulating data.</p>
<div class="sourceCode" id="cb264"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb264-1"><a href="#cb264-1" tabindex="-1"></a>fn1a <span class="ot">&lt;-</span> <span class="cf">function</span> (xy1, xy2, mask) {</span>
<span id="cb264-2"><a href="#cb264-2" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">missing</span>(xy1)) <span class="fu">return</span>(<span class="st">&quot;noneuc&quot;</span>)</span>
<span id="cb264-3"><a href="#cb264-3" tabindex="-1"></a>  xy1 <span class="ot">&lt;-</span> <span class="fu">addCovariates</span>(xy1, mask)</span>
<span id="cb264-4"><a href="#cb264-4" tabindex="-1"></a>  sig <span class="ot">&lt;-</span> <span class="fu">covariates</span>(xy1)<span class="sc">$</span>noneuc   <span class="co"># sigma(x,y) at detectors</span></span>
<span id="cb264-5"><a href="#cb264-5" tabindex="-1"></a>  sig <span class="ot">&lt;-</span> <span class="fu">matrix</span>(sig, <span class="at">nrow =</span> <span class="fu">nrow</span>(xy1), <span class="at">ncol =</span> <span class="fu">nrow</span>(xy2))</span>
<span id="cb264-6"><a href="#cb264-6" tabindex="-1"></a>  euc <span class="ot">&lt;-</span> <span class="fu">edist</span>(xy1, xy2) </span>
<span id="cb264-7"><a href="#cb264-7" tabindex="-1"></a>  euc <span class="sc">/</span> sig</span>
<span id="cb264-8"><a href="#cb264-8" tabindex="-1"></a>}</span>
<span id="cb264-9"><a href="#cb264-9" tabindex="-1"></a>fit1a <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ovposs, <span class="at">mask =</span> ovmask, <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>,</span>
<span id="cb264-10"><a href="#cb264-10" tabindex="-1"></a>                 <span class="at">details =</span> <span class="fu">list</span>(<span class="at">userdist =</span> fn1a), <span class="at">model =</span> noneuc <span class="sc">~</span> x <span class="sc">+</span> y <span class="sc">+</span> x2 <span class="sc">+</span> y2 <span class="sc">+</span> xy,</span>
<span id="cb264-11"><a href="#cb264-11" tabindex="-1"></a>                 <span class="at">fixed =</span> <span class="fu">list</span>(<span class="at">sigma =</span> <span class="dv">1</span>))</span></code></pre></div>
<div class="sourceCode" id="cb265"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb265-1"><a href="#cb265-1" tabindex="-1"></a><span class="fu">predict</span>(fit1a)</span></code></pre></div>
<pre><code>##         link estimate SE.estimate       lcl      ucl
## D        log 14.46193   1.0296889 12.580487 16.62476
## lambda0  log  0.10758   0.0095253  0.090471  0.12792
## noneuc   log 26.12539   1.4198770 23.487421 29.05964</code></pre>
<p>We can verify the use of ‘noneuc’ in fn1 by using it to re-fit the null model:</p>
<div class="sourceCode" id="cb267"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb267-1"><a href="#cb267-1" tabindex="-1"></a>fit0a <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ovposs, <span class="at">mask =</span> ovmask, <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>, </span>
<span id="cb267-2"><a href="#cb267-2" tabindex="-1"></a>    <span class="at">details =</span> <span class="fu">list</span>(<span class="at">userdist =</span> fn1), <span class="at">model =</span> noneuc <span class="sc">~</span> <span class="dv">1</span>, </span>
<span id="cb267-3"><a href="#cb267-3" tabindex="-1"></a>    <span class="at">fixed =</span> <span class="fu">list</span>(<span class="at">sigma =</span> <span class="dv">1</span>), <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<div class="sourceCode" id="cb268"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb268-1"><a href="#cb268-1" tabindex="-1"></a><span class="fu">predict</span>(fit0)</span></code></pre></div>
<pre><code>##         link estimate SE.estimate       lcl      ucl
## D        log 14.38018   1.0030931 12.544712 16.48421
## lambda0  log  0.10148   0.0089477  0.085403  0.12058
## sigma    log 27.37646   0.9729693 25.534944 29.35079</code></pre>
<div class="sourceCode" id="cb270"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb270-1"><a href="#cb270-1" tabindex="-1"></a><span class="fu">predict</span>(fit0a)</span></code></pre></div>
<pre><code>##         link estimate SE.estimate       lcl      ucl
## D        log 14.38018   1.0030930 12.544713 16.48421
## lambda0  log  0.10148   0.0089477  0.085403  0.12058
## noneuc   log 27.37644   0.9729668 25.534919 29.35076</code></pre>
<p>Here, fitting noneuc as a constant while holding sigma fixed is exactly the same as fitting sigma alone.</p>
</div>
<div id="scale-of-movement-sigma-depends-on-locations-of-both-home-range-centre-and-detector" class="section level3" number="20.4.2">
<h3><span class="header-section-number">20.4.2</span> 2. Scale of movement <span class="math inline">\(\sigma\)</span> depends on locations of both home-range centre and detector</h3>
<p>Hypothetically, detections at xy1 of an animal centred at xy2 may depend on both locations (this may also be seen as a approximation to the following case of continuous variation along the path between xy1 and xy2). To model this we need to retrieve the value of noneuc for both locations. Within fn2 we use <code>addCovariates</code> to extract the covariates of the mask (and hence noneuc) for each point in xy1 and xy2. The call to <code>secr.fit</code> is identical except that it uses fn2 instead of fn1:</p>
<div class="sourceCode" id="cb272"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb272-1"><a href="#cb272-1" tabindex="-1"></a>fn2 <span class="ot">&lt;-</span> <span class="cf">function</span> (xy1, xy2, mask) {</span>
<span id="cb272-2"><a href="#cb272-2" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">missing</span>(xy1)) <span class="fu">return</span>(<span class="st">&quot;noneuc&quot;</span>)</span>
<span id="cb272-3"><a href="#cb272-3" tabindex="-1"></a>  xy1 <span class="ot">&lt;-</span> <span class="fu">addCovariates</span>(xy1, mask)</span>
<span id="cb272-4"><a href="#cb272-4" tabindex="-1"></a>  xy2 <span class="ot">&lt;-</span> <span class="fu">addCovariates</span>(xy2, mask)</span>
<span id="cb272-5"><a href="#cb272-5" tabindex="-1"></a>  sig1 <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">covariates</span>(xy1)<span class="sc">$</span>noneuc) <span class="co"># sigma at detector</span></span>
<span id="cb272-6"><a href="#cb272-6" tabindex="-1"></a>  sig2 <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">covariates</span>(xy2)<span class="sc">$</span>noneuc) <span class="co"># sigma at mask pt</span></span>
<span id="cb272-7"><a href="#cb272-7" tabindex="-1"></a>  euc <span class="ot">&lt;-</span> <span class="fu">edist</span>(xy1, xy2) </span>
<span id="cb272-8"><a href="#cb272-8" tabindex="-1"></a>  sig <span class="ot">&lt;-</span> <span class="fu">outer</span> (sig1, sig2, <span class="at">FUN =</span> <span class="cf">function</span>(s1, s2) (s1 <span class="sc">+</span> s2)<span class="sc">/</span><span class="dv">2</span>)</span>
<span id="cb272-9"><a href="#cb272-9" tabindex="-1"></a>  euc <span class="sc">/</span> sig</span>
<span id="cb272-10"><a href="#cb272-10" tabindex="-1"></a>}</span>
<span id="cb272-11"><a href="#cb272-11" tabindex="-1"></a>fit2 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ovposs, <span class="at">mask =</span> ovmask, <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>, </span>
<span id="cb272-12"><a href="#cb272-12" tabindex="-1"></a>    <span class="at">details =</span> <span class="fu">list</span>(<span class="at">userdist =</span> fn2), <span class="at">model =</span> noneuc <span class="sc">~</span> x <span class="sc">+</span> y <span class="sc">+</span> </span>
<span id="cb272-13"><a href="#cb272-13" tabindex="-1"></a>     x2 <span class="sc">+</span> y2 <span class="sc">+</span> xy, <span class="at">fixed =</span> <span class="fu">list</span>(<span class="at">sigma =</span> <span class="dv">1</span>), <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<div class="sourceCode" id="cb273"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb273-1"><a href="#cb273-1" tabindex="-1"></a><span class="fu">predict</span>(fit2)</span></code></pre></div>
<pre><code>##         link estimate SE.estimate       lcl      ucl
## D        log 14.54656   1.0580300 12.616260 16.77220
## lambda0  log  0.10781   0.0095493  0.090662  0.12821
## noneuc   log 26.02329   1.3510108 23.507230 28.80866</code></pre>
<p><span style="color: green;">Tip:</span> The value of noneuc reported by <code>predict.secr</code> is the predicted value at the centroid of the mask, because the model uses standardised mask coordinates.</p>
</div>
<div id="continuously-varying-sigma-using-gdistance" class="section level3" number="20.4.3">
<h3><span class="header-section-number">20.4.3</span> 3. Continuously varying <span class="math inline">\(\sigma\)</span> using <strong>gdistance</strong></h3>
<p>A more elegant but slower approach is to find the least-cost path across the network of cells between xy1 and xy2, using noneuc (i.e. sigma ) as the cell-specific cost weighting (large cell-specific sigma equates with greater ‘conductance’, the inverse of friction or cost). For this we use functions from the package <strong>gdistance</strong>, which in turn uses <strong>igraph</strong>.</p>
<div class="sourceCode" id="cb275"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb275-1"><a href="#cb275-1" tabindex="-1"></a>fn3 <span class="ot">&lt;-</span> <span class="cf">function</span> (xy1, xy2, mask) {</span>
<span id="cb275-2"><a href="#cb275-2" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">missing</span>(xy1)) <span class="fu">return</span>(<span class="st">&quot;noneuc&quot;</span>)</span>
<span id="cb275-3"><a href="#cb275-3" tabindex="-1"></a>  <span class="co"># warp distances to be \propto \int_along path sigma(x,y) dp</span></span>
<span id="cb275-4"><a href="#cb275-4" tabindex="-1"></a>  <span class="co"># where p is path distance  </span></span>
<span id="cb275-5"><a href="#cb275-5" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">require</span>(gdistance))</span>
<span id="cb275-6"><a href="#cb275-6" tabindex="-1"></a>    <span class="fu">stop</span> (<span class="st">&quot;install package gdistance to use this function&quot;</span>)</span>
<span id="cb275-7"><a href="#cb275-7" tabindex="-1"></a>  <span class="co"># make raster from mask</span></span>
<span id="cb275-8"><a href="#cb275-8" tabindex="-1"></a>  Sraster <span class="ot">&lt;-</span> <span class="fu">raster</span>(mask, <span class="st">&quot;noneuc&quot;</span>)</span>
<span id="cb275-9"><a href="#cb275-9" tabindex="-1"></a>  <span class="co"># Assume animals can traverse gaps: bridge gaps using mean</span></span>
<span id="cb275-10"><a href="#cb275-10" tabindex="-1"></a>  Sraster[<span class="fu">is.na</span>(Sraster[])] <span class="ot">&lt;-</span> <span class="fu">mean</span>(Sraster[], <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb275-11"><a href="#cb275-11" tabindex="-1"></a>  <span class="co"># TransitionLayer</span></span>
<span id="cb275-12"><a href="#cb275-12" tabindex="-1"></a>  tr <span class="ot">&lt;-</span> <span class="fu">transition</span>(Sraster, <span class="at">transitionFunction =</span> mean, </span>
<span id="cb275-13"><a href="#cb275-13" tabindex="-1"></a>                   <span class="at">directions =</span> <span class="dv">16</span>)</span>
<span id="cb275-14"><a href="#cb275-14" tabindex="-1"></a>  tr <span class="ot">&lt;-</span> <span class="fu">geoCorrection</span>(tr, <span class="at">type =</span> <span class="st">&quot;c&quot;</span>, <span class="at">multpl =</span> <span class="cn">FALSE</span>)</span>
<span id="cb275-15"><a href="#cb275-15" tabindex="-1"></a>  <span class="co"># costDistance</span></span>
<span id="cb275-16"><a href="#cb275-16" tabindex="-1"></a>  <span class="fu">costDistance</span>(tr, <span class="fu">as.matrix</span>(xy1), <span class="fu">as.matrix</span>(xy2))</span>
<span id="cb275-17"><a href="#cb275-17" tabindex="-1"></a>}</span>
<span id="cb275-18"><a href="#cb275-18" tabindex="-1"></a>fit3 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ovposs, <span class="at">mask =</span> ovmask, <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>,</span>
<span id="cb275-19"><a href="#cb275-19" tabindex="-1"></a>    <span class="at">details =</span> <span class="fu">list</span>(<span class="at">userdist =</span> fn3), <span class="at">model =</span> noneuc <span class="sc">~</span> x <span class="sc">+</span> y <span class="sc">+</span> </span>
<span id="cb275-20"><a href="#cb275-20" tabindex="-1"></a>     x2 <span class="sc">+</span> y2 <span class="sc">+</span> xy, <span class="at">fixed =</span> <span class="fu">list</span>(<span class="at">sigma =</span> <span class="dv">1</span>), <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<div class="sourceCode" id="cb276"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb276-1"><a href="#cb276-1" tabindex="-1"></a><span class="fu">predict</span>(fit3)</span></code></pre></div>
<pre><code>##         link estimate SE.estimate       lcl     ucl
## D        log  14.4063   1.0500192 12.490929 16.6154
## lambda0  log   0.1076   0.0095041  0.090528  0.1279
## noneuc   log  26.4338   1.3643768 23.892137 29.2459</code></pre>
<p>The <strong>gdistance</strong> function <code>costDistance</code> uses a TransitionLayer object that essentially describes the connections between cells in a RasterLayer. In <code>transition</code> adjacent cells are assigned a positive value for ‘conductance’ and all other cells a zero value. Adjacency is defined by the directions argument as 4 (rook’s case), 8 (queen’s case), 16 (knight and one-cell queen moves) and possibly other values (see ?adjacent in <strong>gdistance</strong>). Values &lt; 16 can considerably distort distances even if conductance is homogeneous. <code>geoCorrection</code> is needed to allow for the greater separation (<span class="math inline">\(\times \sqrt 2\)</span>) of cell centres measured along diagonals.</p>
<p>In <code>ovmask</code> there are two forest blocks separated by a shingle stream bed and low scrub that is easily crossed by possums but does not count as ‘habitat’. Habitat gaps are assumed in <strong>secr</strong> to be traversible. The opposite is assumed by <strong>gdistance</strong>. To coerce <strong>gdistance</strong> to behave like <strong>secr</strong> we here temporarily fill in the gaps.</p>
<p>The argument ‘transitionFunction’ determines how the conductance values of adjacent cells are combined to weight travel between them. Here we simply average them, but any other single-valued function of 2 inputs can be used.</p>
<p>Integrating along the path (fn3) takes about 3.6 times as long as the approximation (fn2) and gives quite similar results.</p>
</div>
<div id="density-dependent-sigma" class="section level3" number="20.4.4">
<h3><span class="header-section-number">20.4.4</span> 4. Density-dependent <span class="math inline">\(\sigma\)</span></h3>
<p>A more interesting variation makes sigma a function of the cell-specific density, which may vary independently across space <span class="citation">(<a href="#ref-edjq16">Efford et al. 2016</a>)</span>. Specifically, <span class="math inline">\(\sigma(x,y) = k / \sqrt{D(x,y)}\)</span>, where <span class="math inline">\(k\)</span> is the fitted parameter (noneuc).</p>
<div class="sourceCode" id="cb278"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb278-1"><a href="#cb278-1" tabindex="-1"></a>fn4 <span class="ot">&lt;-</span> <span class="cf">function</span> (xy1, xy2, mask) {</span>
<span id="cb278-2"><a href="#cb278-2" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">missing</span>(xy1)) <span class="fu">return</span>(<span class="fu">c</span>(<span class="st">&quot;D&quot;</span>, <span class="st">&quot;noneuc&quot;</span>))</span>
<span id="cb278-3"><a href="#cb278-3" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">require</span>(gdistance))</span>
<span id="cb278-4"><a href="#cb278-4" tabindex="-1"></a>    <span class="fu">stop</span> (<span class="st">&quot;install package gdistance to use this function&quot;</span>)</span>
<span id="cb278-5"><a href="#cb278-5" tabindex="-1"></a>  <span class="co"># make raster from mask</span></span>
<span id="cb278-6"><a href="#cb278-6" tabindex="-1"></a>  D <span class="ot">&lt;-</span> <span class="fu">covariates</span>(mask)<span class="sc">$</span>D</span>
<span id="cb278-7"><a href="#cb278-7" tabindex="-1"></a>  k <span class="ot">&lt;-</span> <span class="fu">covariates</span>(mask)<span class="sc">$</span>noneuc  </span>
<span id="cb278-8"><a href="#cb278-8" tabindex="-1"></a>  Sraster <span class="ot">&lt;-</span> <span class="fu">raster</span>(mask, <span class="at">values =</span> k <span class="sc">/</span> D<span class="sc">^</span><span class="fl">0.5</span>)</span>
<span id="cb278-9"><a href="#cb278-9" tabindex="-1"></a>  <span class="co"># Assume animals can traverse gaps: bridge gaps using mean</span></span>
<span id="cb278-10"><a href="#cb278-10" tabindex="-1"></a>  Sraster[<span class="fu">is.na</span>(Sraster[])] <span class="ot">&lt;-</span> <span class="fu">mean</span>(Sraster[], <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb278-11"><a href="#cb278-11" tabindex="-1"></a>  <span class="co"># TransitionLayer</span></span>
<span id="cb278-12"><a href="#cb278-12" tabindex="-1"></a>  tr <span class="ot">&lt;-</span> <span class="fu">transition</span>(Sraster, <span class="at">transitionFunction =</span> mean, </span>
<span id="cb278-13"><a href="#cb278-13" tabindex="-1"></a>                   <span class="at">directions =</span> <span class="dv">16</span>)</span>
<span id="cb278-14"><a href="#cb278-14" tabindex="-1"></a>  tr <span class="ot">&lt;-</span> <span class="fu">geoCorrection</span>(tr, <span class="at">type =</span> <span class="st">&quot;c&quot;</span>, <span class="at">multpl =</span> <span class="cn">FALSE</span>)</span>
<span id="cb278-15"><a href="#cb278-15" tabindex="-1"></a>  <span class="co"># costDistance</span></span>
<span id="cb278-16"><a href="#cb278-16" tabindex="-1"></a>  <span class="fu">costDistance</span>(tr, <span class="fu">as.matrix</span>(xy1), <span class="fu">as.matrix</span>(xy2))</span>
<span id="cb278-17"><a href="#cb278-17" tabindex="-1"></a>}</span>
<span id="cb278-18"><a href="#cb278-18" tabindex="-1"></a>fit4 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ovposs, <span class="at">mask =</span> ovmask, <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>,</span>
<span id="cb278-19"><a href="#cb278-19" tabindex="-1"></a>                 <span class="at">details =</span> <span class="fu">list</span>(<span class="at">userdist =</span> fn4), <span class="at">fixed =</span> <span class="fu">list</span>(<span class="at">sigma =</span> <span class="dv">1</span>),</span>
<span id="cb278-20"><a href="#cb278-20" tabindex="-1"></a>                 <span class="at">model =</span> <span class="fu">list</span>(noneuc <span class="sc">~</span> <span class="dv">1</span>, D <span class="sc">~</span> x <span class="sc">+</span> y <span class="sc">+</span> x2 <span class="sc">+</span> y2 <span class="sc">+</span> xy))</span></code></pre></div>
<div class="sourceCode" id="cb279"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb279-1"><a href="#cb279-1" tabindex="-1"></a><span class="fu">predict</span>(fit4)</span></code></pre></div>
<pre><code>##         link  estimate SE.estimate       lcl       ucl
## D        log  15.45490   1.6387370 12.562109  19.01384
## lambda0  log   0.10669   0.0094078  0.089788   0.12678
## noneuc   log 103.22820   5.0334099 93.824963 113.57385</code></pre>
<div class="sourceCode" id="cb281"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb281-1"><a href="#cb281-1" tabindex="-1"></a><span class="co"># or using regression splines with same df</span></span>
<span id="cb281-2"><a href="#cb281-2" tabindex="-1"></a>fit4a <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ovposs, <span class="at">mask =</span> ovmask, <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>,</span>
<span id="cb281-3"><a href="#cb281-3" tabindex="-1"></a>    <span class="at">details =</span> <span class="fu">list</span>(<span class="at">userdist =</span> fn4), <span class="at">fixed =</span> <span class="fu">list</span>(<span class="at">sigma =</span> <span class="dv">1</span>),</span>
<span id="cb281-4"><a href="#cb281-4" tabindex="-1"></a>    <span class="at">model =</span> <span class="fu">list</span>(noneuc<span class="sc">~</span><span class="dv">1</span>, D <span class="sc">~</span> <span class="fu">s</span>(x,y, <span class="at">k =</span> <span class="dv">6</span>)), <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<div class="sourceCode" id="cb282"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb282-1"><a href="#cb282-1" tabindex="-1"></a><span class="fu">predict</span>(fit4a)</span></code></pre></div>
<pre><code>##         link  estimate SE.estimate       lcl       ucl
## D        log  15.76414   1.7665784 12.664251  19.62281
## lambda0  log   0.10681   0.0094166  0.089887   0.12691
## noneuc   log 103.08276   5.0088035 93.723922 113.37614</code></pre>
<div class="sourceCode" id="cb284"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb284-1"><a href="#cb284-1" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">predictDsurface</span>(fit4a))</span>
<span id="cb284-2"><a href="#cb284-2" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">traps</span>(ovposs), <span class="at">add=</span>T)</span>
<span id="cb284-3"><a href="#cb284-3" tabindex="-1"></a><span class="fu">lines</span>(leftbank)</span></code></pre></div>
<div class="sourceCode" id="cb285"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb285-1"><a href="#cb285-1" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">include_graphics</span>(<span class="st">&quot;figures/surface4a.png&quot;</span>)</span></code></pre></div>
<div class="figure">
<img src="figures/surface4a.png" alt="Surface 4a." width="90%" />
<p class="caption">
(#fig:surface4a)Surface 4a.
</p>
</div>
</div>
<div id="habitat-model-for-connectivity" class="section level3" number="20.4.5">
<h3><span class="header-section-number">20.4.5</span> 5. Habitat model for connectivity</h3>
<p>Yet another possibility, in the spirit of <span class="citation">Royle et al. (<a href="#ref-rcgg13">2013</a>)</span>, is to model conductance as a function of habitat covariates. As usual in <strong>secr</strong> these are stored as one or more mask covariates. It is easy to add a covariate for forest type (<em>Nothofagus</em>-dominant ‘beech’ vs ‘nonbeech’) to our mask:</p>
<div class="sourceCode" id="cb286"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb286-1"><a href="#cb286-1" tabindex="-1"></a>ovmask <span class="ot">&lt;-</span> <span class="fu">addCovariates</span>(ovmask, ovforest[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,])</span>
<span id="cb286-2"><a href="#cb286-2" tabindex="-1"></a>fit5 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ovposs, <span class="at">mask =</span> ovmask, <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>,</span>
<span id="cb286-3"><a href="#cb286-3" tabindex="-1"></a>    <span class="at">details =</span> <span class="fu">list</span>(<span class="at">userdist =</span> fn2), <span class="at">model =</span> <span class="fu">list</span>(D <span class="sc">~</span> forest, </span>
<span id="cb286-4"><a href="#cb286-4" tabindex="-1"></a>     noneuc <span class="sc">~</span> forest), <span class="at">fixed =</span> <span class="fu">list</span>(<span class="at">sigma =</span> <span class="dv">1</span>), <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<div class="sourceCode" id="cb287"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb287-1"><a href="#cb287-1" tabindex="-1"></a><span class="fu">predict</span>(fit5, <span class="at">newdata =</span> </span>
<span id="cb287-2"><a href="#cb287-2" tabindex="-1"></a>    <span class="fu">data.frame</span>(<span class="at">forest =</span> <span class="fu">c</span>(<span class="st">&quot;beech&quot;</span>, <span class="st">&quot;nonbeech&quot;</span>)))</span></code></pre></div>
<pre><code>## $`forest = beech`
##         link estimate SE.estimate      lcl      ucl
## D        log  9.42514   2.6531304  5.48570 16.19361
## lambda0  log  0.10111   0.0089337  0.08506  0.12019
## noneuc   log 29.55770   3.4060659 23.59968 37.01988
## 
## $`forest = nonbeech`
##         link estimate SE.estimate      lcl      ucl
## D        log 15.67451   1.2679343 13.37985 18.36270
## lambda0  log  0.10111   0.0089337  0.08506  0.12019
## noneuc   log 27.23476   1.0319160 25.28619 29.33349</code></pre>
<p>Note that we have re-used the userdist function fn2, and allowed both density and noneuc (sigma) to vary by forest type. Strictly, we should have identified “forest” as a required covariate in the (re)definition of fn2, but this is obviously not critical.</p>
<p>A full analysis should also consider models with variation in lambda0. There is no simple way in <strong>secr</strong> to model continuous spatial variation in lambda0 as a function of home-range location (cf sigma in Example 1 above). However, variation in lambda0 at the point of detection may be modelled with detector-level covariates(<a href="https://www.otago.ac.nz/density/pdfs/secr-overview.pdf">secr-overview.pdf</a>).</p>
</div>
</div>
<div id="and-the-winner-is" class="section level2" number="20.5">
<h2><span class="header-section-number">20.5</span> And the winner is…</h2>
<p>Now that we have a bunch of fitted models, let’s see which does the best:</p>
<div class="sourceCode" id="cb289"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb289-1"><a href="#cb289-1" tabindex="-1"></a>fits <span class="ot">&lt;-</span> <span class="fu">secrlist</span>(fit0, fit0a, fit1, fit1a, fit2, fit3, fit4, </span>
<span id="cb289-2"><a href="#cb289-2" tabindex="-1"></a>                 fit4a, fit5)</span>
<span id="cb289-3"><a href="#cb289-3" tabindex="-1"></a><span class="fu">AIC</span>(fits, <span class="at">criterion =</span> <span class="st">&quot;AIC&quot;</span>)[, <span class="sc">-</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>)]</span></code></pre></div>
<pre><code>##                                           model npar    AIC   dAIC  AICwt
## fit4a       D~s(x, y, k = 6) lambda0~1 noneuc~1    8 3098.1  0.000 0.4549
## fit4  D~x + y + x2 + y2 + xy lambda0~1 noneuc~1    8 3098.5  0.382 0.3758
## fit1  D~1 lambda0~1 noneuc~x + y + x2 + y2 + xy    8 3101.8  3.704 0.0714
## fit3  D~1 lambda0~1 noneuc~x + y + x2 + y2 + xy    8 3102.4  4.304 0.0529
## fit2  D~1 lambda0~1 noneuc~x + y + x2 + y2 + xy    8 3103.5  5.411 0.0304
## fit1a D~1 lambda0~1 noneuc~x + y + x2 + y2 + xy    8 3105.0  6.862 0.0147
## fit0                      D~1 lambda0~1 sigma~1    3 3118.1 19.979 0.0000
## fit0a                    D~1 lambda0~1 noneuc~1    3 3118.1 19.979 0.0000
## fit5           D~forest lambda0~1 noneuc~forest    5 3118.4 20.280 0.0000</code></pre>
<p>…the model with a quadratic or spline trend in density and density-dependent sigma.</p>
</div>
<div id="notes-1" class="section level2" number="20.6">
<h2><span class="header-section-number">20.6</span> Notes</h2>
<p>The ‘real’ parameter for spatial scale (<span class="math inline">\(\sigma\)</span>) is lurking in the background as part of the detection model. User-defined non-Euclidean distances are used in the detection function just like ordinary Euclidean distances. This means in practice that they are (almost) always divided by (<span class="math inline">\(\sigma\)</span>). Formally: the distance <span class="math inline">\(d_{ij}\)</span> between an animal <span class="math inline">\(i\)</span> and a detector <span class="math inline">\(j\)</span> appears in all commonly used detection functions as the ratio <span class="math inline">\(r_{ij} = d_{ij}/\sigma\)</span> (e.g., halfnormal <span class="math inline">\(\lambda = \lambda_0 \exp(-0.5r_{ij}^2)\)</span> and exponential <span class="math inline">\(\lambda = \lambda_0 \exp(-r_{ij})\)</span>).</p>
<p>What if we want non-Euclidean distances, but do not want to estimate noneuc? This is a perfectly reasonable request if sigma is constant across space and the distance computation is determined entirely by the habitat geometry, with no need for an additional parameter. If ‘noneuc’ is not included in the character vector returned by your userdist function when it is called with no arguments then noneuc is not modelled at all. (This is the default in <strong>secrlinear</strong>).</p>
<p>Providing a suitable initial value for ‘noneuc’ can be a problem. The argument ‘start’ of <code>secr.fit</code> may be a named, and possibly incomplete, list of real parameter values, so a call such as this is valid:</p>
<div class="sourceCode" id="cb291"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb291-1"><a href="#cb291-1" tabindex="-1"></a><span class="fu">secr.fit</span> (captdata, <span class="at">model =</span> noneuc<span class="sc">~</span><span class="dv">1</span>, <span class="at">details =</span> <span class="fu">list</span>(<span class="at">userdist=</span>fn2), <span class="at">trace =</span> <span class="cn">FALSE</span>, </span>
<span id="cb291-2"><a href="#cb291-2" tabindex="-1"></a>          <span class="at">start =</span> <span class="fu">list</span>(<span class="at">noneuc =</span> <span class="dv">25</span>), <span class="at">fixed =</span> <span class="fu">list</span>(<span class="at">sigma =</span> <span class="dv">1</span>))</span></code></pre></div>
<pre><code>## Error in nlsModel(formula, mf, start, wts, scaleOffset = scOff, nDcentral = nDcntr) : 
##   singular gradient matrix at initial parameter estimates</code></pre>
<pre><code>## 
## secr.fit(capthist = captdata, model = noneuc ~ 1, start = list(noneuc = 25), 
##     fixed = list(sigma = 1), details = list(userdist = fn2), 
##     trace = FALSE)
## secr 4.6.6, 15:32:06 24 Feb 2024
## 
## Detector type      single 
## Detector number    100 
## Average spacing    30 m 
## x-range            365 635 m 
## y-range            365 635 m 
## 
## N animals       :  76  
## N detections    :  235 
## N occasions     :  5 
## Mask area       :  21.227 ha 
## 
## Model           :  D~1 g0~1 noneuc~1 
## User distances  :  dynamic (function)
## Fixed (real)    :  sigma = 1 
## Detection fn    :  halfnormal
## Distribution    :  poisson 
## N parameters    :  3 
## Log likelihood  :  -759.03 
## AIC             :  1524.1 
## AICc            :  1524.4 
## 
## Beta parameters (coefficients) 
##            beta  SE.beta     lcl      ucl
## D       1.70107 0.117615  1.4705  1.93159
## g0     -0.97849 0.136239 -1.2455 -0.71147
## noneuc  3.37983 0.044415  3.2928  3.46688
## 
## Variance-covariance matrix of beta parameters 
##                  D          g0      noneuc
## D       0.01383321  0.00015578 -0.00099075
## g0      0.00015578  0.01856105 -0.00334337
## noneuc -0.00099075 -0.00334337  0.00197272
## 
## Fitted (real) parameters evaluated at base levels of covariates 
##         link estimate SE.estimate      lcl      ucl
## D        log  5.47981    0.646741  4.35163  6.90048
## g0     logit  0.27319    0.027051  0.22348  0.32927
## noneuc   log 29.36583    1.304938 26.91757 32.03677</code></pre>
<p>We have ignored the parameter <span class="math inline">\(\lambda_0\)</span>. This is almost certainly a mistake, as large variation in <span class="math inline">\(\sigma\)</span> without compensatory or normalising variation in <span class="math inline">\(\lambda_0\)</span> is biologically implausible and can lead to improbable results <span class="citation">Efford (<a href="#ref-e14">2014</a>)</span>.</p>
<p>It is intended that non-Euclidean distances should work with all relevant functions in <strong>secr</strong>.</p>
<p>You may be tempted to model ‘noneuc’ as a function of group - after all, D~g is permitted, right? Unfortunately, this will not work. There is only one pre-computed distance matrix, not one matrix per group.</p>
</div>
<div id="simulation-after-sutherland-et-al.-2015" class="section level2" number="20.7">
<h2><span class="header-section-number">20.7</span> Simulation after Sutherland et al. (2015)</h2>
<p></p>
<p><span class="citation">Sutherland, Fuller, and Royle (<a href="#ref-sfr15">2015</a>)</span> simulated SECR data from a population of animals whose movement was channeled to varying extents along a dendritic network (river system). Their model treated the habitat as 2-dimensional and shrank distances for pixels close to water and expanded them for pixels further away. The authors kindly provided data for the network map and detector layout which we use here to emulate their simulations in <strong>secr</strong>. We assume an existing SpatialLinesDataFrame <code>sample.water</code> for the network, and a matrix of x-y coordinates for detector locations <code>gridTrapsXY</code>. <code>rivers</code> is a version of <code>sample.water</code> clipped to the habitat mask and used only for plotting.</p>
<div class="sourceCode" id="cb294"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb294-1"><a href="#cb294-1" tabindex="-1"></a><span class="co"># use package secrlinear to create a discretised version of the network,</span></span>
<span id="cb294-2"><a href="#cb294-2" tabindex="-1"></a><span class="co"># as a handy way to get distance to water </span></span>
<span id="cb294-3"><a href="#cb294-3" tabindex="-1"></a><span class="co"># loading this package also loads secr</span></span>
<span id="cb294-4"><a href="#cb294-4" tabindex="-1"></a><span class="fu">library</span>(secrlinear)</span>
<span id="cb294-5"><a href="#cb294-5" tabindex="-1"></a><span class="fu">library</span>(gdistance)</span></code></pre></div>
<div class="sourceCode" id="cb295"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb295-1"><a href="#cb295-1" tabindex="-1"></a>swlinearmask <span class="ot">&lt;-</span> <span class="fu">read.linearmask</span>(<span class="at">data =</span> sample.water, <span class="at">spacing =</span> <span class="dv">100</span>)</span></code></pre></div>
<div class="sourceCode" id="cb296"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb296-1"><a href="#cb296-1" tabindex="-1"></a><span class="co"># generate secr traps object from detector locations</span></span>
<span id="cb296-2"><a href="#cb296-2" tabindex="-1"></a>tr <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(gridTrapsXY<span class="sc">*</span><span class="dv">1000</span>)  <span class="co"># convert to metres</span></span>
<span id="cb296-3"><a href="#cb296-3" tabindex="-1"></a><span class="fu">names</span>(tr) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>)             </span>
<span id="cb296-4"><a href="#cb296-4" tabindex="-1"></a>tr <span class="ot">&lt;-</span> <span class="fu">read.traps</span>(<span class="at">data=</span>tr, <span class="at">detector =</span> <span class="st">&quot;count&quot;</span>)</span>
<span id="cb296-5"><a href="#cb296-5" tabindex="-1"></a></span>
<span id="cb296-6"><a href="#cb296-6" tabindex="-1"></a><span class="co"># generate 2-D habitat mask</span></span>
<span id="cb296-7"><a href="#cb296-7" tabindex="-1"></a>sw2Dmask <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(tr, <span class="at">buffer =</span> <span class="dv">3950</span>, <span class="at">spacing =</span> <span class="dv">100</span>)</span>
<span id="cb296-8"><a href="#cb296-8" tabindex="-1"></a>d2w <span class="ot">&lt;-</span> <span class="fu">distancetotrap</span>(sw2Dmask, swlinearmask)</span>
<span id="cb296-9"><a href="#cb296-9" tabindex="-1"></a><span class="fu">covariates</span>(sw2Dmask) <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">d2w =</span> d2w<span class="sc">/</span><span class="dv">1000</span>) <span class="co"># km to water</span></span></code></pre></div>
<pre><code>## Warning: attribute variables are assumed to be spatially constant throughout all
## geometries</code></pre>
<div class="sourceCode" id="cb298"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb298-1"><a href="#cb298-1" tabindex="-1"></a><span class="co"># plot distance to water</span></span>
<span id="cb298-2"><a href="#cb298-2" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">1</span>,<span class="dv">6</span>))</span>
<span id="cb298-3"><a href="#cb298-3" tabindex="-1"></a><span class="fu">plot</span>(sw2Dmask, <span class="at">covariate =</span> <span class="st">&quot;d2w&quot;</span>, <span class="at">dots =</span> <span class="cn">FALSE</span>)</span>
<span id="cb298-4"><a href="#cb298-4" tabindex="-1"></a><span class="fu">plot</span>(tr, <span class="at">add =</span> <span class="cn">TRUE</span>)</span>
<span id="cb298-5"><a href="#cb298-5" tabindex="-1"></a><span class="fu">plot</span>(rivers, <span class="at">add =</span> <span class="cn">TRUE</span>, <span class="at">col =</span> <span class="st">&quot;blue&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb299"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb299-1"><a href="#cb299-1" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">include_graphics</span>(<span class="st">&quot;figures/d2w.png&quot;</span>)</span></code></pre></div>
<div class="figure">
<img src="figures/d2w.png" alt="Shaded plot of distance to water (d2w in km) with detector sites (red crosses) and rivers superimposed. Detector spacing 1.5 km N-S." width="95%" />
<p class="caption">
(#fig:A1fig)Shaded plot of distance to water (d2w in km) with detector sites (red crosses) and rivers superimposed. Detector spacing 1.5 km N-S.
</p>
</div>
<p>The distance function requires a value of the friction parameter ‘noneuc’ for each mask pixel. Distances are approximated using <strong>gdistance</strong> functions as before, except that we interpret the distance-to-water scale as ‘friction’ and invert that for <strong>gdistance</strong>.</p>
<div class="sourceCode" id="cb300"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb300-1"><a href="#cb300-1" tabindex="-1"></a>dfn <span class="ot">&lt;-</span> <span class="cf">function</span> (xy1, xy2, mask) {</span>
<span id="cb300-2"><a href="#cb300-2" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">missing</span>(xy1)) <span class="fu">return</span>(<span class="st">&quot;noneuc&quot;</span>)</span>
<span id="cb300-3"><a href="#cb300-3" tabindex="-1"></a>    <span class="fu">require</span>(gdistance)</span>
<span id="cb300-4"><a href="#cb300-4" tabindex="-1"></a>    Sraster <span class="ot">&lt;-</span> <span class="fu">raster</span>(mask, <span class="st">&quot;noneuc&quot;</span>)</span>
<span id="cb300-5"><a href="#cb300-5" tabindex="-1"></a>    <span class="co"># conductance is inverse of friction</span></span>
<span id="cb300-6"><a href="#cb300-6" tabindex="-1"></a>    trans <span class="ot">&lt;-</span> <span class="fu">transition</span>(Sraster, <span class="at">transitionFunction =</span> </span>
<span id="cb300-7"><a href="#cb300-7" tabindex="-1"></a>        <span class="cf">function</span>(x) <span class="dv">1</span><span class="sc">/</span><span class="fu">mean</span>(x), <span class="at">directions =</span> <span class="dv">16</span>)</span>
<span id="cb300-8"><a href="#cb300-8" tabindex="-1"></a>    trans <span class="ot">&lt;-</span> <span class="fu">geoCorrection</span>(trans)</span>
<span id="cb300-9"><a href="#cb300-9" tabindex="-1"></a>    <span class="fu">costDistance</span>(trans, <span class="fu">as.matrix</span>(xy1), <span class="fu">as.matrix</span>(xy2))</span>
<span id="cb300-10"><a href="#cb300-10" tabindex="-1"></a>}    </span></code></pre></div>
<p>The <span class="citation">Royle et al. (<a href="#ref-rcgg13">2013</a>)</span> and <span class="citation">Sutherland, Fuller, and Royle (<a href="#ref-sfr15">2015</a>)</span> models use an (<span class="math inline">\(\alpha_0\)</span>, <span class="math inline">\(\alpha_1\)</span>) parameterisation instead of (<span class="math inline">\(\lambda_0\)</span>, <span class="math inline">\(\sigma\)</span>). Their <span class="math inline">\(\alpha_2\)</span> translates directly to a coefficient in the <strong>secr</strong> model, as we’ll see. We consider just one realisation of one scenario (the package <strong>secrdesign</strong> <span class="citation">Efford (<a href="#ref-R-secrdesign">2023a</a>)</span> manages replicated simulations of multiple scenarios).</p>
<div class="sourceCode" id="cb301"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb301-1"><a href="#cb301-1" tabindex="-1"></a><span class="co"># parameter values from Sutherland et al. 2014</span></span>
<span id="cb301-2"><a href="#cb301-2" tabindex="-1"></a>alpha0 <span class="ot">&lt;-</span> <span class="sc">-</span><span class="dv">1</span>   <span class="co"># implies lambda0 = invlogit(-1) = 0.2689414</span></span>
<span id="cb301-3"><a href="#cb301-3" tabindex="-1"></a>sigma <span class="ot">&lt;-</span> <span class="dv">1400</span></span>
<span id="cb301-4"><a href="#cb301-4" tabindex="-1"></a>alpha1 <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">/</span> (<span class="dv">2</span> <span class="sc">*</span> sigma<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb301-5"><a href="#cb301-5" tabindex="-1"></a>alpha2 <span class="ot">&lt;-</span> <span class="dv">5</span>    <span class="co"># just one scenario from the range 0..10</span></span>
<span id="cb301-6"><a href="#cb301-6" tabindex="-1"></a>K  <span class="ot">&lt;-</span> <span class="dv">10</span>       <span class="co"># sampling over 10 occasions, collapsed to 1 occ</span></span></code></pre></div>
<p>Now we are ready to build a simulated dataset.</p>
<div class="sourceCode" id="cb302"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb302-1"><a href="#cb302-1" tabindex="-1"></a><span class="co"># simulate fixed population of 200 animals in masked area</span></span>
<span id="cb302-2"><a href="#cb302-2" tabindex="-1"></a>pop <span class="ot">&lt;-</span> <span class="fu">sim.popn</span> (<span class="at">D =</span> <span class="dv">200</span><span class="sc">/</span><span class="fu">nrow</span>(sw2Dmask), <span class="at">core =</span> tr, </span>
<span id="cb302-3"><a href="#cb302-3" tabindex="-1"></a>                 <span class="at">buffer =</span> <span class="dv">3950</span>, <span class="at">Ndist =</span> <span class="st">&quot;fixed&quot;</span>)  </span>
<span id="cb302-4"><a href="#cb302-4" tabindex="-1"></a><span class="co"># to simulate non-Euclidean detection we attach a mask with </span></span>
<span id="cb302-5"><a href="#cb302-5" tabindex="-1"></a><span class="co"># the pixel-specific friction to the simulated popn object</span></span>
<span id="cb302-6"><a href="#cb302-6" tabindex="-1"></a><span class="fu">covariates</span>(sw2Dmask)<span class="sc">$</span>noneuc <span class="ot">&lt;-</span> <span class="fu">exp</span>(alpha2 <span class="sc">*</span> </span>
<span id="cb302-7"><a href="#cb302-7" tabindex="-1"></a>                                    <span class="fu">covariates</span>(sw2Dmask)<span class="sc">$</span>d2w)</span>
<span id="cb302-8"><a href="#cb302-8" tabindex="-1"></a><span class="fu">attr</span>(pop, <span class="st">&quot;mask&quot;</span>) <span class="ot">&lt;-</span> sw2Dmask</span>
<span id="cb302-9"><a href="#cb302-9" tabindex="-1"></a><span class="co"># simulate detections, specifying non-Euclidean distance function</span></span>
<span id="cb302-10"><a href="#cb302-10" tabindex="-1"></a>CH <span class="ot">&lt;-</span> <span class="fu">sim.capthist</span>(tr, <span class="at">pop =</span> pop, <span class="at">userdist =</span> dfn, </span>
<span id="cb302-11"><a href="#cb302-11" tabindex="-1"></a>    <span class="at">noccasions =</span> <span class="dv">1</span>, <span class="at">binomN =</span> K, <span class="at">detectpar =</span> <span class="fu">list</span>(<span class="at">lambda0 =</span> </span>
<span id="cb302-12"><a href="#cb302-12" tabindex="-1"></a>    <span class="fu">invlogit</span>(alpha0), <span class="at">sigma =</span> sigma), <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb303"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb303-1"><a href="#cb303-1" tabindex="-1"></a><span class="fu">summary</span>(CH, <span class="at">moves =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## Object class       capthist 
## Detector type      count 
## Detector number    64 
## Average spacing    1385.7 m 
## x-range            1698699 1708399 m 
## y-range            2387891 2398391 m 
## 
## Counts by occasion 
##                     1 Total
## n                  37    37
## u                  37    37
## f                  37    37
## M(t+1)             37    37
## losses              0     0
## detections        109   109
## detectors visited  33    33
## detectors used     64    64
## 
## Number of movements per animal
##  0  1  2  3 
## 16 13  7  1 
## 
## Distance moved, excluding zero (m)
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    1386    1386    1443    1552    1500    3151 
## 
## Individual covariates
##  sex   
##  F:21  
##  M:16</code></pre>
<p>Model fitting is simple, but the default starting value for noneuc is not suitable and is overridden:</p>
<div class="sourceCode" id="cb305"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb305-1"><a href="#cb305-1" tabindex="-1"></a>fitne1 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span> (CH, <span class="at">mask =</span> sw2Dmask, <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>, </span>
<span id="cb305-2"><a href="#cb305-2" tabindex="-1"></a>    <span class="at">binomN =</span> <span class="dv">10</span>, <span class="at">model =</span> noneuc <span class="sc">~</span> d2w <span class="sc">-</span><span class="dv">1</span>, <span class="at">details =</span> <span class="fu">list</span>(</span>
<span id="cb305-3"><a href="#cb305-3" tabindex="-1"></a>    <span class="at">userdist =</span> dfn), <span class="at">start =</span> <span class="fu">list</span>(<span class="at">D =</span> <span class="fl">0.005</span>, <span class="at">lambda0 =</span> <span class="fl">0.3</span>,</span>
<span id="cb305-4"><a href="#cb305-4" tabindex="-1"></a>    <span class="at">sigma =</span> <span class="dv">1000</span>, <span class="at">noneuc =</span> <span class="dv">100</span>), <span class="at">trace =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>The warning from nlm indicates a potential problem, but the standard errors and confidence limits below look plausible (they could be checked by running again with method = “none”). Fitting is slow (4 minutes on an aging PC). This is partly because the mask is large (32384 pixels) in order to maintain resolution in relation to the stream network.</p>
<div class="sourceCode" id="cb306"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb306-1"><a href="#cb306-1" tabindex="-1"></a><span class="fu">coef</span>(fitne1)</span></code></pre></div>
<pre><code>##               beta  SE.beta     lcl      ucl
## D          -5.3042 0.181714 -5.6603 -4.94800
## lambda0    -1.1386 0.169830 -1.4715 -0.80577
## sigma       7.1491 0.091395  6.9699  7.32821
## noneuc.d2w  4.5961 0.503034  3.6102  5.58205</code></pre>
<div class="sourceCode" id="cb308"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb308-1"><a href="#cb308-1" tabindex="-1"></a><span class="fu">predict</span>(fitne1)</span></code></pre></div>
<pre><code>##         link   estimate SE.estimate        lcl        ucl
## D        log 4.9709e-03  9.1079e-04 3.4814e-03 7.0976e-03
## lambda0  log 3.2026e-01  5.4784e-02 2.2958e-01 4.4674e-01
## sigma    log 1.2729e+03  1.1658e+02 1.0642e+03 1.5226e+03
## noneuc   log 1.8279e+02  1.1326e+02 5.9804e+01 5.5867e+02</code></pre>
<div class="sourceCode" id="cb310"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb310-1"><a href="#cb310-1" tabindex="-1"></a><span class="fu">region.N</span>(fitne1)</span></code></pre></div>
<pre><code>##     estimate SE.estimate    lcl    ucl  n
## E.N   160.98      29.495 112.74 229.85 37
## R.N   160.98      26.627 118.77 224.97 37</code></pre>
<p>The coefficient noneuc.d2w corresponds to alpha2. Estimates of predicted (‘real’) parameters D and lambda0, and the coefficient noneuc.d2w, and are comfortably close to the true values, and all true values are covered by the 95% CI.</p>
<p>We fit the ‘noneuc’ (friction) parameter through the origin (zero intercept; <span class="math inline">\(-1\)</span> in formula). The predicted value of ‘noneuc’ relates to the covariate value for the first pixel in the mask (d2w = 1.133 km), but in this zero-intercept model the meaning of ‘noneuc’ itself is obscure. In effect, the parameter alpha1 (or sigma) serves as the intercept; the same model may be fitted by fixing sigma (<code>fixed = list(sigma = 1)</code>) and estimating an intercept for noneuc (<code>model = noneuc ~ d2w</code>). In this case, ‘noneuc’ may be interpreted as the site-specific sigma (see also examples in the main text).</p>
<p>It is interesting to plot the predicted detection probability under the simulated model. For plotting we add the pdot value as an extra covariate of the mask. Note that pdot here uses the ‘noneuc’ value previously added as a covariate to <code>sw2Dmask</code>.</p>
<div class="sourceCode" id="cb312"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb312-1"><a href="#cb312-1" tabindex="-1"></a><span class="fu">covariates</span>(sw2Dmask)<span class="sc">$</span>predicted.pdot <span class="ot">&lt;-</span> <span class="fu">pdot</span>(sw2Dmask, tr, </span>
<span id="cb312-2"><a href="#cb312-2" tabindex="-1"></a>    <span class="at">noccasions =</span> <span class="dv">1</span>, <span class="at">binomN =</span> <span class="dv">10</span>, <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>, <span class="at">detectpar =</span> </span>
<span id="cb312-3"><a href="#cb312-3" tabindex="-1"></a>    <span class="fu">list</span>(<span class="at">lambda0 =</span> <span class="fu">invlogit</span>(<span class="sc">-</span><span class="dv">1</span>), <span class="at">sigma =</span> sigma), <span class="at">userdist =</span> dfn)</span></code></pre></div>
<div class="sourceCode" id="cb313"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb313-1"><a href="#cb313-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">1</span>,<span class="dv">6</span>))</span>
<span id="cb313-2"><a href="#cb313-2" tabindex="-1"></a><span class="fu">plot</span>(sw2Dmask, <span class="at">covariate =</span> <span class="st">&quot;predicted.pdot&quot;</span>, <span class="at">dots =</span> <span class="cn">FALSE</span>)</span>
<span id="cb313-3"><a href="#cb313-3" tabindex="-1"></a><span class="fu">plot</span>(tr, <span class="at">add =</span> <span class="cn">TRUE</span>)</span>
<span id="cb313-4"><a href="#cb313-4" tabindex="-1"></a><span class="fu">plot</span>(rivers, <span class="at">add =</span> <span class="cn">TRUE</span>, <span class="at">col =</span> <span class="st">&quot;blue&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb314"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb314-1"><a href="#cb314-1" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">include_graphics</span>(<span class="st">&quot;figures/predictedpdot.png&quot;</span>)</span></code></pre></div>
<div class="figure">
<img src="figures/predictedpdot.png" alt="Shaded plot of probability animal is detected at least once. Animals living within the detector array and away from a river (about half the population within the array) stand very little chance of being detected because the model confines them to a small home range and lambda0 is constant." width="95%" />
<p class="caption">
(#fig:predictedpdot)Shaded plot of probability animal is detected at least once. Animals living within the detector array and away from a river (about half the population within the array) stand very little chance of being detected because the model confines them to a small home range and lambda0 is constant.
</p>
</div>
<!--chapter:end:16-noneuclidean.Rmd-->
</div>
</div>
<div id="Trend" class="section level1" number="21">
<h1><span class="header-section-number">21</span> Trend revisited</h1>
<p>This section describes methods specifically for population trend, defined as change in density between sessions and measured by the finite rate of increase <span class="math inline">\(\lambda_t = D_{t+1} / D_t\)</span>. The flexible methods described here allow the direct estimation of <span class="math inline">\(\lambda_t\)</span>, possibly including covariate effects.</p>
<div id="dlambda-parameterization" class="section level2" number="21.1">
<h2><span class="header-section-number">21.1</span> ‘Dlambda’ parameterization</h2>
<p>
</p>
<p>We parameterize the density model in terms of the initial density <span class="math inline">\(D_1\)</span> and the finite rates of increase <span class="math inline">\(\lambda_t\)</span> for the remaining sessions (<span class="math inline">\(\lambda_1\)</span> refers to the density increase between Session 1 and Session 2, etc.). Reparameterization of the density model is achieved internally in <code>secr.fit</code> by manipulating the density design matrix to provide a new array of mask-cell- and session-specific densities at each evaluation of the full likelihood. This happens when the details argument ‘Dlambda’ is set to TRUE. The density model (D~) and the fitted coefficients take on a new meaning determined by the internal function <code>Dfn2</code>. More explanation is given <a href="#Review">later</a>.</p>
<p>Now, fitting the ovenbird model with D~1 results in two density parameters (density in session 1, constant finite rate of increase across remaining sessions):</p>
<div class="sourceCode" id="cb315"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb315-1"><a href="#cb315-1" tabindex="-1"></a> msk <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(<span class="fu">traps</span>(ovenCH[[<span class="dv">1</span>]]), <span class="at">buffer =</span> <span class="dv">300</span>, <span class="at">nx =</span> <span class="dv">32</span>)</span>
<span id="cb315-2"><a href="#cb315-2" tabindex="-1"></a> fit1  <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ovenCH, <span class="at">model =</span> D<span class="sc">~</span><span class="dv">1</span>, <span class="at">mask =</span> msk, <span class="at">trace =</span> </span>
<span id="cb315-3"><a href="#cb315-3" tabindex="-1"></a>     <span class="cn">FALSE</span>, <span class="at">details =</span> <span class="fu">list</span>(<span class="at">Dlambda =</span> <span class="cn">TRUE</span>))</span>
<span id="cb315-4"><a href="#cb315-4" tabindex="-1"></a> <span class="fu">coef</span>(fit1)</span></code></pre></div>
<pre><code>##            beta  SE.beta      lcl       ucl
## D.D1   0.032027 0.191324 -0.34296  0.407016
## D.D2  -0.063858 0.070151 -0.20135  0.073636
## g0    -3.561922 0.150654 -3.85720 -3.266646
## sigma  4.363969 0.081052  4.20511  4.522828</code></pre>
<p>Density-relevant beta parameters have names starting with ‘D.’<a href="#fn54" class="footnote-ref" id="fnref54"><sup>54</sup></a>. The first is the log initial density; others relate to the <span class="math inline">\(\lambda\)</span> parameters.</p>
<p>To make the most of the reparameterization we need the special prediction function <code>predictDlambda</code> to extract the lambda estimates (the simple <code>predict</code> method does not work).</p>
<div class="sourceCode" id="cb317"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb317-1"><a href="#cb317-1" tabindex="-1"></a> <span class="fu">predictDlambda</span> (fit1)</span></code></pre></div>
<pre><code>##          estimate SE.estimate       lcl      ucl
## D1      1.0325461  0.19937304 0.7096656 1.502329
## lambda1 0.9381377  0.06589279 0.8176239 1.076415
## lambda2 0.9381377  0.06589279 0.8176239 1.076415
## lambda3 0.9381377  0.06589279 0.8176239 1.076415
## lambda4 0.9381377  0.06589279 0.8176239 1.076415</code></pre>
<p>This is an advance on the earlier approach using sdif contrasts, as we have constrained <span class="math inline">\(\lambda\)</span> to a constant.</p>
</div>
<div id="covariate-and-other-trend-models" class="section level2" number="21.2">
<h2><span class="header-section-number">21.2</span> Covariate and other trend models</h2>
<p>The method allows many covariate models for <span class="math inline">\(\lambda\)</span>. We can fit a time trend in <span class="math inline">\(\lambda\)</span> using:</p>
<div class="sourceCode" id="cb319"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb319-1"><a href="#cb319-1" tabindex="-1"></a> fit2  <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ovenCH, <span class="at">model =</span> D<span class="sc">~</span>Session, <span class="at">mask =</span> msk, </span>
<span id="cb319-2"><a href="#cb319-2" tabindex="-1"></a>     <span class="at">trace =</span> <span class="cn">FALSE</span>, <span class="at">details =</span> <span class="fu">list</span>(<span class="at">Dlambda =</span> <span class="cn">TRUE</span>))</span>
<span id="cb319-3"><a href="#cb319-3" tabindex="-1"></a> <span class="fu">predictDlambda</span> (fit2)</span></code></pre></div>
<pre><code>##         estimate SE.estimate     lcl    ucl
## D1       0.90132    0.212018 0.57193 1.4204
## lambda1  1.14737    0.221235 0.78899 1.6685
## lambda2  0.99977    0.092474 0.83432 1.1980
## lambda3  0.87115    0.085988 0.71826 1.0566
## lambda4  0.75908    0.153416 0.51283 1.1236</code></pre>
<p>Session-specific <span class="math inline">\(\lambda\)</span> (lower-case ‘session’) provide a direct comparison with the original analysis:</p>
<div class="sourceCode" id="cb321"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb321-1"><a href="#cb321-1" tabindex="-1"></a> fit3  <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ovenCH, <span class="at">model =</span> D<span class="sc">~</span>session, <span class="at">mask =</span> msk, </span>
<span id="cb321-2"><a href="#cb321-2" tabindex="-1"></a>     <span class="at">trace =</span> <span class="cn">FALSE</span>, <span class="at">details =</span> <span class="fu">list</span>(<span class="at">Dlambda =</span> <span class="cn">TRUE</span>))</span>
<span id="cb321-3"><a href="#cb321-3" tabindex="-1"></a> <span class="fu">predictDlambda</span> (fit3)</span></code></pre></div>
<pre><code>##         estimate SE.estimate     lcl    ucl
## D1       0.92027     0.22763 0.57081 1.4837
## lambda1  1.04688     0.33132 0.57136 1.9182
## lambda2  1.18184     0.34965 0.66987 2.0851
## lambda3  0.73077     0.22567 0.40447 1.3203
## lambda4  0.84210     0.29413 0.43308 1.6374</code></pre>
<p>The ovenbird population appeared to increase in density for two years and then decline for two years, but the effects are far from significant.</p>
<p>Model selection procedures apply as usual:</p>
<div class="sourceCode" id="cb323"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb323-1"><a href="#cb323-1" tabindex="-1"></a> <span class="fu">AIC</span>(fit1, fit2, fit3, <span class="at">criterion =</span> <span class="st">&#39;AIC&#39;</span>)[,<span class="sc">-</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">6</span>)]</span></code></pre></div>
<pre><code>##                       model npar  logLik  dAIC  AICwt
## fit1       D~1 g0~1 sigma~1    4 -930.73 0.000 0.5692
## fit2 D~Session g0~1 sigma~1    5 -930.07 0.680 0.4051
## fit3 D~session g0~1 sigma~1    8 -929.82 6.192 0.0257</code></pre>
<p>Session covariates are readily applied. The covariate for the second session predicts <span class="math inline">\(\lambda_1 = D_2/D_1\)</span>, for the third session predicts <span class="math inline">\(\lambda_2 = D_3/D_2\)</span>, etc. The covariate for the first session is discarded (remember <span class="math inline">\(D_1\)</span> is constant). This all may be confusing, but you can work it out, and it saves extra coding.</p>
<div class="sourceCode" id="cb325"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb325-1"><a href="#cb325-1" tabindex="-1"></a>covs <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">acov =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>))  <span class="co"># fabricated covariate</span></span>
<span id="cb325-2"><a href="#cb325-2" tabindex="-1"></a>fit4  <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ovenCH, <span class="at">model =</span> D<span class="sc">~</span>acov, <span class="at">mask =</span> msk, </span>
<span id="cb325-3"><a href="#cb325-3" tabindex="-1"></a>    <span class="at">trace =</span> <span class="cn">FALSE</span>, <span class="at">details =</span> <span class="fu">list</span>(<span class="at">Dlambda =</span> <span class="cn">TRUE</span>), </span>
<span id="cb325-4"><a href="#cb325-4" tabindex="-1"></a>    <span class="at">sessioncov =</span> covs)</span>
<span id="cb325-5"><a href="#cb325-5" tabindex="-1"></a> <span class="fu">predictDlambda</span> (fit4)</span></code></pre></div>
<pre><code>##         estimate SE.estimate     lcl    ucl
## D1        1.0281     0.21244 0.68858 1.5349
## lambda1   0.9501     0.21202 0.61677 1.4636
## lambda2   0.9303     0.14528 0.68627 1.2611
## lambda3   0.9303     0.14528 0.68627 1.2611
## lambda4   0.9501     0.21202 0.61677 1.4636</code></pre>
</div>
<div id="fixing-coefficients-1" class="section level2" number="21.3">
<h2><span class="header-section-number">21.3</span> Fixing coefficients</h2>
<p>Another possibility is to fit the model with fixed trend (the second beta coefficient corresponds to lambda, before).</p>
<div class="sourceCode" id="cb327"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb327-1"><a href="#cb327-1" tabindex="-1"></a> fit5 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(ovenCH, <span class="at">model =</span> D<span class="sc">~</span><span class="dv">1</span>, <span class="at">mask =</span> msk, <span class="at">trace =</span> <span class="cn">FALSE</span>,</span>
<span id="cb327-2"><a href="#cb327-2" tabindex="-1"></a>    <span class="at">details =</span> <span class="fu">list</span>(<span class="at">Dlambda =</span> <span class="cn">TRUE</span>, <span class="at">fixedbeta =</span> </span>
<span id="cb327-3"><a href="#cb327-3" tabindex="-1"></a>    <span class="fu">c</span>(<span class="cn">NA</span>, <span class="fu">log</span>(<span class="fl">0.9</span>), <span class="cn">NA</span>, <span class="cn">NA</span>)))</span>
<span id="cb327-4"><a href="#cb327-4" tabindex="-1"></a> <span class="fu">predictDlambda</span>(fit5)</span></code></pre></div>
<pre><code>##         estimate SE.estimate     lcl    ucl
## D1        1.1154     0.15381 0.85231 1.4597
## lambda1   0.9000     0.00000 0.90000 0.9000
## lambda2   0.9000     0.00000 0.90000 0.9000
## lambda3   0.9000     0.00000 0.90000 0.9000
## lambda4   0.9000     0.00000 0.90000 0.9000</code></pre>
<p><!-- For comparison, this can be achieved more conventionally by fixing the  -->
<!-- beta coefficient in a model with log-linear trend over sessions (D~Session): --></p>
<p><!--```{r fixedbeta2, cache = TRUE} -->
<!-- fit6 <- secr.fit(ovenCH, model = D~Session, mask = msk, trace = FALSE, -->
<!--     details = list(Dlambda = FALSE, fixedbeta = c(NA, log(0.9), NA, NA))) -->
<!-- t(sapply(predict(fit6), '[', 'D', )) -->
<!--``` --></p>
</div>
<div id="Review" class="section level2" number="21.4">
<h2><span class="header-section-number">21.4</span> Technical notes and tips</h2>
<p><code>Dfn2</code> performs some tricky manipulations. You can see the code by typing <code>secr:::Dfn2</code>. A column is pre-pended to the density design matrix specifically to model the initial density; this takes the value one in Session 1 and is otherwise zero. Other columns in the design matrix are set to zero for the first session. Session-specific density on the link (log) scale is computed as the cumulative sum across sessions of the initial log density and the modelled log-lambda values.</p>
<p>Note –</p>
<ul>
<li><p>The model allows detector locations and habitat masks to vary between sessions.</p></li>
<li><p>The coding of <code>Dfn2</code> relies on a log link function for density.</p></li>
<li><p>Dlambda is ignored for single-session data and conditional-likelihood (CL) models.</p></li>
<li><p>The method is not (yet) suitable for group models.</p></li>
<li><p>The default start values for D in <code>secr.fit</code> work well: all lambda are initially 1.0 (<span class="math inline">\(\mbox{log}(\lambda_t) = 0\)</span> for all <span class="math inline">\(t\)</span>).</p></li>
<li><p>If session covariates are used in any model, AICcompatible() expects the argument ‘sessioncov’ to be included in all models.</p></li>
</ul>
<p><span style="color: green;">Tip:</span> D for session 1 is constant over space. It is not possible in the present version of <strong>secr</strong> to model simultaneous spatial variation in density or <span class="math inline">\(\lambda\)</span>, and using Dlambda with a density model that includes spatial covariates will cause an error.</p>
<p><!-- <span style='color: green;'>Tip:</span> Underestimation of sampling variance is expected when a trend model is fitted to temporal samples with incomplete population turnover between sessions. The product likelihood assumes a new realisation of the underlying population process for each session. If in actuality much of the sampled population remains the same (the same individuals in the same home ranges) then the precision of the trend coefficient will be overstated.  --></p>
<p><!-- The effect is often small. Possible solutions are to fit an open population model (e.g., in **openCR** [@es20]) or to apply some form of bootstrapping. --></p>
<!--chapter:end:16-trend.Rmd-->
</div>
</div>
<div id="Telemetry" class="section level1" number="22">
<h1><span class="header-section-number">22</span> Telemetry</h1>
<p>In some capture–recapture studies there are additional data from radiotelemetry of a sample of animals. Telemetry fixes provide an unbiased sample of animal activity, unlike detections at fixed points (traps, cameras or hair snares) or from searching circumscribed areas. Telemetry data therefore provide a direct estimate of the spatial scale of activity, which is represented in spatially explicit capture–recapture (SECR) by the parameter <span class="math inline">\(\sigma\)</span>. Telemetry data also reduce uncertainty regarding the location of animals’ centres relative to detectors, so detection histories of telemetered animals may improve estimates of other parameters.</p>
<p>Previous examples are <span class="citation">R. Sollmann et al. (<a href="#ref-sgpsmspo13">2013</a>)</span> and <span class="citation">Whittington, Hebblewhite, and Chandler (<a href="#ref-whc18">2018</a>)</span>. Combining data types has been considered generally by <span class="citation">Gopalaswamy et al. (<a href="#ref-Gopalaswamy2012">2012</a>)</span> etc.</p>
<p>This chapter explains and demonstrates the use of telemetry data in the R package <strong>secr</strong>, particularly the use of the ‘telemetry’ detector type.</p>
<p>A word of warning. Telemetry is used in <strong>secr</strong> to augment SECR analyses, particularly the estimation of population density. <strong>secr</strong> is not intended for the detailed analysis of telemetry data <em>per se</em>. There is no provision in the data structure for recording the time of each fix, except as each relates to a discrete sampling occasion. Nor is there provision for associating behavioural or environmental covariates with each fix.</p>
<div id="telemetryexample" class="section level2" number="22.1">
<h2><span class="header-section-number">22.1</span> Example</h2>
<p>We start with a concrete example based on a simulated dataset. The code for the simulation is in <a href="#telemetryappendix1">Appendix 1</a>.</p>
<p>The first step is to combine the capthist objects <code>trCH</code> (trapping data) and <code>teCH</code> (telemetry fixes).</p>
<div class="sourceCode" id="cb329"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb329-1"><a href="#cb329-1" tabindex="-1"></a>combinedCH <span class="ot">&lt;-</span> <span class="fu">addTelemetry</span>(trCH, teCH)</span></code></pre></div>
<p>Generating plots is straightforward. By default, <code>plot.capthist</code> displays the captures and ignores telemetry fixes. The plot type “telemetry” displays the fixes and distinguishes those of animals that also appear in the (unplotted) capture data of the combined object.</p>
<div class="sourceCode" id="cb330"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb330-1"><a href="#cb330-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>), <span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">2</span>))</span>
<span id="cb330-2"><a href="#cb330-2" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">traps</span>(trCH), <span class="at">border =</span> <span class="dv">150</span>, <span class="at">bty =</span> <span class="st">&#39;o&#39;</span>) <span class="co"># base plot</span></span>
<span id="cb330-3"><a href="#cb330-3" tabindex="-1"></a><span class="fu">plot</span>(combinedCH, <span class="at">title =</span> <span class="st">&#39;Trapping&#39;</span>, <span class="at">tracks =</span> <span class="cn">TRUE</span>, <span class="at">add =</span> <span class="cn">TRUE</span>)</span>
<span id="cb330-4"><a href="#cb330-4" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">traps</span>(trCH), <span class="at">border =</span> <span class="dv">150</span>, <span class="at">bty =</span> <span class="st">&#39;o&#39;</span>) <span class="co"># base plot</span></span>
<span id="cb330-5"><a href="#cb330-5" tabindex="-1"></a><span class="fu">plot</span>(combinedCH, <span class="at">title =</span> <span class="st">&#39;Telemetry&#39;</span>, <span class="at">type =</span> <span class="st">&#39;telemetry&#39;</span>, </span>
<span id="cb330-6"><a href="#cb330-6" tabindex="-1"></a>     <span class="at">tracks =</span> <span class="cn">TRUE</span>, <span class="at">add =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/telemetryfig-1.png" alt="Simulated trapping and telemetry data. The 5-day trapping study (left) yielded `r sum(trCH)-nrow(trCH)` recaptures. Telemetry data were obtained on 10 occasions for each of 12 animals (right). Points for animals that were both trapped and telemetered are ringed in black. Colours distinguish individuals." width="576" />
<p class="caption">
(#fig:telemetryfig)Simulated trapping and telemetry data. The 5-day trapping study (left) yielded <code>r sum(trCH)-nrow(trCH)</code> recaptures. Telemetry data were obtained on 10 occasions for each of 12 animals (right). Points for animals that were both trapped and telemetered are ringed in black. Colours distinguish individuals.
</p>
</div>
<p>Next we fit trapping-only and joint trapping-and-telemetry models:</p>
<div class="sourceCode" id="cb331"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb331-1"><a href="#cb331-1" tabindex="-1"></a>mask <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(<span class="fu">traps</span>(trCH), <span class="at">buffer =</span> <span class="dv">100</span>, <span class="at">type =</span> <span class="st">&#39;trapbuffer&#39;</span>, </span>
<span id="cb331-2"><a href="#cb331-2" tabindex="-1"></a>    <span class="at">nx =</span> <span class="dv">32</span>)</span>
<span id="cb331-3"><a href="#cb331-3" tabindex="-1"></a>args <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">mask =</span> mask, <span class="at">detectfn =</span> <span class="st">&#39;HHN&#39;</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb331-4"><a href="#cb331-4" tabindex="-1"></a>fits <span class="ot">&lt;-</span> <span class="fu">list.secr.fit</span>(<span class="fu">list</span>(trCH, combinedCH), <span class="at">constant =</span> args, </span>
<span id="cb331-5"><a href="#cb331-5" tabindex="-1"></a>    <span class="at">names =</span> <span class="fu">c</span>(<span class="st">&#39;tr&#39;</span>,<span class="st">&#39;combined&#39;</span>))</span>
<span id="cb331-6"><a href="#cb331-6" tabindex="-1"></a><span class="fu">collate</span>(fits)[<span class="dv">1</span>,,,]</span></code></pre></div>
<pre><code>## , , D
## 
##          estimate SE.estimate    lcl    ucl
## tr         5.9057      1.3312 3.8175 9.1363
## combined   5.8976      1.3080 3.8384 9.0615
## 
## , , lambda0
## 
##          estimate SE.estimate      lcl     ucl
## tr       0.118276    0.029911 0.072604 0.19268
## combined 0.097067    0.020792 0.064089 0.14702
## 
## , , sigma
## 
##          estimate SE.estimate    lcl    ucl
## tr         22.027     2.40308 17.798 27.262
## combined   23.461     0.99756 21.586 25.499</code></pre>
<p>Here, telemetry data greatly improves the precision of the estimated scale of movement <span class="math inline">\(\sigma\)</span>, but the effect on estimates of the other two parameters is small.</p>
</div>
<div id="standalone-telemetry-data" class="section level2" number="22.2">
<h2><span class="header-section-number">22.2</span> Standalone telemetry data</h2>
<p>Telemetry data are stored in modified <strong>secr</strong> capthist objects. A capthist object may comprise telemetry fixes only (‘standalone telemetry’) or telemetry fixes in association with capture–recapture data (composite telemetry and capture–recapture). In this section I describe standalone telemetry data. A composite capthist is formed by combining a telemetry-only object and a standard capthist object with <code>addTelemetry</code>, as described in the <a href="#composite">next section</a>.</p>
<div id="the-traps-object-for-telemetry-data" class="section level3" number="22.2.1">
<h3><span class="header-section-number">22.2.1</span> The ‘traps’ object for telemetry data</h3>
<p>Telemetry data differ from all other SECR data in that the detection process does not constrain where animals are detected (telemetry provides a spatially unbiased sample of each animal’s activity). That is clearly not the case for area-search and point detectors, which inevitably constrain where animals are detected. Nevertheless, for compatibility with the rest of <strong>secr</strong>, we associate telemetry data with a notional detector located at a point. The ‘traps’ object for telemetry data comprises the coordinates of this point plus the usual attributes of a ‘traps’ object in <strong>secr</strong> (detector type, usage, etc.). Remember that the point is only a ‘notional’ detector - it is never visited.</p>
<p>The function <code>make.telemetry</code> generates a suitable object:</p>
<div class="sourceCode" id="cb333"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb333-1"><a href="#cb333-1" tabindex="-1"></a>te <span class="ot">&lt;-</span> <span class="fu">make.telemetry</span>()</span>
<span id="cb333-2"><a href="#cb333-2" tabindex="-1"></a><span class="fu">summary</span>(te)</span></code></pre></div>
<pre><code>## Object class       traps 
## Detector type      telemetry 
## Telemetry type     independent</code></pre>
<div class="sourceCode" id="cb335"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb335-1"><a href="#cb335-1" tabindex="-1"></a><span class="fu">str</span>(te)</span></code></pre></div>
<pre><code>## Classes &#39;traps&#39; and &#39;data.frame&#39;:    1 obs. of  2 variables:
##  $ x: num 0
##  $ y: num 0
##  - attr(*, &quot;detector&quot;)= chr &quot;telemetry&quot;
##  - attr(*, &quot;telemetrytype&quot;)= chr &quot;independent&quot;</code></pre>
<p>The attribute <code>telemetrytype</code> is always ‘independent’ for standalone telemetry data; other possible values for composite data are described later.</p>
</div>
<div id="detector-type" class="section level3" number="22.2.2">
<h3><span class="header-section-number">22.2.2</span> Detector type</h3>
<p>Every ‘traps’ object has an associated detector type (attribute <code>detector</code>, commonly ‘multi’ or ‘proximity’). This may be a vector with a different value for each occasion. The detector type for telemetry data is ‘telemetry’. In a standalone telemetry capthist, all elements of <code>detector</code> are ‘telemetry’.</p>
</div>
<div id="but-where-are-the-data" class="section level3" number="22.2.3">
<h3><span class="header-section-number">22.2.3</span> But where are the data?</h3>
<p>As for any other detector type, the body of a telemetry capthist is a 3-D array whose elements are the number of detections for each combination of animal, occasion and detector. Coordinates are stored separately in the ‘telemetryxy’ attribute. Use one of these functions to reveal the telemetry component of a capthist object <code>CH</code>:</p>
<ol style="list-style-type: decimal">
<li><code>str(CH)</code></li>
<li><code>summary(CH)</code></li>
<li><code>plot(CH, type = 'telemetry')</code></li>
<li><code>telemetryxy(CH)</code></li>
</ol>
<p>The attribute ‘telemetryxy’ is a list with one component for each animal. The fixes of each animal are sorted in chronological order.</p>
</div>
<div id="data-input-1" class="section level3" number="22.2.4">
<h3><span class="header-section-number">22.2.4</span> Data input</h3>
<p>Data for a telemetry-only object should be read with function <code>read.telemetry</code>, a simplified version of <code>read.capthist</code>. The input format for telemetry fixes follows the ‘XY’ format for captures, with one line per fix (see <a href="https://www.otago.ac.nz/density/pdfs/secr-datainput.pdf">secr-datainput.pdf</a>).</p>
<p>The first few lines of a text file containing telemetry data collected on 5 occasions might look like this –</p>
<pre><code>1  10 1  -83.3  -20.04
1  10 2  -57.91  -4.77
1  10 3 -112.96  -7.51
1  10 4  -77.71 -75.79
1  10 5  -85.81 -42.45
1 101 1  143.06 170.48
1 101 2   99.22 145.49
etc.</code></pre>
<p>The first column is a session code, the next an animal identifier (‘10’, ‘101’), the third an occasion number (1..noccasions) and the last two are the x and y coordinates. GPS coordinates should be projected (i.e. not latitude and longitude), and in metres if possible.</p>
<p>A file named ‘telemetrydemo.txt’ may be read with</p>
<div class="sourceCode" id="cb338"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb338-1"><a href="#cb338-1" tabindex="-1"></a>CHt <span class="ot">&lt;-</span> <span class="fu">read.telemetry</span>(<span class="at">file =</span> <span class="st">&quot;data/telemetrydemo.txt&quot;</span>)</span></code></pre></div>
<pre><code>## No errors found :-)</code></pre>
<div class="sourceCode" id="cb340"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb340-1"><a href="#cb340-1" tabindex="-1"></a><span class="fu">head</span>(CHt)</span></code></pre></div>
<pre><code>## Session =  1 
## , , 1
## 
##    1 2 3 4 5
## 4  1 1 1 1 1
## 9  1 1 1 1 1
## 10 1 1 1 1 1
## 11 1 1 1 1 1
## 12 1 1 1 1 1
## 14 1 1 1 1 1</code></pre>
<div class="sourceCode" id="cb342"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb342-1"><a href="#cb342-1" tabindex="-1"></a><span class="fu">telemetryxy</span>(CHt)[[<span class="st">&#39;10&#39;</span>]]  <span class="co"># coordinates of first animal</span></span></code></pre></div>
<pre><code>##         x      y
## 1  -83.30 -20.04
## 2  -57.91  -4.77
## 3 -112.96  -7.51
## 4  -77.71 -75.79
## 5  -85.81 -42.45</code></pre>
<p>Input may be from a text file (named in argument ‘file’) or dataframe (argument ‘data’).
The body of the resulting capthist object merely tallies the number of detections per animal per session and occasion. The fixes for one session are stored separately in an attribute that is a list of dataframes, one per animal. Use <code>telemetryxy(CHt)</code> to retrieve this list.</p>
<p>The summary of a telemetry-only capthist is quirky:</p>
<div class="sourceCode" id="cb344"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb344-1"><a href="#cb344-1" tabindex="-1"></a><span class="fu">summary</span>(CHt)</span></code></pre></div>
<pre><code>## Object class       capthist 
## Detector type      telemetry (5) 
## Telemetry type     independent 
## 
## Counts by occasion 
##                    1  2  3  4  5 Total
## n                 79 79 79 79 79   395
## u                 79  0  0  0  0    79
## f                  0  0  0  0 79    79
## M(t+1)            79 79 79 79 79    79
## losses             0  0  0  0  0     0
## detections        79 79 79 79 79   395
## detectors visited  0  0  0  0  0     0
## detectors used     0  0  0  0  0     0
## 
## Empty histories :  79 
## 79 telemetered animals, 0 detected
## 5-5 locations per animal, mean =  5, sd = 0 
## 
## Individual covariates
##        V6      
##  Min.   :1.00  
##  1st Qu.:1.00  
##  Median :2.00  
##  Mean   :1.52  
##  3rd Qu.:2.00  
##  Max.   :2.00</code></pre>
<p>Even though each fix is counted as a ‘detection’ in the body of the final capthist object, none of the telemetered animals is considered to have been ‘detected’ in a conventional SECR sense. The telemetry-only capthist object includes a trivial traps object with a single point. The telemetry type of the traps for a telemetry-only capthist defaults to ‘independent’.</p>
</div>
</div>
<div id="composite" class="section level2" number="22.3">
<h2><span class="header-section-number">22.3</span> Combining telemetry and capture–recapture</h2>
<p>For the purpose of density estimation and modelling, standalone telemetry data are added to an existing spatial capture–recapture (capthist) data object with the function <code>addTelemetry</code>. The relationship between the telemetry and capture–recapture samples is determined by the <code>type</code> argument (default ‘concurrent’). We first explain the possible telemetry types.</p>
<div id="types-of-telemetry-data" class="section level3" number="22.3.1">
<h3><span class="header-section-number">22.3.1</span> Types of telemetry data</h3>
<p><strong>secr</strong> distinguishes three types of telemetry data – independent, dependent and concurrent – that differ in how they relate to other SECR samples (capture–recapture data). Each type corresponds to a particular <a href="#telemetrylikelihood">probability model</a>.</p>
<div class="figure">
<img src="SECRbook_files/figure-html/telemetryschematic-1.png" alt="Schematic relationship of capture--recapture data to three types of telemetry data. Vertical overlap indicates individuals that appear in both datasets." width="90%" />
<p class="caption">
(#fig:telemetryschematic)Schematic relationship of capture–recapture data to three types of telemetry data. Vertical overlap indicates individuals that appear in both datasets.
</p>
</div>
<ol style="list-style-type: decimal">
<li>Independent telemetry</li>
</ol>
<p>Independent telemetry data have no particular relationship to spatial capture–recapture data except that they may be modelled using a shared value of the spatial-scale parameter <span class="math inline">\(\sigma\)</span>, and possibly other spatial parameters. Telemetered animals do not have detection histories.</p>
<ol start="2" style="list-style-type: decimal">
<li>Dependent telemetry</li>
</ol>
<p>Dependent telemetry data relate to a sample of animals detected during the capture–recapture study: an animal must be caught in that study to become telemetered, and no animal is telemetered and not otherwise detected (i.e. no detection history is all-zero).</p>
<ol start="3" style="list-style-type: decimal">
<li>Concurrent telemetry</li>
</ol>
<p>Concurrent telemetry data are obtained for a sample of animals from the same regional population as the capture–recapture study. Telemetered animals appear stochastically in the capture–recapture sample with probability related to their location. Detection histories of some animals may be all-zero, and these are modelled. Whether the capture–recapture phase precedes or follows telemetry is not material.</p>
</div>
<div id="what-exactly-does-addtelemetry-do" class="section level3" number="22.3.2">
<h3><span class="header-section-number">22.3.2</span> What exactly does <code>addTelemetry</code> do?</h3>
<p>The <code>addTelemetry</code> function forms a composite capthist object. Its usage follows -</p>
<pre><code>addTelemetry (detectionCH, telemetryCH, type = c(&quot;concurrent&quot;, &quot;dependent&quot;, 
    &quot;independent&quot;), collapsetelemetry = TRUE, verify = TRUE) </code></pre>
<p>Capture–recapture data in the argument ‘detectionCH’ form the basis for <code>addTelemetry</code>. The base capthist is modified in these ways –</p>
<ul>
<li>For all telemetry types <code>addTelemetry</code> extends the capture–recapture ‘traps’ object by adding a single (notional) detector location (duplicating the first).</li>
<li>By default, the ‘detector’ attribute is extended by a single sampling occasion with type ‘telemetry’; all telemetry data are associated with this occasion, regardless of how many occasions there were in the telemetry input. If <code>collapsetelemetry = FALSE</code> distinct telemetry occasions are retained.</li>
<li>The ‘usage’ attribute is set to zero for the notional telemetry detector on capture occasions and for capture detectors on telemetry occasions. Other usage data from ‘detectionCH’ is retained.</li>
<li>All-zero detection histories are generated for the ‘concurrent’ data type.<br />
</li>
<li>The coordinates of telemetry fixes are transferred from <code>telemetryCH</code> as the attribute ‘telemetryxy’ of the output.</li>
<li>If the data are independent then the labels of telemetered animals are prefixed by ‘T’ to reduce the chance of identity conflicts with animals in ‘detectionCH’.</li>
<li>By default, <code>addtelemetry</code> calls <code>verify.capthist</code> to check its output.</li>
</ul>
</div>
<div id="composite-data-different-sessions" class="section level3" number="22.3.3">
<h3><span class="header-section-number">22.3.3</span> Composite data, different sessions</h3>
<p>We use <code>addTelemetry</code> to combine telemetry data and capture–recapture data from the same session, or possibly for each of several sessions when the detectionCH and telemetryCH are parallel (equal-length) multi-session objects. It is also feasible to concatenate telemetry and capture–recapture data as separate sessions of a multi-session object with <code>MS.capthist</code>. The effect is similar to a single-session composite capthist with telemetrytype ‘independent’, because <strong>secr</strong> treats sessions as independent (i.e. individual histories do not span session boundaries). See the next section for an example.</p>
</div>
</div>
<div id="model-fitting-2" class="section level2" number="22.4">
<h2><span class="header-section-number">22.4</span> Model fitting</h2>
<div id="standalone-telemetry-data-1" class="section level3" number="22.4.1">
<h3><span class="header-section-number">22.4.1</span> Standalone telemetry data</h3>
<p>We can estimate <span class="math inline">\(\sigma\)</span> for a half-normal circular home-range model directly:</p>
<div class="sourceCode" id="cb347"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb347-1"><a href="#cb347-1" tabindex="-1"></a><span class="fu">RPSV</span> (CHt, <span class="at">CC =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] 24.868</code></pre>
<p>Note the CC argument (named for <span class="citation">Calhoun and Casby (<a href="#ref-cc58">1958</a>)</span>) that is required to scale the result correctly.</p>
<p>More laboriously:</p>
<div class="sourceCode" id="cb349"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb349-1"><a href="#cb349-1" tabindex="-1"></a>fit0 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(CHt, <span class="at">buffer =</span> <span class="dv">300</span>, <span class="at">detectfn =</span> <span class="st">&#39;HHN&#39;</span>, </span>
<span id="cb349-2"><a href="#cb349-2" tabindex="-1"></a>                 <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb349-3"><a href="#cb349-3" tabindex="-1"></a><span class="fu">predict</span>(fit0)</span></code></pre></div>
<pre><code>##       link estimate SE.estimate    lcl    ucl
## sigma  log   24.867     0.69957 23.533 26.277</code></pre>
<p>The detection function (argument <code>detectfn</code>) must be either hazard half-normal (14, ‘HHN’) or hazard exponential (16, ‘HEX’)<a href="#fn55" class="footnote-ref" id="fnref55"><sup>55</sup></a>. The default detection function for a dataset with any telemetry component is ‘HHN’. For telemetry-only data the likelihood is conditional on the number of observations, so the argument <code>CL</code> is set internally to TRUE. A large <code>buffer</code> value here brings <span class="math inline">\(\hat \sigma\)</span> from <code>secr.fit</code> closer to <span class="math inline">\(\hat \sigma\)</span> from <code>RPSV</code>. See <a href="#habitatmask">below</a> for more on the <code>buffer</code> argument.</p>
<p>See <a href="#technotes">Technical notes</a> for potential numerical problems.</p>
</div>
<div id="composite-telemetry-and-capturerecapture-data" class="section level3" number="22.4.2">
<h3><span class="header-section-number">22.4.2</span> Composite telemetry and capture–recapture data</h3>
<p>Fitting a model to composite data should raise no further problems: <code>secr.fit</code> receives all the information it requires in the composite capthist input. The likelihood is a straightforward extension of the usual SECR likelihood, with some subtle differences in the case of dependent or concurrent telemetry (Chapter @ref(SpecialTopics), <a href="telemetrylikelihood">Telemetry</a>.</p>
<p>The use of detection functions expressed in terms of the hazard provides a more natural link between the model for the activity distribution and the model for detection probability. When a hazard function is used <code>secr.fit</code> automatically flips the default model for the first detection parameter from ‘g0 ~ 1’ to ‘lambda0 ~ 1’.</p>
<p>Our introductory <a href="#telemetryexample">example</a> fitted a model to single-session composite data. We can compare the results when the telemetry and trapping data are in separate sessions:</p>
<div class="sourceCode" id="cb351"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb351-1"><a href="#cb351-1" tabindex="-1"></a>msCH <span class="ot">&lt;-</span> <span class="fu">MS.capthist</span>(trCH, teCH)</span>
<span id="cb351-2"><a href="#cb351-2" tabindex="-1"></a>fit.ms <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(msCH, <span class="at">mask=</span>mask, <span class="at">detectfn =</span> <span class="st">&#39;HHN&#39;</span>, </span>
<span id="cb351-3"><a href="#cb351-3" tabindex="-1"></a>                   <span class="at">trace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb351-4"><a href="#cb351-4" tabindex="-1"></a><span class="fu">predict</span>(fit.ms)</span></code></pre></div>
<pre><code>## $`session = trCH`
##         link estimate SE.estimate       lcl     ucl
## D        log  5.68802    1.251718  3.714104  8.7110
## lambda0  log  0.10628    0.021189  0.072182  0.1565
## sigma    log 23.63780    1.043956 21.678653 25.7740
## 
## $`session = teCH`
##       link estimate SE.estimate    lcl    ucl
## sigma  log   23.638       1.044 21.679 25.774</code></pre>
<p>Note: If the order of <code>teCH</code> and <code>trCH</code> had been reversed in <code>msCH</code> we would need to use details=list(autoini=2) to base parameter starting values on the trapping data, or provide start values manually.</p>
</div>
<div id="habitatmask" class="section level3" number="22.4.3">
<h3><span class="header-section-number">22.4.3</span> Habitat mask for telemetry data</h3>
<p>The centres of both detected and telemetry-only animals are assumed to lie on the habitat mask. Ensure the mask is large enough to encompass telemetry-only animals. A conservative approach is to buffer around the individual telemetry centroids. Using <code>teCH</code> from before:</p>
<div class="sourceCode" id="cb353"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb353-1"><a href="#cb353-1" tabindex="-1"></a>centroids <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="fu">t</span>(<span class="fu">sapply</span>(<span class="fu">telemetryxy</span>(teCH), </span>
<span id="cb353-2"><a href="#cb353-2" tabindex="-1"></a>    apply, <span class="dv">2</span>, mean)))</span>
<span id="cb353-3"><a href="#cb353-3" tabindex="-1"></a>mask1 <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(centroids, <span class="at">buffer =</span> <span class="dv">100</span>, <span class="at">type =</span> <span class="st">&#39;trapbuffer&#39;</span>)</span></code></pre></div>
<p>For composite telemetry and capture–recapture, buffering should include the detector sites:</p>
<div class="sourceCode" id="cb354"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb354-1"><a href="#cb354-1" tabindex="-1"></a>tmpxy <span class="ot">&lt;-</span> <span class="fu">rbind</span>(centroids, <span class="fu">data.frame</span>(<span class="fu">traps</span>(trCH))) </span>
<span id="cb354-2"><a href="#cb354-2" tabindex="-1"></a>mask2 <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(tmpxy, <span class="at">buffer =</span> <span class="dv">100</span>, <span class="at">type =</span> <span class="st">&#39;trapbuffer&#39;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb355"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb355-1"><a href="#cb355-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span>
<span id="cb355-2"><a href="#cb355-2" tabindex="-1"></a><span class="fu">plot</span>(mask1)</span>
<span id="cb355-3"><a href="#cb355-3" tabindex="-1"></a><span class="fu">plot</span>(teCH, <span class="at">add =</span> <span class="cn">TRUE</span>, <span class="at">title =</span> <span class="st">&#39;Telemetry only&#39;</span>)</span>
<span id="cb355-4"><a href="#cb355-4" tabindex="-1"></a><span class="fu">plot</span>(mask2)</span>
<span id="cb355-5"><a href="#cb355-5" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">traps</span>(trCH), <span class="at">add =</span> <span class="cn">TRUE</span>)</span>
<span id="cb355-6"><a href="#cb355-6" tabindex="-1"></a><span class="fu">plot</span>(teCH, <span class="at">add =</span> <span class="cn">TRUE</span>, <span class="at">title =</span> <span class="st">&#39;Telemetry and detector sites&#39;</span>)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/maskplot-1.png" alt="Habitat masks prepared by buffering around telemetry sites (left) or both telemetry and detector sites (right)." width="576" />
<p class="caption">
(#fig:maskplot)Habitat masks prepared by buffering around telemetry sites (left) or both telemetry and detector sites (right).
</p>
</div>
<p>The mask generated automatically by <code>secr.fit</code> buffers around both detector sites and telemetry fixes, as shown here. The ‘buffer’ argument in <code>make.mask</code> can be problematic when used with a standalone telemetry traps object because the notional detector location is an arbitrary point - it is better to use the centroid coordinates as input.</p>
</div>
</div>
<div id="simulation-1" class="section level2" number="22.5">
<h2><span class="header-section-number">22.5</span> Simulation</h2>
<p>Simulation of joint capture–recapture and telemetry data is a 2-step operation in <strong>secr</strong>, with the steps depending on the type of telemetry sampling. Here is an example of each type.</p>
<p>We choose to fix the number of observations per animal at 25 using the <code>exactN</code> argument of <code>sim.capthist</code>. The same effect can be achieved by increasing the number of occasions to 25 and setting <code>exactN = 1</code>.</p>
<div id="independent-telemetry" class="section level3" number="22.5.1">
<h3><span class="header-section-number">22.5.1</span> Independent telemetry</h3>
<p>For independent data there is no specified connection between the populations sampled, so we separately generate telemetry and capture–recapture datasets and stick them together.</p>
<div class="sourceCode" id="cb356"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb356-1"><a href="#cb356-1" tabindex="-1"></a><span class="co"># detectors</span></span>
<span id="cb356-2"><a href="#cb356-2" tabindex="-1"></a>te <span class="ot">&lt;-</span> <span class="fu">make.telemetry</span>()</span>
<span id="cb356-3"><a href="#cb356-3" tabindex="-1"></a>tr <span class="ot">&lt;-</span> <span class="fu">make.grid</span>(<span class="at">nx =</span> <span class="dv">8</span>, <span class="at">ny =</span> <span class="dv">8</span>, <span class="at">detector =</span> <span class="st">&quot;proximity&quot;</span>)</span>
<span id="cb356-4"><a href="#cb356-4" tabindex="-1"></a>pop1 <span class="ot">&lt;-</span> <span class="fu">sim.popn</span>(tr, <span class="at">D =</span> <span class="dv">10</span>, <span class="at">buffer =</span> <span class="dv">200</span>)</span>
<span id="cb356-5"><a href="#cb356-5" tabindex="-1"></a>pop2 <span class="ot">&lt;-</span> <span class="fu">sim.popn</span>(<span class="at">core =</span> tr, <span class="at">buffer =</span> <span class="dv">200</span>, <span class="at">Nbuffer =</span> <span class="dv">20</span>, </span>
<span id="cb356-6"><a href="#cb356-6" tabindex="-1"></a>                 <span class="at">Ndist =</span> <span class="st">&#39;fixed&#39;</span>)</span>
<span id="cb356-7"><a href="#cb356-7" tabindex="-1"></a>trCH <span class="ot">&lt;-</span> <span class="fu">sim.capthist</span>(tr,  <span class="at">popn =</span> pop1, <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>, </span>
<span id="cb356-8"><a href="#cb356-8" tabindex="-1"></a>    <span class="at">detectpar =</span> <span class="fu">list</span>(<span class="at">lambda0 =</span> <span class="fl">0.1</span>, <span class="at">sigma =</span> <span class="dv">25</span>))</span>
<span id="cb356-9"><a href="#cb356-9" tabindex="-1"></a>teCH <span class="ot">&lt;-</span> <span class="fu">sim.capthist</span>(te,  <span class="at">popn =</span> pop2, <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>, </span>
<span id="cb356-10"><a href="#cb356-10" tabindex="-1"></a>    <span class="at">detectpar =</span> <span class="fu">list</span>(<span class="at">sigma =</span> <span class="dv">25</span>), <span class="at">noccasions =</span> <span class="dv">1</span>, <span class="at">exactN =</span> <span class="dv">25</span>)</span>
<span id="cb356-11"><a href="#cb356-11" tabindex="-1"></a>CHI <span class="ot">&lt;-</span> <span class="fu">addTelemetry</span>(trCH, teCH, <span class="at">type =</span> <span class="st">&#39;independent&#39;</span>)</span></code></pre></div>
<pre><code>## No errors found :-)</code></pre>
<div class="sourceCode" id="cb358"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb358-1"><a href="#cb358-1" tabindex="-1"></a><span class="fu">session</span>(CHI) <span class="ot">&lt;-</span> <span class="st">&#39;Independent&#39;</span></span>
<span id="cb358-2"><a href="#cb358-2" tabindex="-1"></a><span class="fu">summary</span>(CHI)</span></code></pre></div>
<pre><code>## Object class       capthist 
## Detector type      proximity (5), telemetry 
## Telemetry type     independent 
## Detector number    64 
## Average spacing    20 m 
## x-range            0 140 m 
## y-range            0 140 m 
## 
## Usage range by occasion
##     1 2 3 4 5 6
## min 0 0 0 0 0 0
## max 1 1 1 1 1 1
## 
## Counts by occasion 
##                    1  2  3  4  5   6 Total
## n                 24 16 19 22 17  20   118
## u                 24  9  7  5  1  20    66
## f                 35 14 13  4  0   0    66
## M(t+1)            24 33 40 45 46  66    66
## losses             0  0  0  0  0   0     0
## detections        29 19 30 26 19 500   623
## detectors visited 23 16 23 23 18   0   103
## detectors used    64 64 64 64 64   0   320
## 
## Empty histories :  20 
## 20 telemetered animals, 0 detected
## 25-25 locations per animal, mean =  25, sd = 0 
## 
## Individual covariates
##  sex   
##  F:34  
##  M:32</code></pre>
</div>
<div id="dependent-telemetry" class="section level3" number="22.5.2">
<h3><span class="header-section-number">22.5.2</span> Dependent telemetry</h3>
<p>For dependent data the telemetry sample is drawn from animals caught during the capture–recapture phase. This example uses the previously constructed ‘traps’ objects (<code>tr</code> and <code>te</code>). The original numbering of animals must be conserved (<code>renumber = FALSE</code>).</p>
<div class="sourceCode" id="cb360"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb360-1"><a href="#cb360-1" tabindex="-1"></a>pop3 <span class="ot">&lt;-</span> <span class="fu">sim.popn</span>(tr, <span class="at">D =</span> <span class="dv">10</span>, <span class="at">buffer =</span> <span class="dv">200</span>)</span>
<span id="cb360-2"><a href="#cb360-2" tabindex="-1"></a>trCH <span class="ot">&lt;-</span> <span class="fu">sim.capthist</span>(tr,  <span class="at">popn =</span> pop3, <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>, </span>
<span id="cb360-3"><a href="#cb360-3" tabindex="-1"></a>    <span class="at">detectpar =</span> <span class="fu">list</span>(<span class="at">lambda0 =</span> <span class="fl">0.1</span>, <span class="at">sigma =</span> <span class="dv">25</span>), <span class="at">renumber =</span> </span>
<span id="cb360-4"><a href="#cb360-4" tabindex="-1"></a>    <span class="cn">FALSE</span>, <span class="at">savepopn =</span> <span class="cn">TRUE</span>)</span>
<span id="cb360-5"><a href="#cb360-5" tabindex="-1"></a></span>
<span id="cb360-6"><a href="#cb360-6" tabindex="-1"></a><span class="do">## select trapped animals from saved popn</span></span>
<span id="cb360-7"><a href="#cb360-7" tabindex="-1"></a>pop3D <span class="ot">&lt;-</span> <span class="fu">subset</span>(<span class="fu">attr</span>(trCH, <span class="st">&#39;popn&#39;</span>), <span class="fu">rownames</span>(trCH))</span>
<span id="cb360-8"><a href="#cb360-8" tabindex="-1"></a><span class="do">## sample 12 detected animals for telemetry</span></span>
<span id="cb360-9"><a href="#cb360-9" tabindex="-1"></a>pop3Dt <span class="ot">&lt;-</span> <span class="fu">subset</span>(pop3D, <span class="fu">sample.int</span>(<span class="fu">nrow</span>(pop3D), <span class="dv">12</span>))  </span>
<span id="cb360-10"><a href="#cb360-10" tabindex="-1"></a><span class="do">## simulate telemetry</span></span>
<span id="cb360-11"><a href="#cb360-11" tabindex="-1"></a>teCHD <span class="ot">&lt;-</span> <span class="fu">sim.capthist</span>(te, <span class="at">popn =</span> pop3Dt, <span class="at">renumber =</span> <span class="cn">FALSE</span>, </span>
<span id="cb360-12"><a href="#cb360-12" tabindex="-1"></a>    <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>, <span class="at">detectpar =</span> <span class="fu">list</span>(<span class="at">sigma =</span> <span class="dv">25</span>), </span>
<span id="cb360-13"><a href="#cb360-13" tabindex="-1"></a>    <span class="at">noccasions =</span> <span class="dv">1</span>, <span class="at">exactN =</span> <span class="dv">25</span>)</span>
<span id="cb360-14"><a href="#cb360-14" tabindex="-1"></a>CHD <span class="ot">&lt;-</span> <span class="fu">addTelemetry</span>(trCH, teCHD, <span class="at">type =</span> <span class="st">&#39;dependent&#39;</span>)</span></code></pre></div>
<pre><code>## No errors found :-)</code></pre>
<div class="sourceCode" id="cb362"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb362-1"><a href="#cb362-1" tabindex="-1"></a><span class="fu">session</span>(CHD) <span class="ot">&lt;-</span> <span class="st">&#39;Dependent&#39;</span></span>
<span id="cb362-2"><a href="#cb362-2" tabindex="-1"></a><span class="fu">summary</span>(CHD)</span></code></pre></div>
<pre><code>## Object class       capthist 
## Detector type      proximity (5), telemetry 
## Telemetry type     dependent 
## Detector number    64 
## Average spacing    20 m 
## x-range            0 140 m 
## y-range            0 140 m 
## 
## Usage range by occasion
##     1 2 3 4 5 6
## min 0 0 0 0 0 0
## max 1 1 1 1 1 1
## 
## Counts by occasion 
##                    1  2  3  4  5   6 Total
## n                 20 22 22 10 26  12   112
## u                 20 12  8  1  4   0    45
## f                 12 14  9  5  5   0    45
## M(t+1)            20 32 40 41 45  45    45
## losses             0  0  0  0  0   0     0
## detections        33 31 29 11 36 300   440
## detectors visited 25 25 26 10 26   0   112
## detectors used    64 64 64 64 64   0   320
## 12 telemetered animals, 12 detected
## 25-25 locations per animal, mean =  25, sd = 0 
## 
## Individual covariates
##  sex   
##  F:20  
##  M:25</code></pre>
</div>
<div id="concurrent-telemetry" class="section level3" number="22.5.3">
<h3><span class="header-section-number">22.5.3</span> Concurrent telemetry</h3>
<p>For concurrent telemetry a sample of animals is taken from the regional population without reference to whether or not each animal was detected in the capture–recapture phase. The original numbering of animals must be conserved (<code>renumber = FALSE</code>), as for dependent telemetry.</p>
<div class="sourceCode" id="cb364"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb364-1"><a href="#cb364-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">567</span>) </span>
<span id="cb364-2"><a href="#cb364-2" tabindex="-1"></a>pop4 <span class="ot">&lt;-</span> <span class="fu">sim.popn</span>(tr, <span class="at">D =</span> <span class="dv">10</span>, <span class="at">buffer =</span> <span class="dv">200</span>)</span>
<span id="cb364-3"><a href="#cb364-3" tabindex="-1"></a><span class="co"># select 15 individuals at random from larger population</span></span>
<span id="cb364-4"><a href="#cb364-4" tabindex="-1"></a>pop4C <span class="ot">&lt;-</span> <span class="fu">subset</span>(pop4, <span class="fu">sample.int</span>(<span class="fu">nrow</span>(pop4), <span class="dv">15</span>))</span>
<span id="cb364-5"><a href="#cb364-5" tabindex="-1"></a><span class="co"># original animalID (renumber = FALSE) are needed for matching</span></span>
<span id="cb364-6"><a href="#cb364-6" tabindex="-1"></a>trCH <span class="ot">&lt;-</span> <span class="fu">sim.capthist</span>(tr,  <span class="at">popn =</span> pop4, <span class="at">renumber =</span> <span class="cn">FALSE</span>, </span>
<span id="cb364-7"><a href="#cb364-7" tabindex="-1"></a>    <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>, <span class="at">detectpar =</span> <span class="fu">list</span>(<span class="at">lambda0 =</span> <span class="fl">0.1</span>, </span>
<span id="cb364-8"><a href="#cb364-8" tabindex="-1"></a>    <span class="at">sigma =</span> <span class="dv">25</span>))</span>
<span id="cb364-9"><a href="#cb364-9" tabindex="-1"></a>teCHC <span class="ot">&lt;-</span> <span class="fu">sim.capthist</span>(te, <span class="at">popn =</span> pop4C, <span class="at">renumber =</span> <span class="cn">FALSE</span>, </span>
<span id="cb364-10"><a href="#cb364-10" tabindex="-1"></a>    <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>, <span class="at">detectpar =</span> <span class="fu">list</span>(<span class="at">sigma =</span> <span class="dv">25</span>), <span class="at">noccasions =</span></span>
<span id="cb364-11"><a href="#cb364-11" tabindex="-1"></a>    <span class="dv">1</span>, <span class="at">exactN =</span> <span class="dv">25</span>)</span>
<span id="cb364-12"><a href="#cb364-12" tabindex="-1"></a>CHC <span class="ot">&lt;-</span> <span class="fu">addTelemetry</span>(trCH, teCHC, <span class="at">type =</span> <span class="st">&#39;concurrent&#39;</span>)</span></code></pre></div>
<pre><code>## No errors found :-)</code></pre>
<div class="sourceCode" id="cb366"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb366-1"><a href="#cb366-1" tabindex="-1"></a><span class="fu">session</span>(CHC) <span class="ot">&lt;-</span> <span class="st">&#39;Concurrent&#39;</span></span>
<span id="cb366-2"><a href="#cb366-2" tabindex="-1"></a><span class="fu">summary</span>(CHC)</span></code></pre></div>
<pre><code>## Object class       capthist 
## Detector type      proximity (5), telemetry 
## Telemetry type     concurrent 
## Detector number    64 
## Average spacing    20 m 
## x-range            0 140 m 
## y-range            0 140 m 
## 
## Usage range by occasion
##     1 2 3 4 5 6
## min 0 0 0 0 0 0
## max 1 1 1 1 1 1
## 
## Counts by occasion 
##                    1  2  3  4  5   6 Total
## n                 16 17 21 17 16  15   102
## u                 16 12  7  5  3  11    54
## f                 28 11  9  5  1   0    54
## M(t+1)            16 28 35 40 43  54    54
## losses             0  0  0  0  0   0     0
## detections        25 26 27 26 24 375   503
## detectors visited 23 20 22 22 19   0   106
## detectors used    64 64 64 64 64   0   320
## 
## Empty histories :  11 
## 15 telemetered animals, 4 detected
## 25-25 locations per animal, mean =  25, sd = 0 
## 
## Individual covariates
##  sex   
##  F:24  
##  M:30</code></pre>
</div>
<div id="plotting-to-compare-simulated-data" class="section level3" number="22.5.4">
<h3><span class="header-section-number">22.5.4</span> Plotting to compare simulated data</h3>
<div class="sourceCode" id="cb368"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb368-1"><a href="#cb368-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>), <span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">2</span>), <span class="at">xpd =</span> <span class="cn">TRUE</span>)</span>
<span id="cb368-2"><a href="#cb368-2" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">traps</span>(CHI), <span class="at">border =</span> <span class="dv">200</span>, <span class="at">gridlines =</span> <span class="cn">FALSE</span>, <span class="at">bty =</span> <span class="st">&#39;o&#39;</span>)</span>
<span id="cb368-3"><a href="#cb368-3" tabindex="-1"></a><span class="fu">plot</span>(CHI, <span class="at">type =</span> <span class="st">&#39;telemetry&#39;</span>, <span class="at">tracks =</span> <span class="cn">TRUE</span>, <span class="at">add =</span> <span class="cn">TRUE</span>)</span>
<span id="cb368-4"><a href="#cb368-4" tabindex="-1"></a></span>
<span id="cb368-5"><a href="#cb368-5" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">traps</span>(CHD), <span class="at">border =</span> <span class="dv">200</span>, <span class="at">gridlines =</span> <span class="cn">FALSE</span>, <span class="at">bty =</span> <span class="st">&#39;o&#39;</span>)</span>
<span id="cb368-6"><a href="#cb368-6" tabindex="-1"></a><span class="fu">plot</span>(CHD, <span class="at">type =</span> <span class="st">&#39;telemetry&#39;</span>, <span class="at">tracks =</span> <span class="cn">TRUE</span>, <span class="at">add =</span> <span class="cn">TRUE</span>)</span>
<span id="cb368-7"><a href="#cb368-7" tabindex="-1"></a></span>
<span id="cb368-8"><a href="#cb368-8" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">traps</span>(CHC), <span class="at">border =</span> <span class="dv">200</span>, <span class="at">gridlines =</span> <span class="cn">FALSE</span>, <span class="at">bty =</span> <span class="st">&#39;o&#39;</span>)</span>
<span id="cb368-9"><a href="#cb368-9" tabindex="-1"></a><span class="fu">plot</span>(CHC, <span class="at">type =</span> <span class="st">&#39;telemetry&#39;</span>, <span class="at">tracks =</span> <span class="cn">TRUE</span>, <span class="at">add =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="figure">
<img src="SECRbook_files/figure-html/plotsim-1.png" alt="Simulated telemetry data in relation to a capture--recapture grid (red crosses). Independently telemetered individuals are not recognised if they are caught on the grid. Dependent telemetry is restricted to animals caught on the grid. Individuals telemetered concurrently may or may not be caught, but are recognised when they are." width="576" />
<p class="caption">
(#fig:plotsim)Simulated telemetry data in relation to a capture–recapture grid (red crosses). Independently telemetered individuals are not recognised if they are caught on the grid. Dependent telemetry is restricted to animals caught on the grid. Individuals telemetered concurrently may or may not be caught, but are recognised when they are.
</p>
</div>
</div>
</div>
<div id="telemetrytechnotes" class="section level2" number="22.6">
<h2><span class="header-section-number">22.6</span> Technical notes</h2>
<div id="assumption-of-common-sigma" class="section level3" number="22.6.1">
<h3><span class="header-section-number">22.6.1</span> Assumption of common <span class="math inline">\(\sigma\)</span></h3>
<p>Joint analysis of telemetry and capture–recapture data usually relies on the assumption that the same value of the parameter <span class="math inline">\(\sigma\)</span> applies in both sampling processes. This does not hold when</p>
<ul>
<li><p>telemetry fixes have large measurement error that inflates <span class="math inline">\(\sigma\)</span>, or</p></li>
<li><p>the tendency of an animal to interact with a detector after encountering it varies systematically with distance from the home-range centre, or</p></li>
<li><p>activity is not stationary and the telemetry and capture–recapture data relate to different time intervals.</p></li>
</ul>
<p>The assumption may be avoided altogether by modelling distinct values of <span class="math inline">\(\sigma\)</span> on trapping and telemetry occasions. This is readily achieved using the automatic predictor <code>tt</code> in the formula for sigma, as in <code>secr.fit(CH, detectfn = 'HHN', model = sigma~tt, ...)</code>. The model then has one level of sigma for non-telemetry occasions (tt = ‘nontelemetry’) and another for telemetry occasions (tt = ‘telemetry’). However, this sacrifices much of the benefit from a joint analysis when the telemetry data are dependent or concurrent, and all benefit for independent telemetry data.</p>
</div>
<div id="numerical-problems" class="section level3" number="22.6.2">
<h3><span class="header-section-number">22.6.2</span> Numerical problems</h3>
<p>Fitting joint telemetry and SECR models can be difficult - the usual computations in <strong>secr</strong> may fail to return a likelihood. The problem is often due to a near-zero value in a component of the telemetry likelihood. This occurs particularly in large datasets. The problem may be fixed by scaling the offending values by an arbitrary large number given in the details argument ‘telemetryscale’. The required magnitude for ‘telemetryscale’ may be found by experimentation (try 1e3, 1e6, 1e9, 1e12 etc.). This ad hoc solution must be applied consistently if models are to be compared by AIC.</p>
<div class="sourceCode" id="cb369"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb369-1"><a href="#cb369-1" tabindex="-1"></a>te <span class="ot">&lt;-</span> <span class="fu">make.telemetry</span>()</span>
<span id="cb369-2"><a href="#cb369-2" tabindex="-1"></a>teCH2 <span class="ot">&lt;-</span> <span class="fu">sim.capthist</span>(te, <span class="at">popn =</span> <span class="fu">list</span>(<span class="at">D =</span> <span class="dv">2</span>, <span class="at">buffer =</span> <span class="dv">200</span>), </span>
<span id="cb369-3"><a href="#cb369-3" tabindex="-1"></a>    <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>, <span class="at">exactN =</span> <span class="dv">100</span>, <span class="at">detectpar =</span> <span class="fu">list</span>(<span class="at">sigma =</span> <span class="dv">25</span>),</span>
<span id="cb369-4"><a href="#cb369-4" tabindex="-1"></a>    <span class="at">noccasions =</span> <span class="dv">1</span>)</span>
<span id="cb369-5"><a href="#cb369-5" tabindex="-1"></a>mask <span class="ot">&lt;-</span> <span class="fu">make.mask</span>(<span class="fu">traps</span>(teCH2), <span class="at">buffer =</span> <span class="dv">300</span>, <span class="at">type =</span> </span>
<span id="cb369-6"><a href="#cb369-6" tabindex="-1"></a>    <span class="st">&#39;trapbuffer&#39;</span>)</span>
<span id="cb369-7"><a href="#cb369-7" tabindex="-1"></a><span class="co"># fails</span></span>
<span id="cb369-8"><a href="#cb369-8" tabindex="-1"></a>fit1 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(teCH2, <span class="at">mask =</span> mask, <span class="at">detectfn =</span> <span class="st">&#39;HHN&#39;</span>, <span class="at">CL =</span> <span class="cn">TRUE</span>, </span>
<span id="cb369-9"><a href="#cb369-9" tabindex="-1"></a>    <span class="at">trace =</span> <span class="cn">FALSE</span>, <span class="at">details =</span> <span class="fu">list</span>(<span class="at">telemetryscale =</span> <span class="dv">1</span>)) </span>
<span id="cb369-10"><a href="#cb369-10" tabindex="-1"></a><span class="fu">predict</span>(fit1)</span></code></pre></div>
<pre><code>##       link estimate SE.estimate lcl ucl
## sigma  log       NA          NA  NA  NA</code></pre>
<div class="sourceCode" id="cb371"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb371-1"><a href="#cb371-1" tabindex="-1"></a><span class="co"># succeeds</span></span>
<span id="cb371-2"><a href="#cb371-2" tabindex="-1"></a>fit1000 <span class="ot">&lt;-</span> <span class="fu">secr.fit</span>(teCH2, <span class="at">mask =</span> mask, <span class="at">detectfn =</span> <span class="st">&#39;HHN&#39;</span>, </span>
<span id="cb371-3"><a href="#cb371-3" tabindex="-1"></a>    <span class="at">CL =</span> <span class="cn">TRUE</span>, <span class="at">trace =</span> <span class="cn">FALSE</span>, <span class="at">details =</span> <span class="fu">list</span>(<span class="at">telemetryscale =</span> </span>
<span id="cb371-4"><a href="#cb371-4" tabindex="-1"></a>    <span class="fl">1e3</span>)) </span>
<span id="cb371-5"><a href="#cb371-5" tabindex="-1"></a><span class="fu">predict</span>(fit1000)</span></code></pre></div>
<pre><code>##       link estimate SE.estimate    lcl    ucl
## sigma  log   25.044     0.20636 24.643 25.452</code></pre>
<p>Numerical problems may also be caused by inappropriate starting values, poor model specification, or an unknown bug. It may help to use the longer-tailed detection function ‘HEX’ instead of ‘HHN’.</p>
</div>
<div id="learned-response" class="section level3" number="22.6.3">
<h3><span class="header-section-number">22.6.3</span> Learned response</h3>
<p>Learned responses (b, bk) are not expected in telemetry data. However, they may make sense for the ‘SECR’ occasions of a composite dataset (combined stationary detectors and telemetry). There is no way to avoid a global learned response (b) from propagating to the telemetry occasions (i.e. modelling different telemetry sigmas for animals detected or not detected in the pre-telemetry phase). A site-specific learned response, however, cannot propagate to the telemetry phase if there is a single telemetry ‘occasion’ because (i) no animal is detected at the notional telemetry detector in the pre-telemetry phase, and (ii) there is no opportunity for learning within the telemetry phase if all detections are on one occasion.</p>
</div>
</div>
<div id="telemetrylimitations" class="section level2" number="22.7">
<h2><span class="header-section-number">22.7</span> Limitations</h2>
<p>In <strong>secr</strong> some important functions have yet to be updated to work with telemetry data. These are listed in <a href="#telemetryappendix2">Appendix 2</a>. Other limitations are described here.</p>
<div id="incompatible-with-area-search" class="section level3" number="22.7.1">
<h3><span class="header-section-number">22.7.1</span> Incompatible with area search</h3>
<p>Telemetry data may not be combined with area-search (polygon) data except as independent data in distinct sessions. This is because the polygon data types presently implemented in <strong>secr</strong> must be constant across a session.</p>
<p>If the ‘independent data, distinct-session’ solution is inadequate you might try rasterizing the search area (function <code>discretize</code>).</p>
</div>
<div id="incompatible-with-markresight" class="section level3" number="22.7.2">
<h3><span class="header-section-number">22.7.2</span> Incompatible with mark–resight</h3>
<p>Telemetry data may not be combined with mark-resight except possibly in distinct sessions (this has not been tested).</p>
</div>
<div id="incompatible-with-hybrid-heterogeneity-model" class="section level3" number="22.7.3">
<h3><span class="header-section-number">22.7.3</span> Incompatible with hybrid heterogeneity model</h3>
<p>The <code>secr.fit</code> code for hybrid heterogeneity models (hcov) has yet to be updated.</p>
</div>
<div id="non-euclidean-distance" class="section level3" number="22.7.4">
<h3><span class="header-section-number">22.7.4</span> Non-Euclidean distance</h3>
<p>Non-Euclidean distance methods cannot be used with telemetry data at present (a very large distance matrix would be required).</p>
</div>
</div>
<div id="telemetryappendix1" class="section level2" number="22.8">
<h2><span class="header-section-number">22.8</span> Appendix 1. Code used to simulate data for initial demonstration</h2>
<div class="sourceCode" id="cb373"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb373-1"><a href="#cb373-1" tabindex="-1"></a><span class="co"># simulate capthist objects (trCH, teCH)</span></span>
<span id="cb373-2"><a href="#cb373-2" tabindex="-1"></a><span class="fu">library</span>(secr)</span>
<span id="cb373-3"><a href="#cb373-3" tabindex="-1"></a><span class="co"># detectors</span></span>
<span id="cb373-4"><a href="#cb373-4" tabindex="-1"></a>te <span class="ot">&lt;-</span> <span class="fu">make.telemetry</span>()</span>
<span id="cb373-5"><a href="#cb373-5" tabindex="-1"></a>tr <span class="ot">&lt;-</span> <span class="fu">make.grid</span>(<span class="at">detector =</span> <span class="st">&quot;multi&quot;</span>, <span class="at">nx =</span> <span class="dv">8</span>, <span class="at">ny =</span> <span class="dv">8</span>)</span>
<span id="cb373-6"><a href="#cb373-6" tabindex="-1"></a></span>
<span id="cb373-7"><a href="#cb373-7" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb373-8"><a href="#cb373-8" tabindex="-1"></a>pop4 <span class="ot">&lt;-</span> <span class="fu">sim.popn</span>(tr, <span class="at">D =</span> <span class="dv">5</span>, <span class="at">buffer =</span> <span class="dv">100</span>, <span class="at">seed =</span> <span class="dv">567</span>)</span>
<span id="cb373-9"><a href="#cb373-9" tabindex="-1"></a><span class="co"># select 12 individuals at random from larger population</span></span>
<span id="cb373-10"><a href="#cb373-10" tabindex="-1"></a>pop4C <span class="ot">&lt;-</span> <span class="fu">subset</span>(pop4, <span class="fu">sample.int</span>(<span class="fu">nrow</span>(pop4), <span class="dv">12</span>))</span>
<span id="cb373-11"><a href="#cb373-11" tabindex="-1"></a><span class="co"># original animalID (renumber = FALSE) are needed for matching</span></span>
<span id="cb373-12"><a href="#cb373-12" tabindex="-1"></a>trCH <span class="ot">&lt;-</span> <span class="fu">sim.capthist</span>(tr,  <span class="at">popn =</span> pop4, <span class="at">renumber =</span> <span class="cn">FALSE</span>, </span>
<span id="cb373-13"><a href="#cb373-13" tabindex="-1"></a>    <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>, <span class="at">detectpar =</span> <span class="fu">list</span>(<span class="at">lambda0 =</span> <span class="fl">0.1</span>, </span>
<span id="cb373-14"><a href="#cb373-14" tabindex="-1"></a>    <span class="at">sigma =</span> <span class="dv">25</span>), <span class="at">seed =</span> <span class="dv">123</span>)</span>
<span id="cb373-15"><a href="#cb373-15" tabindex="-1"></a><span class="fu">session</span>(trCH) <span class="ot">&lt;-</span> <span class="st">&#39;Trapping&#39;</span></span>
<span id="cb373-16"><a href="#cb373-16" tabindex="-1"></a>teCH <span class="ot">&lt;-</span> <span class="fu">sim.capthist</span>(te, <span class="at">popn =</span> pop4C, <span class="at">renumber =</span> <span class="cn">FALSE</span>, </span>
<span id="cb373-17"><a href="#cb373-17" tabindex="-1"></a>    <span class="at">detectfn =</span> <span class="st">&quot;HHN&quot;</span>, <span class="at">detectpar =</span> <span class="fu">list</span>(<span class="at">lambda0 =</span> <span class="dv">1</span>, <span class="at">sigma =</span> <span class="dv">25</span>),</span>
<span id="cb373-18"><a href="#cb373-18" tabindex="-1"></a>    <span class="at">noccasions =</span> <span class="dv">10</span>, <span class="at">seed =</span> <span class="dv">345</span>)</span>
<span id="cb373-19"><a href="#cb373-19" tabindex="-1"></a><span class="fu">session</span>(teCH) <span class="ot">&lt;-</span> <span class="st">&#39;Telemetry&#39;</span></span></code></pre></div>
</div>
<div id="telemetryappendix2" class="section level2" number="22.9">
<h2><span class="header-section-number">22.9</span> Appendix 2.</h2>
<table>
<caption>(#tab:telemetryfunctions) Functions specifically for telemetry data</caption>
<colgroup>
<col width="22%" />
<col width="77%" />
</colgroup>
<thead>
<tr class="header">
<th>Function</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>addTelemetry</code></td>
<td>combine capture-recapture and telemetry data in new capthist</td>
</tr>
<tr class="even">
<td><code>make.telemetry</code></td>
<td>build a traps object for standalone telemetry data</td>
</tr>
<tr class="odd">
<td><code>read.telemetry</code></td>
<td>input telemetry fixes from text file or dataframe</td>
</tr>
<tr class="even">
<td><code>telemetered</code></td>
<td>determine which animals in a capthist object have telemetry data</td>
</tr>
<tr class="odd">
<td><code>telemetrytype</code></td>
<td>extract or replace the ‘telemetrytype’ attribute of a traps object</td>
</tr>
<tr class="even">
<td><code>telemetryxy</code></td>
<td>extract or replace telemetry coordinates from capthist</td>
</tr>
<tr class="odd">
<td><code>xy2CH</code></td>
<td>make a standalone telemetry capthist from a composite capthist</td>
</tr>
</tbody>
</table>
<table>
<caption>(#tab:telemetrygeneralfunctions) Telemetry-ready general functions</caption>
<thead>
<tr class="header">
<th>Function</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>derived</code></td>
<td>Horvitz-Thompson-like density estimate</td>
</tr>
<tr class="even">
<td><code>join</code></td>
<td>combine sessions of multi-session capthist object</td>
</tr>
<tr class="odd">
<td><code>make.capthist</code></td>
<td>build capthist object</td>
</tr>
<tr class="even">
<td><code>moves</code></td>
<td>sequential movements*</td>
</tr>
<tr class="odd">
<td><code>MS.capthist</code></td>
<td>form multi-session capthist from separate sessions</td>
</tr>
<tr class="even">
<td><code>plot.capthist</code></td>
<td>plotting (type = ‘telemetry’)</td>
</tr>
<tr class="odd">
<td><code>rbind.capthist</code></td>
<td>concatenate rows of capthist</td>
</tr>
<tr class="even">
<td><code>RPSV</code>, <code>MMDM</code>, <code>ARL</code>, <code>dbar</code></td>
<td>indices of home-range size*</td>
</tr>
<tr class="odd">
<td><code>secr.fit</code></td>
<td>model fitting</td>
</tr>
<tr class="even">
<td><code>sim.capthist</code></td>
<td>generate capthist data</td>
</tr>
<tr class="odd">
<td><code>subset.capthist</code></td>
<td>select subset of animals, occasions or detectors</td>
</tr>
<tr class="even">
<td><code>summary.capthist</code></td>
<td>summary</td>
</tr>
<tr class="odd">
<td><code>verify.capthist</code></td>
<td>perform integrity checks</td>
</tr>
<tr class="even">
<td><code>verify.traps</code></td>
<td>perform integrity checks</td>
</tr>
</tbody>
</table>
<p><code>*</code> these functions use the telemetry coordinates if the capthist is telemetry-only, otherwise the detection sites</p>
<table>
<caption>(#tab:telemetrynonfunctions) General functions not ready for telemetry.</caption>
<thead>
<tr class="header">
<th>Function</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>reduce.capthist</code></td>
<td>change detector type or collapse occasions</td>
</tr>
<tr class="even">
<td><code>sim.secr</code></td>
<td>parametric bootstrap fitted model</td>
</tr>
<tr class="odd">
<td><code>simulate</code></td>
<td>simulate from fitted model</td>
</tr>
<tr class="even">
<td><code>secr.test</code></td>
<td>another parametric boostrap</td>
</tr>
<tr class="odd">
<td><code>fx.total</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>fxi.contour</code></td>
<td></td>
</tr>
</tbody>
</table>
<!--chapter:end:16-telemetry.Rmd-->
</div>
</div>
<div id="Expected" class="section level1" number="23">
<h1><span class="header-section-number">23</span> Expected counts</h1>
<p>It can be useful to predict various count statistics from a fitted model or from hypothetical parameter values or from a design that has been altered without changing parameter values. Here we repeat and extend formulae from <span class="citation">Efford and Boulanger (<a href="#ref-eb19">2019</a>)</span>. See <strong>secrdesign</strong> and <a href="https://www.otago.ac.nz/density/pdfs/secrdesign-Enrm.pdf">secrdesign-Enrm.pdf</a> for an implementation.</p>
<p>For convenience we formulate the detection process in terms of hazard <span class="math inline">\(\lambda(d_k(\mathbf{x}))\)</span> rather than probability <span class="math inline">\(g(d_k(\mathbf{x}))\)</span>, but the two are interchangeable<a href="#fn56" class="footnote-ref" id="fnref56"><sup>56</sup></a>. The overall detection rate on occasion <span class="math inline">\(s\)</span> of an AC at location <span class="math inline">\(\mathbf{x}\)</span> is
<span class="math display">\[\begin{equation}
\Lambda_s(\mathbf{x}) = \sum_K \lambda(d_k(\mathbf{x})),
\end{equation}\]</span>
and aggregating over occasions gives <span class="math inline">\(\Lambda(\mathbf{x}) = \sum_s \Lambda_s(\mathbf{x})\)</span>.</p>
<p>If all potential detections are recorded then <span class="math inline">\(\Lambda_s(\mathbf{x})\)</span> is the expected total number of detections on one occasion for an animal centred at <span class="math inline">\(\mathbf{x}\)</span>. Only Poisson proximity detectors are assumed to act like this. Other detector types collect binary data (e.g. binary proximity detectors record only whether an individual appeared at least once or not at all at a detector on a certain occasion). Nevertheless, <span class="math inline">\(\Lambda_s(\mathbf{x})\)</span> is useful for predicting the outcome for binary detector types as shown later. Single-catch traps are a special case for which there are not closed-form expressions for <span class="math inline">\(\mbox{E} (n)\)</span> and <span class="math inline">\(\mbox{E} (r)\)</span>.</p>
<div id="number-of-individuals-n" class="section level2" number="23.1">
<h2><span class="header-section-number">23.1</span> Number of individuals <span class="math inline">\(n\)</span></h2>
<p>The expected number of individuals detected at least once is <span class="math display">\[E(n) = \int [1 - \exp\{-\Lambda(\mathbf{x}) \} ] \times  D(\mathbf{x}) \; d \mathbf{x}.\]</span> This is the same for all detector types in which individuals are detected independently of each other (‘multi’, ‘binary proximity’ or ‘Poisson proximity’). Integration is over all locations in the plane from which an individual might be detected. The region of integration is represented in practice by a discretized ‘habitat mask’, and integration is performed by summing over cells.</p>
</div>
<div id="number-of-detections-c" class="section level2" number="23.2">
<h2><span class="header-section-number">23.2</span> Number of detections <span class="math inline">\(C\)</span></h2>
<p>The total number of detections <span class="math inline">\(C\)</span> depends on the detector type, as follows.</p>
<div id="detector-type-poisson-proximity" class="section level3" number="23.2.1">
<h3><span class="header-section-number">23.2.1</span> Detector type ‘Poisson proximity’</h3>
<p>This is the simplest case –
<span class="math display">\[E(C) = \int \Lambda(\mathbf{x}) \times D(\mathbf{x}) \; d\mathbf{x}.\]</span></p>
</div>
<div id="detector-type-multi-catch-trap" class="section level3" number="23.2.2">
<h3><span class="header-section-number">23.2.2</span> Detector type ‘multi-catch trap’</h3>
<p>Data from ‘multi’ detectors are binary at the level of each animal <span class="math inline">\(\times\)</span> occasion, with Bernoulli probability <span class="math inline">\(p_s = 1 - \exp\{- \Lambda_s(\mathbf{x})\}\)</span>. This leads to the overall number of detections – <span class="math display">\[E(C) = \int \sum_s p_s(\mathbf{x}) \times D(\mathbf{x}) \; d \mathbf{x}.\]</span></p>
</div>
<div id="detector-type-binary-proximity" class="section level3" number="23.2.3">
<h3><span class="header-section-number">23.2.3</span> Detector type ‘binary proximity’</h3>
<p>Data from binary proximity detectors are binary at the level of each animal <span class="math inline">\(\times\)</span> detector <span class="math inline">\(\times\)</span> occasion, with Bernoulli probability <span class="math inline">\(p_{ks}(\mathbf{x}) = 1 - \exp\{- \lambda(d_k(\mathbf{x}))\}\)</span>. This leads to the overall number of detections – <span class="math display">\[E(C) = \int \sum_s \sum_k p_{ks}(\mathbf{x}) \times D(\mathbf{x}) \; d\mathbf{x}.\]</span></p>
<p><!-- These calculations assume a homogeneous distribution of animals across space, leading to a constant hazard for each detector. That is never the case, because the hazard for each individual is peaked near its activity centre and individuals are distributed at random, leading to more or less rough hazard surface. Variance in the per-detector hazard leads to systematic bias. --></p>
</div>
</div>
<div id="number-of-recaptures-r" class="section level2" number="23.3">
<h2><span class="header-section-number">23.3</span> Number of recaptures <span class="math inline">\(r\)</span></h2>
<p>For all detector types the expected number of recaptures is simply <span class="math inline">\(E(r) = E(C) - E(n).\)</span></p>
</div>
<div id="number-of-movements-m" class="section level2" number="23.4">
<h2><span class="header-section-number">23.4</span> Number of movements <span class="math inline">\(m\)</span></h2>
<p>A movement is a recapture (redetection) at a site other than the previous one. Movements are a subset of recaptures. We calculate the expected number of movements by considering each recapture event in turn and calculating the conditional probability that it is at the same site as before. This is a sum of squared detector-wise conditional probabilities.</p>
<p>Conditional on detection somewhere, the probability of detection in detector <span class="math inline">\(k\)</span> is <span class="math inline">\(q_k(\mathbf{x}) = \lambda(d_k(\mathbf{x})) / \sum_k \lambda(d_k(\mathbf{x}))\)</span>. For clarity in the following detector-specific expressions we use <span class="math inline">\(a(\mathbf{x}) = 1 - \exp\{-\Lambda(\mathbf{x})\})\)</span> and <span class="math inline">\(b(\mathbf{x}) = 1-\sum_k q_k(\mathbf{x})^2\)</span>.</p>
<div id="detector-type-poisson-proximity-1" class="section level3" number="23.4.1">
<h3><span class="header-section-number">23.4.1</span> Detector type ‘Poisson proximity’</h3>
<p><span class="math display">\[E(m) = \int \{ \Lambda(\mathbf{x}) - a(\mathbf{x})\} \times b(\mathbf{x}) \times D(\mathbf{x}) \; d\mathbf{x}.\]</span></p>
</div>
<div id="detector-type-multi-catch-trap-1" class="section level3" number="23.4.2">
<h3><span class="header-section-number">23.4.2</span> Detector type ‘multi-catch trap’</h3>
<p><span class="math display">\[E(m) = \int \{\sum_s p_s(\mathbf{x}) - a(\mathbf{x})\} \times b(\mathbf{x}) \times D(\mathbf{x}) \; d\mathbf{x}.\]</span></p>
</div>
<div id="detector-type-binary-proximity-1" class="section level3" number="23.4.3">
<h3><span class="header-section-number">23.4.3</span> Detector type ‘binary proximity’</h3>
<p><span class="math display">\[E(m) = \int \{ \sum_s \sum_k p_{ks}(\mathbf{x})  - a(\mathbf{x}) \} \times b(\mathbf{x}) \times D(\mathbf{x}) \; d\mathbf{x}.\]</span></p>
</div>
<div id="caveat" class="section level3" number="23.4.4">
<h3><span class="header-section-number">23.4.4</span> Caveat</h3>
<p>If an animal may be detected more than once on one occasion (as with ‘proximity’ and ‘count’ detector types) and time of detection is not recorded within each occasion (the norm in <strong>secr</strong>) then the temporal sequence of detections is not fully observed. The number of observed (apparent) movements is then less than or equal to the true number. Results from the <code>moves</code> function in <strong>secr</strong> are also not to be trusted: they effectively assume any repeat detections at the same site precede other redetections rather than being interspersed in time. Precise formulae are not available for the expected number of observed movements among proximity and count detectors. There should be little discrepancy between observed and true numbers when detections are sparse. The predicted number of movements is close to the apparent number in simulations (see later section; this deserves further investigation).</p>
</div>
</div>
<div id="individuals-detected-at-two-or-more-detectors-n_2" class="section level2" number="23.5">
<h2><span class="header-section-number">23.5</span> Individuals detected at two or more detectors <span class="math inline">\(n_2\)</span></h2>
<p>This count is related to the optimization criterion <span class="math inline">\(Q_{p_m}\)</span> of <span class="citation">Dupont et al. (<a href="#ref-drns21">2021</a>)</span>. The value is simply the total count <span class="math inline">\(\mbox{E}(n)\)</span> minus the number detected at only one detector <span class="math inline">\(\mbox{E}(n_1)\)</span>. For
independent detectors (proximity detectors of any sort) the calculation follows from <span class="citation">Dupont et al. (<a href="#ref-drns21">2021</a>)</span>: setting <span class="math inline">\(p_0(\mathbf{x}) = \exp (-S\Lambda(\mathbf{x}))\)</span> and <span class="math inline">\(p_k(\mathbf{x}) = \exp\{-S \lambda[d_k(\mathbf{x})]\}\)</span>,</p>
<p><span class="math display">\[E(n_1) = \int p_0(\mathbf{x}) \sum_k \frac{p_k(\mathbf{x})}{1 - p_k(\mathbf{x})} \times D(\mathbf{x}) \; d \mathbf{x}.\]</span>
Then <span class="math inline">\(\mbox{E}(n_2) = \mbox{E}(n) - \mbox{E}(n_1)\)</span>.</p>
<p>The calculation of <span class="math inline">\(\mbox{E}(n_1)\)</span> is more messy for non-independent detectors, specifically multi-catch traps. Using <span class="math inline">\(p_{ks}(\mathbf{x}) = [1 - \exp(-\Lambda(\mathbf{x}))] \; \lambda(d_k(\mathbf{x})) / \Lambda(\mathbf{x})\)</span> for the probability an individual at <span class="math inline">\(\mathbf{x}\)</span> is caught at <span class="math inline">\(k\)</span> on a particular occasion, and <span class="math inline">\(p^*_{ks}(\mathbf{x}) = [1 - \exp(-\Lambda(\mathbf{x}))] \; (1 - \lambda(d_k(\mathbf{x})) / \Lambda(\mathbf{x}))\)</span> for the probability it is caught elsewhere:</p>
<p><span class="math display">\[E(n_1) = \int \sum_k \left( 1 - [1-p_{ks}(\mathbf{x})]^S \right) \;  [1-p^*_{ks}(\mathbf{x})]^{S-1} \times D(\mathbf{x}) \; d \mathbf{x}.\]</span></p>
</div>
<div id="single-catch-traps" class="section level2" number="23.6">
<h2><span class="header-section-number">23.6</span> Single-catch traps</h2>
<p>All the preceding calculations assume independence among animals. If traps can catch only one animal at a time then animals effectively compete for access (the first arrival is most likely to be caught). This depresses the realised hazard of detection <span class="math inline">\(\lambda(d_k(\mathbf{x}); \theta)\)</span>; the effect increases with density. No closed-form expressions exist for this case. The computed <span class="math inline">\(\mbox{E}(n)\)</span>, <span class="math inline">\(\mbox{E}(r)\)</span> and <span class="math inline">\(\mbox{E}(m)\)</span> for multi-catch traps (detector ‘multi’) will exceed the true values for the single-catch traps (detector ‘single’) <em>given the same detection parameters</em>. That final caveat is significant because a pilot value of <span class="math inline">\(\hat \lambda_0\)</span> from fitting a multi-catch model to single-catch data will be an underestimate <span class="citation">(<a href="#ref-ebb09">Efford, Borchers, and Byrom 2009</a>)</span>.</p>
</div>
<div id="number-of-animals-detected-at-detector-k" class="section level2" number="23.7">
<h2><span class="header-section-number">23.7</span> Number of animals detected at detector <span class="math inline">\(k\)</span></h2>
<p>[To be added]</p>
<!--chapter:end:16-expected-counts.Rmd-->
</div>
</div>
<div id="Datasets" class="section level1" number="24">
<h1><span class="header-section-number">24</span> Datasets</h1>
<p>These datasets are included in <strong>secr</strong>. See each linked help page for details. Code for model fitting is in <a href="https://www.otago.ac.nz/density/pdfs/secr-version4.pdf">secr-version4.pdf</a>.</p>
<table>
<colgroup>
<col width="17%" />
<col width="82%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Dataset</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="https://www.otago.ac.nz/density/html/deermouse.html">deermouse</a></td>
<td align="left"><em>Peromyscus maniculatus</em> live-trapping data of V. H. Reid published as a CAPTURE example by <span class="citation">Otis et al. (<a href="#ref-obwa78">1978</a>)</span></td>
</tr>
<tr class="even">
<td align="left"><a href="https://www.otago.ac.nz/density/html/hornedlizard.html">hornedlizard</a></td>
<td align="left">Repeated searches of a quadrat in Arizona for flat-tailed horned lizards <em>Phrynosoma mcallii</em> <span class="citation">(<a href="#ref-ry08">Royle and Young 2008</a>)</span></td>
</tr>
<tr class="odd">
<td align="left"><a href="https://www.otago.ac.nz/density/html/coulombe.html">housemouse</a></td>
<td align="left"><em>Mus musculus</em> live-trapping data of H. N. Coulombe published as a CAPTURE example by <span class="citation">Otis et al. (<a href="#ref-obwa78">1978</a>)</span></td>
</tr>
<tr class="even">
<td align="left"><a href="https://www.otago.ac.nz/density/html/ovenbird.html">ovenbird</a></td>
<td align="left">Multi-year mist-netting study of ovenbirds <em>Seiurus aurocapilla</em> at a site in Maryland, USA <span class="citation">(<a href="#ref-de09">Dawson and Efford 2009</a>)</span></td>
</tr>
<tr class="odd">
<td align="left"><a href="https://www.otago.ac.nz/density/html/ovensong.html">ovensong</a></td>
<td align="left">Acoustic detections of ovenbirds <span class="citation">(<a href="#ref-de09">Dawson and Efford 2009</a>)</span></td>
</tr>
<tr class="even">
<td align="left"><a href="https://www.otago.ac.nz/density/html/OVpossum.html">OVpossum</a></td>
<td align="left">Brushtail possum <em>Trichosurus vulpecula</em> live trapping in the Orongorongo Valley, Wellington, New Zealand 1996–1997 <span class="citation">(<a href="#ref-ec04">Efford and Cowan 2004</a>)</span></td>
</tr>
<tr class="odd">
<td align="left"><a href="https://www.otago.ac.nz/density/html/possum.html">possum</a></td>
<td align="left">Brushtail possum <em>Trichosurus vulpecula</em> live trapping at Waitarere, North Island, New Zealand April 2002 <span class="citation">(<a href="#ref-ewcb05">Efford et al. 2005</a>)</span></td>
</tr>
<tr class="even">
<td align="left"><a href="https://www.otago.ac.nz/density/html/secrdemo.html">secrdemo</a></td>
<td align="left">Simulated data ‘captdata’, and some fitted models</td>
</tr>
<tr class="odd">
<td align="left"><a href="https://www.otago.ac.nz/density/html/skink.html">skink</a></td>
<td align="left">Multi-session lizard (<em>Oligosoma infrapunctatum</em> and <em>O. lineoocellatum</em>) pitfall trapping data from Lake Station, Upper Buller Valley, South Island, New Zealand (Efford et al. in prep)</td>
</tr>
<tr class="even">
<td align="left"><a href="https://www.otago.ac.nz/density/html/stoatDNA.html">stoatDNA</a></td>
<td align="left">Stoat <em>Mustela erminea</em> hair tube DNA data from Matakitaki Valley, South Island, New Zealand <span class="citation">(<a href="#ref-ebb09">Efford, Borchers, and Byrom 2009</a>)</span></td>
</tr>
</tbody>
</table>
<!--chapter:end:17-datasets.Rmd-->
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="unnumbered">References</h1>
<!--chapter:end:17-references.Rmd-->
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-R-akima" class="csl-entry">
Akima, Hiroshi, and Albrecht Gebhardt. 2022. <em>Akima: Interpolation of Irregularly and Regularly Spaced Data</em>. <a href="https://CRAN.R-project.org/package=akima">https://CRAN.R-project.org/package=akima</a>.
</div>
<div id="ref-R-RcppParallel" class="csl-entry">
Allaire, JJ, Romain Francois, Kevin Ushey, Gregory Vandenbrouck, Marcus Geelnard, and Intel. 2023. <em>RcppParallel: Parallel Programming Tools for ’Rcpp’</em>. <a href="https://CRAN.R-project.org/package=RcppParallel">https://CRAN.R-project.org/package=RcppParallel</a>.
</div>
<div id="ref-Augustine2018" class="csl-entry">
Augustine, Ben C., J. Andrew Royle, Marcella J. Kelly, Christopher B. Satter, Robert S. Alonso, Erin E. Boydston, and Kevin R. Crooks. 2018. <span>“Spatial Capture–Recapture with Partial Identity: An Application to Camera Traps.”</span> <em>The Annals of Applied Statistics</em> 12 (1). <a href="https://doi.org/10.1214/17-aoas1091">https://doi.org/10.1214/17-aoas1091</a>.
</div>
<div id="ref-Bischof2020" class="csl-entry">
Bischof, Richard, Pierre Dupont, Cyril Milleret, Joseph Chipperfield, and J. Andrew Royle. 2020. <span>“Consequences of Ignoring Group Association in Spatial Capture–Recapture Analysis.”</span> <em>Wildlife Biology</em> 2020 (1). <a href="https://doi.org/10.2981/wlb.00649">https://doi.org/10.2981/wlb.00649</a>.
</div>
<div id="ref-Borchers2002" class="csl-entry">
Borchers, D. L., S. T. Buckland, and W. Zucchini. 2002. <em>Estimating Animal Abundance</em>. <em>Statistics for Biology and Health</em>. Springer London. <a href="https://doi.org/10.1007/978-1-4471-3708-5">https://doi.org/10.1007/978-1-4471-3708-5</a>.
</div>
<div id="ref-be08" class="csl-entry">
Borchers, D. L., and M. G. Efford. 2008. <span>“Spatially Explicit Maximum Likelihood Methods for Capture-Recapture Studies.”</span> <em>Biometrics</em> 64: 377–85.
</div>
<div id="ref-bf16" class="csl-entry">
Borchers, D. L., and R. Fewster. 2016. <span>“Spatial Capture–Recapture Models.”</span> <em>Statistical Science</em> 31 (2). <a href="https://doi.org/10.1214/16-sts557">https://doi.org/10.1214/16-sts557</a>.
</div>
<div id="ref-bk14" class="csl-entry">
Borchers, D. L., and D. J. Kidney. 2014. <em>Flexible Density Surface Estimation Using Regression Splines with Spatially Explicit Capture-Recapture Data</em>. In prep.
</div>
<div id="ref-Borchers2015" class="csl-entry">
Borchers, D. L., B. C. Stevenson, D. Kidney, L. Thomas, and T. A. Marques. 2015. <span>“A Unifying Model for Capture–Recapture and Distance Sampling Surveys of Wildlife Populations.”</span> <em>Journal of the American Statistical Association</em> 110 (509): 195–204. <a href="https://doi.org/10.1080/01621459.2014.893884">https://doi.org/10.1080/01621459.2014.893884</a>.
</div>
<div id="ref-bvns02" class="csl-entry">
Boyce, M. S., P. R. Vernier, S. E. Nielsen, and F. K. A. Schmiegelow. 2002. <span>“Evaluating Resource Selection Functions.”</span> <em>Ecological Modelling</em> 157: 281–300.
</div>
<div id="ref-Brooks1997" class="csl-entry">
Brooks, S. P., B. J. T. Morgan, M. S. Ridout, and S. E. Pack. 1997. <span>“Finite Mixture Models for Proportions.”</span> <em>Biometrics</em> 53 (3): 1097. <a href="https://doi.org/10.2307/2533567">https://doi.org/10.2307/2533567</a>.
</div>
<div id="ref-bablbt01" class="csl-entry">
Buckland, S. T., D. R. Anderson, K. P. Burnham, J. L. Laake, D. L. Borchers, and L. Thomas. 2001. <em>Introduction to Distance Sampling</em>. Oxford: Oxford University Press.
</div>
<div id="ref-Buckland2015" class="csl-entry">
Buckland, S. T., E. A. Rexstad, T. A. Marques, and C. S. Oedekoven. 2015. <em>Distance Sampling: Methods and Applications</em>. Springer eBook Collection. Cham: Springer.
</div>
<div id="ref-Burnham1987" class="csl-entry">
Burnham, K. P., D. R. Anderson, G. C. White, C. Brownie, and K. H. Pollock. 1987. <em>Design and Analysis Methods for Fish Survival Experiments Based on Release-Recapture</em>. American Fisheries Society.
</div>
<div id="ref-cc58" class="csl-entry">
Calhoun, J. B., and J. U. Casby. 1958. <span>“Calculation of Home Range and Density of Small Mammals.”</span> <em>Public Health Monograph</em>, no. 55.
</div>
<div id="ref-cr13" class="csl-entry">
Chandler, R. B., and J. A. Royle. 2013. <span>“Spatially Explicit Models for Inference about Density in Unmarked or Partially Marked Populations.”</span> <em>Annals of Applied Statistics</em> 7: 936–54.
</div>
<div id="ref-Chao1989" class="csl-entry">
Chao, Anne. 1989. <span>“Estimating Population Size for Sparse Data in Capture-Recapture Experiments.”</span> <em>Biometrics</em> 45 (2): 427. <a href="https://doi.org/10.2307/2531487">https://doi.org/10.2307/2531487</a>.
</div>
<div id="ref-cw" class="csl-entry">
Cooch, E., and G White, eds. 2023. <em>Program MARK: A Gentle Introduction.</em> 23rd ed. <a href="http://www.phidot.org/software/mark/docs/book/">http://www.phidot.org/software/mark/docs/book/</a>.
</div>
<div id="ref-cn06" class="csl-entry">
Csardi, G., and T. Nepusz. 2006. <span>“The Igraph Software Package for Complex Network Research.”</span> <em>InterJournal</em> 1695. <a href="http://igraph.org">http://igraph.org</a>.
</div>
<div id="ref-de09" class="csl-entry">
Dawson, D. K., and M. G. Efford. 2009. <span>“Bird Population Density Estimated from Acoustic Signals.”</span> <em>Journal of Applied Ecology</em> 46: 1201–9.
</div>
<div id="ref-Distiller2015" class="csl-entry">
Distiller, G., and D. L. Borchers. 2015. <span>“A Spatially Explicit Capture–Recapture Estimator for Single‐catch Traps.”</span> <em>Ecology and Evolution</em> 5 (21): 5075–87. <a href="https://doi.org/10.1002/ece3.1748">https://doi.org/10.1002/ece3.1748</a>.
</div>
<div id="ref-d13" class="csl-entry">
Dorazio, R. M. 2013. <span>“Bayes and Empirical Bayes Estimators of Abundance and Density from Spatial Capture-Recapture Data.”</span> <em>PLoS ONE</em> 8: e84017.
</div>
<div id="ref-R-spsurvey" class="csl-entry">
Dumelle, M., T. M. Kincaid, A. R. Olsen, and M. H. Weber. 2024. <em>Spsurvey: Spatial Sampling Design and Analysis</em>. <em>R Package Version 5.5.1</em>. <a href="https://CRAN.R-project.org/package=spsurvey">https://CRAN.R-project.org/package=spsurvey</a>.
</div>
<div id="ref-drns21" class="csl-entry">
Dupont, G., J. A. Royle, M. A. Nawaz, and C. Sutherland. 2021. <span>“Optimal Sampling Design for Spatial Capture-Recapture.”</span> <em>Ecology</em> 102: e03262.
</div>
<div id="ref-Durbach2024" class="csl-entry">
Durbach, I., R. Chopara, D. L. Borchers, R. Phillip, K. Sharma, and B. C. Stevenson. 2024. <span>“That’s Not the Mona Lisa! How to Interpret Spatial Capture-Recapture Density Surface Estimates.”</span> <em>Biometrics</em> 80 (1). <a href="https://doi.org/10.1093/biomtc/ujad020">https://doi.org/10.1093/biomtc/ujad020</a>.
</div>
<div id="ref-R-Rcpp" class="csl-entry">
Eddelbuettel, Dirk, Romain Francois, JJ Allaire, Kevin Ushey, Qiang Kou, Nathan Russell, Inaki Ucar, Douglas Bates, and John Chambers. 2023. <em>Rcpp: Seamless r and c++ Integration</em>. <a href="https://CRAN.R-project.org/package=Rcpp">https://CRAN.R-project.org/package=Rcpp</a>.
</div>
<div id="ref-R-stars" class="csl-entry">
Edzer, E., and R. Bivand. 2023. <em><span class="nocase">Spatial Data Science: With applications in R</span></em>. London: Chapman; Hall/CRC. <a href="https://doi.org/10.1201/9780429459016">https://doi.org/10.1201/9780429459016</a>.
</div>
<div id="ref-e04" class="csl-entry">
Efford, M. G. 2004. <span>“Density Estimation in Live-Trapping Studies.”</span> <em>Oikos</em> 106: 598–610.
</div>
<div id="ref-e11" class="csl-entry">
———. 2011. <span>“Estimation of Population Density by Spatially Explicit Capture-Recapture Analysis of Data from Area Searches.”</span> <em>Ecology</em> 92: 2202–7.
</div>
<div id="ref-e12" class="csl-entry">
———. 2012. <em>DENSITY 5.0: Software for Spatially Explicit Capture-Recapture</em>. Dunedin, New Zealand: Department of Mathematics; Statistics, University of Otago. <a href="https://www.otago.ac.nz/density">https://www.otago.ac.nz/density</a>.
</div>
<div id="ref-e14" class="csl-entry">
———. 2014. <span>“Bias from Heterogeneous Usage of Space in Spatially Explicit Capture-Recapture Analyses.”</span> <em>Methods in Ecology and Evolution</em> 5: 599–602.
</div>
<div id="ref-R-secrdesign" class="csl-entry">
———. 2023a. <em>Secrdesign: Sampling Design for Spatially Explicit Capture-Recapture</em>. <a href="https://CRAN.R-project.org/package=secrdesign">https://CRAN.R-project.org/package=secrdesign</a>.
</div>
<div id="ref-R-secrlinear" class="csl-entry">
———. 2023b. <em>Secrlinear: Spatially Explicit Capture-Recapture for Linear Habitats</em>. <a href="https://CRAN.R-project.org/package=secrlinear">https://CRAN.R-project.org/package=secrlinear</a>.
</div>
<div id="ref-Efford2023" class="csl-entry">
———. 2023c. <span>“<span class="nocase">ipsecr: An R package for awkward spatial capture–recapture data</span>.”</span> <em>Methods in Ecology and Evolution</em> 14 (5): 1182–89. <a href="https://doi.org/10.1111/2041-210x.14088">https://doi.org/10.1111/2041-210x.14088</a>.
</div>
<div id="ref-R-secr" class="csl-entry">
———. 2024. <em><span class="nocase">secr: Spatially explicit capture-recapture models</span></em>. <a href="https://CRAN.R-project.org/package=secr">https://CRAN.R-project.org/package=secr</a>.
</div>
<div id="ref-ebb09" class="csl-entry">
Efford, M. G., D. L. Borchers, and A. E. Byrom. 2009. <span>“Density Estimation by Spatially Explicit Capture-Recapture: Likelihood-Based Methods.”</span> In <em>Modeling Demographic Processes in Marked Populations</em>, edited by D. L. Thomson, E. G. Cooch, and M. J. Conroy, 255–69. New York.: Springer.
</div>
<div id="ref-ebm13" class="csl-entry">
Efford, M. G., D. L. Borchers, and G. Mowat. 2013. <span>“Varying Effort in Capture-Recapture Studies.”</span> <em>Methods in Ecology and Evolution</em> 4: 629–36.
</div>
<div id="ref-eb19" class="csl-entry">
Efford, M. G., and J. Boulanger. 2019. <span>“Fast Evaluation of Study Designs for Spatially Explicit Capture-Recapture.”</span> <em>Methods in Ecology and Evolution</em> 10: 1529–35. <a href="https://doi.org/10.1111/2041-210X.13239">https://doi.org/10.1111/2041-210X.13239</a>.
</div>
<div id="ref-ec04" class="csl-entry">
Efford, M. G., and P. E. Cowan. 2004. <span>“Long-Term Population Trend of <em>Trichosurus <span class="nocase">v</span>ulpecula</em> in the Orongorongo Valley, New Zealand.”</span> In <em>The Biology of Australian Possums and Gliders</em>, edited by R. L. Goldingay and S. M. Jackson, 471–83. Chipping Norton: Surrey Beatty &amp; Sons.
</div>
<div id="ref-edb09" class="csl-entry">
Efford, M. G., D. K. Dawson, and D. L. Borchers. 2009. <span>“Population Density Estimated from Locations of Individuals on a Passive Detector Array.”</span> <em>Ecology</em> 90: 2676–82.
</div>
<div id="ref-edjq16" class="csl-entry">
Efford, M. G., D. K. Dawson, Y. V. Jhala, and Q. Qureshi. 2016. <span>“Density-Dependent Home-Range Size Revealed by Spatially Explicit Capture-Recapture.”</span> <em>Ecography</em> 39: 676–88.
</div>
<div id="ref-edr04" class="csl-entry">
Efford, M. G., D. K. Dawson, and C. S. Robbins. 2004. <span>“DENSITY: Software for Analysing Capture-Recapture Data from Passive Detector Arrays.”</span> <em>Animal Biodiversity and Conservation</em> 27: 217–28.
</div>
<div id="ref-ef13" class="csl-entry">
Efford, M. G., and R. M. Fewster. 2013. <span>“Estimating Population Size by Spatially Explicit Capture-Recapture.”</span> <em>Oikos</em> 122: 918–28.
</div>
<div id="ref-eh18" class="csl-entry">
Efford, M. G., and C. M. Hunter. 2018. <span>“Spatial Capture-Mark-Resight Estimation of Animal Population Density.”</span> <em>Biometrics</em> 74: 411–20. <a href="https://doi.org/10.1111/biom.12766">https://doi.org/10.1111/biom.12766</a>.
</div>
<div id="ref-em14" class="csl-entry">
Efford, M. G., and G. Mowat. 2014. <span>“Compensatory Heterogeneity in Spatially Explicit Capture-Recapture Data.”</span> <em>Ecology</em> 95: 1341–48.
</div>
<div id="ref-es20" class="csl-entry">
Efford, M. G., and M. R. Schofield. 2020. <span>“A Spatial Open-Population Capture-Recapture Model.”</span> <em>Biometrics</em> 76: 392–402.
</div>
<div id="ref-ewcb05" class="csl-entry">
Efford, M. G., B. Warburton, M. C. Coleman, and R. J. Barker. 2005. <span>“A Field Test of Two Methods for Density Estimation.”</span> <em>Wildlife Society Bulletin</em> 33: 731–38.
</div>
<div id="ref-Ergon2013" class="csl-entry">
Ergon, T., and B. Gardner. 2013. <span>“Separating Mortality and Emigration: Modelling Space Use, Dispersal and Survival with Robust‐design Spatial Capture–Recapture Data.”</span> Edited by Evan Cooch. <em>Methods in Ecology and Evolution</em> 5 (12): 1327–36. <a href="https://doi.org/10.1111/2041-210x.12133">https://doi.org/10.1111/2041-210x.12133</a>.
</div>
<div id="ref-Evans1996" class="csl-entry">
Evans, Marc A., Hag-Min Kim, and Timothy E. O’Brien. 1996. <span>“An Application of Profile-Likelihood Based Confidence Interval to Capture: Recapture Estimators.”</span> <em>Journal of Agricultural, Biological, and Environmental Statistics</em> 1 (1): 131. <a href="https://doi.org/10.2307/1400565">https://doi.org/10.2307/1400565</a>.
</div>
<div id="ref-grw09" class="csl-entry">
Gardner, B., J. A. Royle, and M. T. Wegan. 2009. <span>“Hierarchical Models for Estimating Density from DNA Mark-Recapture Studies.”</span> <em>Ecology</em> 90: 1106–15.
</div>
<div id="ref-Gopalaswamy2012" class="csl-entry">
Gopalaswamy, A. M., J. A. Royle, M. Delampady, J. D. Nichols, K. U. Karanth, and D. W. Macdonald. 2012. <span>“Density Estimation in Tiger Populations: Combining Information for Strong Inference.”</span> <em>Ecology</em> 93 (7): 1741–51. <a href="https://doi.org/10.1890/11-2110.1">https://doi.org/10.1890/11-2110.1</a>.
</div>
<div id="ref-SPACECAP" class="csl-entry">
Gopalaswamy, A. M., J. A. Royle, M. E. Meredith, P. Singh, D. Jathanna, N. S. Kumar, and K. U. Karanth. 2014. <em>A Program to Estimate Animal Abundance and Density Using Bayesian Spatially-Explicit Capture-Recapture Models</em>.
</div>
<div id="ref-hb83" class="csl-entry">
Hayes, R. J., and S. T. Buckland. 1983. <span>“Radial-Distance Models for the Line-Transect Method.”</span> <em>Biometrics</em> 39: 29–42.
</div>
<div id="ref-R-raster" class="csl-entry">
Hijmans, R. J. 2023a. <em>Raster: Geographic Data Analysis and Modeling</em>. <em>R Package Version 3.6-26</em>. <a href="https://CRAN.R-project.org/package=raster">https://CRAN.R-project.org/package=raster</a>.
</div>
<div id="ref-R-terra" class="csl-entry">
———. 2023b. <em>Terra: Spatial Data Analysis</em>. <a href="https://CRAN.R-project.org/package=terra">https://CRAN.R-project.org/package=terra</a>.
</div>
<div id="ref-h89" class="csl-entry">
Huggins, R. M. 1989. <span>“On the Statistical Analysis of Capture Experiments.”</span> <em>Biometrika</em> 76: 133–40.
</div>
<div id="ref-Huxley1934" class="csl-entry">
Huxley, J. S. 1934. <span>“A Natural Experiment on the Territorial Instinct.”</span> <em>British Birds</em> 27: 270–77.
</div>
<div id="ref-illian08" class="csl-entry">
Illian, J., A. Penttinen, H. Stoyan, and D. Stoyan. 2008. <em>Statistical Analysis and Modelling of Spatial Point Patterns</em>. Chichester, UK: Wiley.
</div>
<div id="ref-j80" class="csl-entry">
Johnson, D. H. 1980. <span>“The Comparison of Usage and Availability Measurements for Evaluating Resource Preference.”</span> <em>Ecology</em> 61: 65–71.
</div>
<div id="ref-lc24" class="csl-entry">
Laake, J. L., and B. A. Collier. 2024. <span>“Understanding Implications of Detection Heterogeneity in Wildlife Abundance Estimation.”</span> <em>Journal of Wildlife Management</em> 88: e22516. <a href="https://doi.org/10.1002/jwmg.22516">https://doi.org/10.1002/jwmg.22516</a>.
</div>
<div id="ref-mtr11" class="csl-entry">
Marques, T. A., L. Thomas, and J. A. Royle. 2011. <span>“A Hierarchical Model for Spatial Capture-Recapture Data: Comment.”</span> <em>Ecology</em> 92: 526–28.
</div>
<div id="ref-mmpcl13" class="csl-entry">
Matechou, E., B. J. T. Morgan, S. Pledger, J. A. Collazo, and J. E. Lyons. 2013. <span>“Integrated Analysis of Capture-Recapture-Resighting Data and Counts of Unmarked Birds at Stopover Sites.”</span> <em>Journal of Agricultural, Biological and Environmental Statistics</em> 18: 120–35.
</div>
<div id="ref-mw12" class="csl-entry">
McClintock, B. T., and G. C. White. 2012. <span>“From NOREMARK to MARK: Software for Estimating Demographic Parameters Using Mark-Resight Methodology.”</span> <em>Journal of Ornithology, Supplement 2</em> 152: S641–50.
</div>
<div id="ref-McCrea2010" class="csl-entry">
McCrea, Rachel S., and Byron J. T. Morgan. 2010. <span>“Multistate Mark-Recapture Model Selection Using Score Tests.”</span> <em>Biometrics</em> 67: 234–41. <a href="https://doi.org/10.1111/j.1541-0420.2010.01421.x">https://doi.org/10.1111/j.1541-0420.2010.01421.x</a>.
</div>
<div id="ref-ms00" class="csl-entry">
Mowat, G., and C. Strobeck. 2000. <span>“Estimating Population Size of Grizzly Bears Using Hair Capture, DNA Profiling, and Mark-Recapture Analysis.”</span> <em>Journal of Wildlife Management</em> 64: 183–93.
</div>
<div id="ref-obwa78" class="csl-entry">
Otis, D. L., K. P. Burnham, G. C. White, and D. R. Anderson. 1978. <span>“Statistical Inference from Capture Data on Closed Animal Populations.”</span> <em>Wildlife Monographs</em>, no. 62.
</div>
<div id="ref-R-sf" class="csl-entry">
Pebesma, E. J. 2018. <span>“<span class="nocase">Simple Features for R: Standardized Support for Spatial Vector Data</span>.”</span> <em><span>The R Journal</span></em> 10 (1): 439–46. <a href="https://doi.org/10.32614/RJ-2018-009">https://doi.org/10.32614/RJ-2018-009</a>.
</div>
<div id="ref-R-sp" class="csl-entry">
Pebesma, E. J., and R. Bivand. 2005. <span>“Classes and Methods for Spatial Data in <span>R</span>.”</span> <em>R News</em> 5 (2): 9–13. <a href="https://CRAN.R-project.org/doc/Rnews/">https://CRAN.R-project.org/doc/Rnews/</a>.
</div>
<div id="ref-p2000" class="csl-entry">
Pledger, S. 2000. <span>“Unified Maximum Likelihood Estimates for Closed Capture-Recapture Models Using Mixtures.”</span> <em>Biometrics</em> 56: 434–42.
</div>
<div id="ref-R-base" class="csl-entry">
R Core Team. 2024. <em>R: A Language and Environment for Statistical Computing</em>. Vienna, Austria: R Foundation for Statistical Computing. <a href="https://www.R-project.org/">https://www.R-project.org/</a>.
</div>
<div id="ref-rksnmapdbed14" class="csl-entry">
Rich, L. N., M. J. Kelly, R. Sollmann, A. J. Noss, L. Maffei, R. L. Arispe, A. Paviolo, et al. 2014. <span>“Comparing Capture-Recapture, Mark-Resight, and Spatial Mark-Resight Models for Estimating Puma Densities via Camera Traps.”</span> <em>Journal of Mammalogy</em> 95: 382–91.
</div>
<div id="ref-rcgg13" class="csl-entry">
Royle, J. A., R. B. Chandler, K. D. Gazenski, and T. A. Graves. 2013. <span>“Spatial Capture-Recapture Models for Jointly Estimating Population Density and Landscape Connectivity.”</span> <em>Ecology</em> 94: 287–94.
</div>
<div id="ref-rcsg14" class="csl-entry">
Royle, J. A., R. B. Chandler, R. Sollmann, and B. Gardner. 2014. <em>Spatial Capture-Recapture</em>. Academic Press.
</div>
<div id="ref-Royle2015" class="csl-entry">
Royle, J. A., A. K. Fuller, and C. Sutherland. 2015. <span>“Spatial Capture–Recapture Models Allowing Markovian Transience or Dispersal.”</span> <em>Population Ecology</em> 58 (1): 53–62. <a href="https://doi.org/10.1007/s10144-015-0524-z">https://doi.org/10.1007/s10144-015-0524-z</a>.
</div>
<div id="ref-rg11" class="csl-entry">
Royle, J. A., and B. Gardner. 2011. <span>“Hierarchical Spatial Capture-Recapture Models for Estimating Density from Trapping Arrays.”</span> In <em>Camera Traps in Animal Ecology: Methods and Analyses</em>, edited by A. F. O’Connell, J. D. Nichols, and K. U. Karanth, 163–90. Tokyo, Japan: Springer.
</div>
<div id="ref-Royle2009" class="csl-entry">
Royle, J. A., K. U. Karanth, A. M. Gopalaswamy, and N. S. Kumar. 2009. <span>“Bayesian Inference in Camera Trapping Studies for a Class of Spatial Capture–Recapture Models.”</span> <em>Ecology</em> 90 (11): 3233–44. <a href="https://doi.org/10.1890/08-1481.1">https://doi.org/10.1890/08-1481.1</a>.
</div>
<div id="ref-rmgvl11" class="csl-entry">
Royle, J. A., A. J. Magoun, B. Gardner, P. Valkenburg, and R. E. Lowell. 2011. <span>“Density Estimation in a Wolverine Population Using Spatial Capture-Recapture Models.”</span> <em>Journal of Wildlife Management</em> 75: 604–11.
</div>
<div id="ref-rnug09" class="csl-entry">
Royle, J. A., J. D. Nichols, K. U. Karanth, and A. M. Gopalaswamy. 2009. <span>“A Hierarchical Model for Estimating Density in Camera‐trap Studies.”</span> <em>Journal of Applied Ecology</em> 46 (1): 118–27. <a href="https://doi.org/10.1111/j.1365-2664.2008.01578.x">https://doi.org/10.1111/j.1365-2664.2008.01578.x</a>.
</div>
<div id="ref-ry08" class="csl-entry">
Royle, J. A., and K. V. Young. 2008. <span>“A Hierarchical Model for Spatial Capture-Recapture Data.”</span> <em>Ecology</em> 89: 2281–89.
</div>
<div id="ref-rswmd15" class="csl-entry">
Rutledge, M. E., R. Sollmann, B. E. Washburn, C. E. Moorman, and C. S. DePerno. 2015. <span>“Using Novel Spatial Mark-Resight Techniques to Monitor Resident Canada Geese in a Suburban Environment.”</span> <em>Wildlife Research</em> 41: 447–53.
</div>
<div id="ref-s82" class="csl-entry">
Seber, G. A. F. 1982. <em>The Estimation of Animal Abundance and Related Parameters.</em> 2nd ed. London: Griffin.
</div>
<div id="ref-Sollmann2024" class="csl-entry">
Sollmann, Rahel. 2024. <span>“Mt or Not Mt: Temporal Variation in Detection Probability in Spatial Capture-Recapture and Occupancy Models.”</span> <em>Peer Community Journal</em> 4 (January). <a href="https://doi.org/10.24072/pcjournal.357">https://doi.org/10.24072/pcjournal.357</a>.
</div>
<div id="ref-sgpsmspo13" class="csl-entry">
Sollmann, R., B. Gardner, A. W. Parsons, J. J. Stocking, B. T. McClintock, T. R. Simons, K. H. Pollock, and A. F. O’Connell. 2013. <span>“A Spatial Mark-Resight Model Augmented with Telemetry Data.”</span> <em>Ecology</em> 94: 553–59.
</div>
<div id="ref-Stephens2000" class="csl-entry">
Stephens, M. 2000. <span>“Dealing with Label Switching in Mixture Models.”</span> <em>Journal of the Royal Statistical Society Series B</em> 62: 795–809.
</div>
<div id="ref-sfr15" class="csl-entry">
Sutherland, C., A. K. Fuller, and J. A. Royle. 2015. <span>“Modelling Non-Euclidean Movement and Landscape Connectivity in Highly Structured Ecological Networks.”</span> <em>Methods in Ecology and Evolution</em> 6: 169–77.
</div>
<div id="ref-srl19" class="csl-entry">
Sutherland, C., J. A. Royle, and D. W. Linden. 2019. <span>“oSCR: A Spatial Capture-Recapture r Package for Inference about Spatial Ecological Processes.”</span> <em>Ecography</em> 42: 1459–69. <a href="https://doi.org/10.1111/ecog.04551">https://doi.org/10.1111/ecog.04551</a>.
</div>
<div id="ref-Turek2021" class="csl-entry">
Turek, Daniel, Cyril Milleret, Torbjørn Ergon, Henrik Brøseth, Pierre Dupont, Richard Bischof, and Perry de Valpine. 2021. <span>“Efficient Estimation of Large‐scale Spatial Capture–Recapture Models.”</span> <em>Ecosphere</em> 12 (2). <a href="https://doi.org/10.1002/ecs2.3385">https://doi.org/10.1002/ecs2.3385</a>.
</div>
<div id="ref-R-gdistance" class="csl-entry">
van Etten, J. 2023. <em>Gdistance: Distances and Routes on Geographical Grids</em>. <a href="https://CRAN.R-project.org/package=gdistance">https://CRAN.R-project.org/package=gdistance</a>.
</div>
<div id="ref-whc18" class="csl-entry">
Whittington, J., M. Hebblewhite, and R. Chandler. 2018. <span>“Generalized Spatial Mark-Resight Models with an Application to Grizzly Bears.”</span> <em>Journal of Applied Ecology</em> 55: 157–68.
</div>
<div id="ref-wnc02" class="csl-entry">
Williams, B. K., J. D. Nichols, and M. J. Conroy. 2002. <em>Analysis and Management of Animal Populations</em>. San Diego: Academic Press.
</div>
<div id="ref-w06" class="csl-entry">
Wood, S. N. 2006. <em>Generalized Additive Models: An Introduction with <span>R</span></em>. Chapman; Hall/CRC.
</div>
<div id="ref-Zhang2022" class="csl-entry">
Zhang, Wei, Joseph D. Chipperfield, Janine B. Illian, Pierre Dupont, Cyril Milleret, Perry de Valpine, and Richard Bischof. 2022. <span>“A Flexible and Efficient Bayesian Implementation of Point Process Models for Spatial Capture–Recapture Data.”</span> <em>Ecology</em> 104 (1). <a href="https://doi.org/10.1002/ecy.3887">https://doi.org/10.1002/ecy.3887</a>.
</div>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr />
<ol>
<li id="fn1"><p>A closed population is one in which the composition of the population and the activity distributions of individuals can be assumed fixed for the duration of sampling.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>The earlier Bayesian SECR package <strong>SPACECAP</strong> <span class="citation">(<a href="#ref-SPACECAP">Gopalaswamy et al. 2014</a>)</span> is no longer maintained and has been archived from CRAN.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>‘Activity centre’ is often used in preference to ‘home range centre’ because it appears more neutral: ‘home range’ implies a particular pattern of behaviour and spatial familiarity. In reality, SECR relies on the very pattern of behaviour (persistent use) that distinguishes a home range, so it is safe to use the terms interchangeably in this context.<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p>All detection functions have intercept (<span class="math inline">\(g_0\)</span>, <span class="math inline">\(\lambda_0\)</span>) and scale (<span class="math inline">\(\sigma\)</span>) parameters; some such as the hazard rate function have a further parameter that controls some aspect of shape.<a href="#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p>This is a shortened version of the tutorial in <a href="https://www.otago.ac.nz/density/pdfs/secr-tutorial.pdf">secr-tutorial.pdf</a>.<a href="#fnref5" class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p>See Appendix @ref(Spatialdata).<a href="#fnref6" class="footnote-back">↩︎</a></p></li>
<li id="fn7"><p>While noting that estimates of the detection parameter g0 are biased. For unbiased estimates see <strong><a href="https://CRAN.R-project.org/package=ipsecr">ipsecr</a></strong> and <span class="citation">Efford (<a href="#ref-Efford2023">2023c</a>)</span>.<a href="#fnref7" class="footnote-back">↩︎</a></p></li>
<li id="fn8"><p>We can get from beta parameter estimates to real parameter estimates by applying the inverse of the link function e.g. <span class="math inline">\(\hat D = \exp(\hat \beta_D)\)</span>, and similarly for confidence limits; standard errors require a delta-method approximation (Lebreton et al. 1992).<a href="#fnref8" class="footnote-back">↩︎</a></p></li>
<li id="fn9"><p>One hectare (ha) is 10000 m<sup>2</sup> or 0.01 km<sup>2</sup>.<a href="#fnref9" class="footnote-back">↩︎</a></p></li>
<li id="fn10"><p>This is not just the tail probability of a normal deviate; think about how the probability of an individual being detected at least once changes with (i) the duration of sampling (ii) the density of detector array.<a href="#fnref10" class="footnote-back">↩︎</a></p></li>
<li id="fn11"><p>These are Horvitz-Thompson-like estimates of density obtained by dividing the observed number of individuals <span class="math inline">\(n\)</span> by effective sampling areas (Borchers and Efford 2008) computed as the cumulative sum over mask cells ordered by distance from the traps. The algorithm treats the detection parameters as known and fixed.<a href="#fnref11" class="footnote-back">↩︎</a></p></li>
<li id="fn12"><p>We use <span class="math inline">\(D(\mathbf{x})\)</span> in preference to <span class="math inline">\(\lambda(\mathbf{x})\)</span> because <span class="math inline">\(\lambda\)</span> has multiple meanings.<a href="#fnref12" class="footnote-back">↩︎</a></p></li>
<li id="fn13"><p>Integration is commonly performed by summing over many small cells for a finite region near the detectors, as both <span class="math inline">\(\mbox{Pr}(\omega_i)\)</span> and <span class="math inline">\(f(\mathbf{x})\)</span> decline to zero at greater distances. We state the model in terms of the real plane and defer discussion of the region of integration to Chapter @ref(Habitat).<a href="#fnref13" class="footnote-back">↩︎</a></p></li>
<li id="fn14"><p>The parameter vectors <span class="math inline">\(\theta\)</span> and <span class="math inline">\(\theta^\prime\)</span> differ for detection functions expressed in terms of probability (<span class="math inline">\(g()\)</span>) and hazard (<span class="math inline">\(\lambda()\)</span>).
<!-- Subscripts $i,s$ are included for generality, allowing individual and temporal variation in detection probability, but more often than not these do not appear in the model ($\theta_{is} = \theta$ for all $i,s$) and $p_k$ is sufficient. --><a href="#fnref14" class="footnote-back">↩︎</a></p></li>
<li id="fn15"><p>‘Home range’ is used here loosely - a more nuanced explanation would distinguish between the stationary distribution of activity (the home-range utilisation distribution) and the spatial distribution of cues (opportunities for detection) generated by an individual.<a href="#fnref15" class="footnote-back">↩︎</a></p></li>
<li id="fn16"><p>Population size is sometimes termed ‘abundance’; we avoid this usage because ‘abundance’ can also be a catch-all for density and population size, and its overtones are vague and biblical rather than scientific.<a href="#fnref16" class="footnote-back">↩︎</a></p></li>
<li id="fn17"><p><span class="math inline">\(|A|\)</span> is the area of region <span class="math inline">\(A\)</span>.<a href="#fnref17" class="footnote-back">↩︎</a></p></li>
<li id="fn18"><p>Technically, these are S3 classes. A ‘class’ in R specifies a particular type of data object and the functions (methods) by which it is manipulated (computed, printed, plotted etc). See the R documentation for further explanation.<a href="#fnref18" class="footnote-back">↩︎</a></p></li>
<li id="fn19"><p>This applies even with a full-likelihood fit.<a href="#fnref19" class="footnote-back">↩︎</a></p></li>
<li id="fn20"><p>The transformation is non-linear so, for example, a half-normal form for <span class="math inline">\(g(.)\)</span> does not correspond to half-normal form for <span class="math inline">\(\lambda(.)\)</span>.<a href="#fnref20" class="footnote-back">↩︎</a></p></li>
<li id="fn21"><p>This use of ‘hazard’ has historical roots in distance sampling <span class="citation">(<a href="#ref-hb83">Hayes and Buckland 1983</a>)</span> and has no real connection to models for hazard as a function of distance.<a href="#fnref21" class="footnote-back">↩︎</a></p></li>
<li id="fn22"><p>Technically this is the cumulative hazard rather than the instantaneous hazard, but we get tired of using the full term.<a href="#fnref22" class="footnote-back">↩︎</a></p></li>
<li id="fn23"><p>The lack in <strong>secr</strong> of a probability function with variable power <span class="math inline">\(g(d) = g_0 \exp \{ -(^d/_\sigma)^{z} \}\)</span> is an historical accident (the obvious integer codes had been allocated, and attention had shifted to hazard functions, hence HVP). Maybe there will be a function VP in future.<a href="#fnref23" class="footnote-back">↩︎</a></p></li>
<li id="fn24"><p>The function <code>list.secr.fit</code> applies <code>secr.fit</code> with multiple settings, in this case different detection functions, and returns an ‘secrlist’, a list of fitted models. <code>list.secr.fit</code> was introduced in <strong>secr</strong> 4.6.6 to replace <code>par.secr.fit</code>.<a href="#fnref24" class="footnote-back">↩︎</a></p></li>
<li id="fn25"><p>Examples are <span class="citation">Gardner, Royle, and Wegan (<a href="#ref-grw09">2009</a>)</span>, <span class="citation">Royle and Gardner (<a href="#ref-rg11">2011</a>)</span> and <span class="citation">Royle et al. (<a href="#ref-rmgvl11">2011</a>)</span>, but not <span class="citation">Royle et al. (<a href="#ref-rcsg14">2014</a>)</span> and <span class="citation">Royle, Fuller, and Sutherland (<a href="#ref-Royle2015">2015</a>)</span>).<a href="#fnref25" class="footnote-back">↩︎</a></p></li>
<li id="fn26"><p>In the C++ code, two real-valued 3-dimensional arrays are populated with pre-computed values of <span class="math inline">\(p_{sk}(\mathbf{x})\)</span> (gk) and <span class="math inline">\(h_{sk}(\mathbf{x})\)</span> (hk). The dimensions are the number of unique parameter combinations <span class="math inline">\(C\)</span>, the number of detectors <span class="math inline">\(K\)</span> and the number of mask points <span class="math inline">\(M\)</span>. The memory requirement for these arrays alone is <span class="math inline">\(2.8.C.K.M\)</span> bytes, which for 200 detectors, 10000 mask points, and 100 parameter levels is 3.2 Gb. This is on top of the two parameter index arrays requiring <span class="math inline">\(2 . 4 . R. n. S. K. U\)</span> bytes for <span class="math inline">\(R\)</span> sessions and <span class="math inline">\(U\)</span> mixture classes (e.g. 10 sessions, 200 animals, 6 occasions, 200 detectors and 2 mixture classes, 0.0384 Gb), and a number of smaller objects.<a href="#fnref26" class="footnote-back">↩︎</a></p></li>
<li id="fn27"><p>We use ‘link-linear’ to describe a linear model on the link scale, where this may be log-linear, logit-linear etc.<a href="#fnref27" class="footnote-back">↩︎</a></p></li>
<li id="fn28"><p>The usage matrix for polygon and transect detectors has one row for each polygon or transect, rather than one row per vertex.<a href="#fnref28" class="footnote-back">↩︎</a></p></li>
<li id="fn29"><p>score tests <span class="citation">(<a href="#ref-McCrea2010">McCrea and Morgan 2010</a>)</span> are not appropriate because the models are not nested, at least that’s how it seems to me.<a href="#fnref29" class="footnote-back">↩︎</a></p></li>
<li id="fn30"><p>See <span class="citation">Dawson and Efford (<a href="#ref-de09">2009</a>)</span> and the vignette <a href="https://www.otago.ac.nz/density/pdfs/secr-sound.pdf">secr-sound.pdf</a> for another example of a multimodal likelihood in SECR.<a href="#fnref30" class="footnote-back">↩︎</a></p></li>
<li id="fn31"><p>We can also express the model as before <span class="math inline">\(\mathbf{y} = \mathbf{X} \pmb {\beta}\)</span>, where <span class="math inline">\(\mathbf{X}\)</span> is the design matrix, <span class="math inline">\(\pmb{\beta}\)</span> is a vector of coefficients, and <span class="math inline">\(\mathbf{y}\)</span> is the resulting vector of densities on the link scale. Rows of <span class="math inline">\(\mathbf{X}\)</span> and elements of <span class="math inline">\(\mathbf{y}\)</span> correspond to points on the habitat mask, possibly replicated in the case of group and session effects.<a href="#fnref31" class="footnote-back">↩︎</a></p></li>
<li id="fn32"><p>Technically, it may also be specified in a user-written function supplied to
<code>secr.fit</code> (see <a href="#userfnappendix">Appendix 1</a>), but you are unlikely to need this.<a href="#fnref32" class="footnote-back">↩︎</a></p></li>
<li id="fn33"><p>Null formulae such as <code>D ~ 1</code> may be omitted, and if a single formula is used, it may be presented on its own rather than in list() form.<a href="#fnref33" class="footnote-back">↩︎</a></p></li>
<li id="fn34"><p>Option available only for models specified in generalized linear model form with the ‘model’ argument of secr.fit, not for user-defined functions.<a href="#fnref34" class="footnote-back">↩︎</a></p></li>
<li id="fn35"><p>If you’re interested, function <code>bias.D</code> computes an approximation to this bias.<a href="#fnref35" class="footnote-back">↩︎</a></p></li>
<li id="fn36"><p>Character-valued covariates will be coerced to factors in <code>secr.fit</code>.<a href="#fnref36" class="footnote-back">↩︎</a></p></li>
<li id="fn37"><p>As an aside - covariates used in detection models should have a small number of discrete values, even when they represent a continuous quantity, because covariates with many values slow down computation and demand extra memory. There is no such constraint with mask covariates.<a href="#fnref37" class="footnote-back">↩︎</a></p></li>
<li id="fn38"><p>Care is needed: the estimates of realised population size (but not expected population size) are meaningless if the new region does not cover all <span class="math inline">\(n\)</span> detected animals. See <span class="citation">Efford and Fewster (<a href="#ref-ef13">2013</a>)</span> for more on realised and expected population size.<a href="#fnref38" class="footnote-back">↩︎</a></p></li>
<li id="fn39"><p>The cumulative hazard <span class="math inline">\(\lambda(d)\)</span> and probability <span class="math inline">\(g(d)\)</span> formulations are largely interchangeable because <span class="math inline">\(g(d) = 1 - \exp(-\lambda(d))\)</span>.<a href="#fnref39" class="footnote-back">↩︎</a></p></li>
<li id="fn40"><p><strong>secr</strong> names D, lambda0 or sigma.<a href="#fnref40" class="footnote-back">↩︎</a></p></li>
<li id="fn41"><p><strong>secr</strong> name a0<a href="#fnref41" class="footnote-back">↩︎</a></p></li>
<li id="fn42"><p><strong>secr</strong> uses sigmak = <span class="math inline">\(100k\)</span><a href="#fnref42" class="footnote-back">↩︎</a></p></li>
<li id="fn43"><p>This does not apply if you are using an artificial coordinates (e.g., from <code>make.grid</code>()) rather than importing actual locations.<a href="#fnref43" class="footnote-back">↩︎</a></p></li>
<li id="fn44"><p>The logic here is that hazards are additive whereas probabilities are not.<a href="#fnref44" class="footnote-back">↩︎</a></p></li>
<li id="fn45"><p>For constraints on the shape of polygon detectors see <a href="#polygonshape">Polygon shape</a><a href="#fnref45" class="footnote-back">↩︎</a></p></li>
<li id="fn46"><p>Alternatively, one can construct a mask with <code>make.mask</code> and provide that in the ‘mask’ argument of <code>secr.fit</code>. Note that <code>make.mask</code> defaults to <code>type = 'rectangular'</code>; see <a href="#transectsearch">Transect search</a> for an example in which points are dropped if they are within the rectangle but far from detectors (the default in <code>secr.fit</code>)<a href="#fnref46" class="footnote-back">↩︎</a></p></li>
<li id="fn47"><p>An important case is when some animals carry natural marks and others don’t, as in the puma study of <span class="citation">Rich et al. (<a href="#ref-rksnmapdbed14">2014</a>)</span>.<a href="#fnref47" class="footnote-back">↩︎</a></p></li>
<li id="fn48"><p>‘Count’ detectors most closely approximate sampling with replacement (McClintock and White 2012); sampling strictly without replacement implies detection at no more than one site per occasion (detector type ‘multi’) that has yet to be implemented for mark–resight data, and may prove difficult.<a href="#fnref48" class="footnote-back">↩︎</a></p></li>
<li id="fn49"><p>There may also be marking occasions on which recaptures are ignored, but this possibility has yet to be modelled.<a href="#fnref49" class="footnote-back">↩︎</a></p></li>
<li id="fn50"><p>A slight exception is the optional <a href="#areaspecification"><code>marking</code></a> mask covariate used for sighting-only data.<a href="#fnref50" class="footnote-back">↩︎</a></p></li>
<li id="fn51"><p>This is not an issue for sighting-only models as the marked fraction is not modelled.<a href="#fnref51" class="footnote-back">↩︎</a></p></li>
<li id="fn52"><p>The number of marked individuals may be estimated as a derived parameter if required.<a href="#fnref52" class="footnote-back">↩︎</a></p></li>
<li id="fn53"><p>Mixing 2-km and 0.5-km cells carries a slight penalty: the centres of a few 2-km cells (&lt;1%) do not lie in valid 0.5-km cells; these become inaccessible (infinite distance from all detectors) and are silently dropped in a later step.<a href="#fnref53" class="footnote-back">↩︎</a></p></li>
<li id="fn54"><p>Their indices are listed in component ‘D’ of the ‘parindx’ component of the fitted model (e.g. <code>fit1$parindx$D</code>), but you are unlikely to need this.<a href="#fnref54" class="footnote-back">↩︎</a></p></li>
<li id="fn55"><p>This constraint arises from the need internally to normalise the probability density function for each telemetry fix. The normalising constant for these functions is <span class="math inline">\(1/(2\pi \sigma^2)\)</span>, whereas for most other possible values of <code>detectfn</code> it is hard to compute or the function does not correspond to a probability density.<a href="#fnref55" class="footnote-back">↩︎</a></p></li>
<li id="fn56"><p><span class="math inline">\(\lambda(d_k(\mathbf{x})) = -\log[1 - g(d_k(\mathbf{x}))]\)</span>.<a href="#fnref56" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
<!--bookdown:body:end-->
  </main>

  <div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page">
      <h2>On this page</h2>
      <div id="book-on-this-page"></div>

      <div class="book-extra">
        <ul class="list-unstyled">
          <li><a id="book-source" href="#">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="#">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
      </div>
    </nav>
  </div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5">
  <div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Spatially Explicit Capture–Recapture</strong>" was written by Murray Efford. It was last built on 2024-02-28.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
<script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>

</html>
