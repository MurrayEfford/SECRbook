## Trend

**secr** is primarily for estimating closed population density (density at one point in time), but multi-session data may also be modelled to describe population trend over time. This section describes methods specifically for population trend, defined as change in density between sessions and measured by the finite rate of increase $\lambda_t = D_{t+1} / D_t$. 

Simple trend analysis may be achieved with a particular coding of the session factor as described in Chapter \@ref(Multisession). The more flexible methods described here allow the direct estimation of $\lambda_t$, possibly including covariate effects. 

### Direct estimation of $\lambda$

A satisfying and flexible approach is to parameterize the density model in terms of the initial density $D_1$ and the finite rates of increase $\lambda_t$ for the remaining sessions ($\lambda_1$ refers to the density increase between Session 1 and Session 2, etc.).

#### The Dlambda parameterization

Reparameterization of the density model is achieved internally in `secr.fit` by manipulating the density design matrix to provide a new array of mask-cell- and session-specific densities at each evaluation of the full likelihood. This happens when the details argument 'Dlambda' is set to TRUE. The density model (D~) and the fitted beta parameters take on a new meaning determined by the internal function `Dfn2`. More explanation is given [later](#Review).

Now, fitting the ovenbird model with D~1 results in two density parameters (density in session 1, constant finite rate of increase across remaining sessions):
```{r direct, cache = TRUE}
msk <- make.mask(traps(ovenCH[[1]]), buffer = 300, nx = 32)
fit1  <- secr.fit(ovenCH, model = D~1, mask = msk, trace = FALSE, 
                 details = list(Dlambda = TRUE))
coef(fit1)
```

Density-relevant beta parameters have names starting with 'D.'[^trend1]. The first is the log initial density; others relate to the $\lambda$ parameters.

[^trend1]: Their indices are listed in component 'D' of the 'parindx' component of the fitted model (e.g. `fit1$parindx$D`), but you are unlikely to need this.

### The summary function `predictDlambda`

To make the most of the reparameterization we need the special function `predictDlambda` to extract the lambda estimates (the simple `predict` method does not work).

```{r predictDfn2, cache = TRUE}
predictDlambda (fit1)
```

This is an advance on the earlier approach using sdif contrasts, as we have constrained $\lambda$ to a constant. 

### Covariate and other models

The method allows many covariate models for $\lambda$. We can fit a time trend in $\lambda$ using:

```{r direct2, cache = TRUE}
fit2  <- secr.fit(ovenCH, model = D~Session, mask = msk, trace = FALSE, 
                 details = list(Dlambda = TRUE))
predictDlambda (fit2)
```

Session-specific $\lambda$ (lower-case 'session') provide a direct comparison with the original analysis:

```{r direct3, cache = TRUE}
fit3  <- secr.fit(ovenCH, model = D~session, mask = msk, trace = FALSE, 
                 details = list(Dlambda = TRUE))
predictDlambda (fit3)
```

Model selection procedures apply as usual:
```{r AIC}
AIC(fit1, fit2, fit3, criterion = 'AIC')[,-6]
```

Session covariates are readily applied. The covariate for the second session predicts $\lambda_1 = D_2/D_1$, for the third session predicts $\lambda_2 = D_3/D_2$, etc. The covariate for the first session is discarded (remember $D_1$ is constant). This all may be confusing, but you can work it out, and it saves extra coding.

```{r direct4, cache = TRUE}
covs <- data.frame(acov = c(0,2,1,1,2))   # a fabricated covariate
fit4  <- secr.fit(ovenCH, model = D~acov, mask = msk, trace = FALSE, 
                 details = list(Dlambda = TRUE), sessioncov = covs)
predictDlambda (fit4)
```

### Fixing coefficients

Another possibility is to fit the model with fixed trend (the second beta 
coefficient corresponds to lambda, before). 

```{r fixedbeta, cache = TRUE}
fit5 <- secr.fit(ovenCH, model = D~1, mask = msk, trace = FALSE,
    details = list(Dlambda = TRUE, fixedbeta = c(NA, log(0.9), NA, NA)))
predictDlambda(fit5)
```

For comparison, this can be achieved more conventionally by fixing the 
beta coefficient in a model with log-linear trend over sessions (D~Session):

```{r fixedbeta2, cache = TRUE}
fit6 <- secr.fit(ovenCH, model = D~Session, mask = msk, trace = FALSE,
    details = list(Dlambda = FALSE, fixedbeta = c(NA, log(0.9), NA, NA)))
t(sapply(predict(fit6), '[', 'D', ))
```

### Technical notes and tips {#Review}

`Dfn2` performs some tricky manipulations. You can see the code by typing `secr:::Dfn2`. A column is pre-pended to the density design matrix specifically to model the initial density; this takes the value one in Session 1 and is otherwise zero. Other columns in the design matrix are set to zero for the first session. Session-specific density on the link (log) scale is computed as the cumulative sum across sessions of the initial log density and the modelled log-lambda values.

Note --

* The model allows detector locations and habitat masks to vary between sessions.

* The coding of `Dfn2` relies on a log link function for density.

* Dlambda is ignored for single-session data and conditional-likelihood (CL) models.

* The method is not (yet) suitable for group models.

* The default start values for D in `secr.fit` work well: all lambda are initially 1.0 ($\mbox{log}(\lambda_t) = 0$ for all $t$).

* If session covariates are used in any model, AICcompatible() expects the argument 'sessioncov' to be included in all models.

### Caveats

#### Spatial variation in density

D for session 1 is constant over space. It is not possible in the present version of **secr** to model simultaneous spatial variation in density or $\lambda$, and using Dlambda with a density model that includes spatial covariates will cause an error.

#### Underestimation of sampling variance

Underestimation of sampling variance is expected when a trend model is fitted to temporal samples with incomplete population turnover between sessions. The product likelihood assumes a new realisation of the underlying population process for each session. If in actuality much of the sampled population remains the same (the same individuals in the same home ranges) then the precision of the trend coefficient will be overstated. 

The effect is often small. Possible solutions are to fit an open population model (e.g., in **openCR** [@es20]) or to apply some form of bootstrapping.

## Appendix 1. Simulated example with known $\lambda$  {#Appendix2}

In this example the true $\lambda_t$ are (1, 2, 1, 1, 1.5) for sessions 1--5.

```{r simulation, cache = TRUE, warning = FALSE}
# traps and mask
grid144 <- make.grid(12,12, detector='proximity', spacing = 2)
grid144mask <- make.mask(grid144, spacing = 0.5, buffer = 4)
# simulate some data
set.seed(123)
# some warnings are suppressed
pop <- sim.popn(D = 3000, core = grid144, buffer = 4, nsessions = 6, 
                details = list(lambda = c(1, 2, 1, 1, 1.5)))
ch <- sim.capthist(grid144, popn = pop, detectfn = 'HHN', renumber = FALSE,
                   detectpar = list(lambda0 = 0.5, sigma = 1))
summary(ch, terse = TRUE)
```

## $\hat \lambda$ from sequence of density estimates

```{r simulationfit, cache = TRUE, warning = FALSE}
setNumThreads(18)   # adjust as required
fit0 <- secr.fit(ch, mask = grid144mask, detectfn = 'HHN', model = D ~ session, 
    trace = FALSE)
D <- sapply(predict(fit0), '[[', 'D', 'estimate')
D[2:6]/D[1:5]
```

## Old style $\hat \lambda$ using contr.sdif

```{r simulationfit2, cache = TRUE, warning = FALSE}
fit1 <- secr.fit(ch, mask = grid144mask, detectfn = 'HHN', model = D ~ session, 
    trace = FALSE, details = list(contrasts = list(session = MASS::contr.sdif)))
# lambda estimates
exp(coef(fit1)[2:6,1])
```

## Session-specific $\hat \lambda$

```{r simulationfit3, cache = TRUE, warning = FALSE}
fit2 <- secr.fit(ch, mask = grid144mask, detectfn = 'HHN', model = D~session, 
    trace = FALSE, details = list(Dlambda = TRUE))
predictDlambda(fit2)
```

## Using session covariate

The covariate used here is a perfect match to the original $\lambda$ - 
completely unrealistic, but a test of the idea. 

```{r simulationfit4, cache = TRUE, warning = FALSE}
covs <- data.frame(sesscov = log(c(1, 1, 2, 1, 1, 1.5)))
fit3 <- secr.fit(ch, mask = grid144mask, detectfn = 'HHN', model = D ~ sesscov,
    sessioncov = covs, trace = FALSE, details = list(Dlambda = TRUE))
predictDlambda(fit3)
```
